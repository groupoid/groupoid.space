\section{–ú–æ–≤–∞ –ø—Ä–æ—Å—Ç–æ—Ä—É}

–¶—è —Å—Ç–∞—Ç—Ç—è –ø—Ä–∏—Å–≤—è—á–µ–Ω–∞ —Ü—ñ–ª–∫–æ–º CCHM –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—É –≥–æ–º–æ—Ç–æ–ø—ñ—á–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏ —Ç–∏–ø—ñ–≤ –∑
–¥–≤–æ–º–∞ —Ä—ñ–≤–Ω–æ—Å—Ç—è–º–∏, –≤—ñ–¥–æ–º–æ—ó —è–∫ HTS —Å–∏—Å—Ç–µ–º–∞ –í–æ—î–≤–æ–¥—Å—å–∫–æ–≥–æ –∞–±–æ —Å–∏—Å—Ç–µ–º–∞ 2LTT
–ê–Ω–Ω–µ–Ω–∫–æ–≤–∞-–ö–∞–ø—Ä—ñ–æ—Ç—Ç—ñ-–ö—Ä–∞—É—Å–∞-–°–∞—Ç—Ç–ª–µ—Ä–∞. –ö—Ä—ñ–º —Ä—ñ–≤–Ω–æ—Å—Ç—ñ –Ω–∞ –ø—Ä–µ—Ç–∏–ø–∞—Ö,
–ê–Ω–¥–µ—Ä—Å –º—ñ—Å—Ç–∏—Ç—å —è–∫ –ø—Ä–∏–º—ñ—Ç–∏–≤ —Å—Ç–µ–∫ –¥–µ –†–∞–º–∞ –ß–µ—Ä—É–±—ñ–Ω—ñ-–®—Ä–∞–π–±–µ—Ä–∞, —â–æ —Ä–æ–±–∏—Ç—å
–π–æ–≥–æ –ø—Ä–∏–¥–∞—Ç–Ω–∏–º –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è –∫–æ–≥–æ–º–æ–ª–æ–≥—ñ–π —Ç–∞ —Å–∏–Ω—Ç–µ—Ç–∏—á–Ω–æ—ó –¥–∏—Ñ–µ—Ä–µ–Ω—Ü—ñ–∞–ª—å–Ω–æ—ó –≥–µ–æ–º–µ—Ç—Ä—ñ—ó.

\begin{lstlisting}
type exp =
  | EPre of Z.t | EKan of Z.t | EVar of name | EHole
  | EPi of exp * (name * exp) | ELam of exp * (name * exp) | EApp of exp * exp
  | ESig of exp * (name *exp) | EPair of tag*exp*exp | EFst of exp | ESnd of exp
  | EId of exp | ERef of exp | EJ of exp | EField of exp * string
  | EPathP of exp | EPLam of exp | EAppFormula of exp * exp
  | EI | EDir of dir | EAnd of exp * exp | EOr of exp * exp | ENeg of exp
  | ETransp of exp * exp | EHComp of exp * exp * exp * exp
  | EPartial of exp | EPartialP of exp * exp | ESystem of exp System.t
  | ESub of exp * exp * exp | EInc of exp * exp | EOuc of exp
  | EGlue of exp | EGlueElem of exp * exp * exp | EUnglue of exp
  | EEmpty | EIndEmpty of exp
  | EUnit | EStar | EIndUnit of exp
  | EBool | EFalse | ETrue | EIndBool of exp
  | EW of exp * (name * exp) | ESup of exp * exp | EIndW of exp * exp * exp
  | EIm of exp | EInf of exp | EIndIm of exp * exp | EJoin of exp
\end{lstlisting}

\subsection*{–ö–æ—Å–º–æ—Å –∞–±–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≤—Å–µ—Å–≤—ñ—Ç—ñ–≤}

–ü–æ—á–∞—Ç–∏ —Å—Ç–∞—Ç—Ç—é —Ö–æ—á—É –∑ –≤–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ç–∞–π–ø —á–µ–∫–µ—Ä–∞. –ü–æ —Å—É—Ç—ñ —Ç–∞–π–ø —á–µ–∫–µ—Ä
—Ü–µ —Ñ—É–Ω–∫—Ü—ñ—è –Ω–∞–¥ –º–æ–≤–æ—é –≤–∏—Ä–∞–∑—ñ–≤ exp. –†–æ–∑–≥–ª—è–Ω–µ–º–æ –ø—Ä–∏—Å—Ç—Ä—ñ–π —Ñ—É–Ω–∫—Ü—ñ–π —Ç–∞–π–ø
—á–µ–∫–µ—Ä–∞ —Ä—è–¥–∫–æ–≤–æ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø—Ä–∏—Ç–∏–º—ñ—Ç–∏–≤–∞ –∑ –¥–µ—Ä–µ–≤–∞ exp.

\begin{lstlisting}
type exp = | EPre of Z.t | EKan of Z.t | EVar of name | EHole
\end{lstlisting}

–°–∏—Å—Ç–µ–º–∞ HTS (–∞–±–æ 2LTT) —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏–∑—É—î—Ç—å—Å—è –Ω–∞—è–≤–Ω—ñ—Å—Ç—é –¥–≤–æ—Ö —ñ—î—Ä–∞—Ä—Ö—ñ–π
–ø—Ä–µ–¥–∏–∫–∞—Ç–∏–≤–Ω–∏—Ö –≤—Å–µ—Å–≤—ñ—Ç—ñ–≤ $U_i$ –¥–ª—è —Ñ—ñ–±—Ä–∞—Ü—ñ–π–Ω–∏—Ö —Ç–∏–ø—ñ–≤ —ñ $V_j$ –¥–ª—è –ø—Ä–µ—Ç–∏–ø—ñ–≤,
–¥–µ –∂–∏–≤–µ –≥–æ–º–æ—Ç–æ–ø—ñ—á–Ω–∏–π –±–∞–≥–∞—Ç–æ–≤–∏–º—ñ—Ä–Ω–∏–π –≤—ñ–¥—Ä—ñ–∑–æ–∫. –¢–∞–∫–æ–∂ –≤ —è–¥—Ä—ñ —Ç–∞–π–ø —á–µ–∫–µ—Ä—ñ–≤
–∑–∞–∑–≤–∏—á–∞–π –∑–Ω–∞—Ö–æ–¥—è—Ç—å—Å—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏ –¥–ª—è –∑–º—ñ–Ω–Ω–∏—Ö —ñ –¥—ñ—Ä–æ–∫ –∑—Ä—É—á–Ω–∏—Ö –¥–ª—è –ø—Ä–æ—Ü–µ—Å—É
–≤–∏–ª—É—á–µ–Ω–Ω—è –¥–æ–∫–∞–∑—ñ–≤. –†—ñ–≤–Ω—è–Ω–Ω—è —Ü–∏—Ö –ø—Ä–∏–º—ñ—Ç–∏–≤—ñ–≤ –±—É–¥—É—Ç—å –¥–∞–Ω—ñ —É —Ü—å–æ–º—É –ø–∞—Ä–∞–≥—Ä–∞—Ñ—ñ.

–°–∞–º —Ç–∞–π–ø—á–µ–∫–µ—Ä –≤–ª–∞—à—Ç–æ–≤–∞–Ω–∏–π —Ç–∞–∫–∏–º —á–∏–Ω–æ–º (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞, –¥–∏–≤—ñ—Ç—å—Å—è
–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —Ç–∞–π–ø—á–µ–∫–µ—Ä–∏ Mini-TT –∞–±–æ cubicaltt, —â–æ –≤–∂–µ —Å—Ç–∞–ª–∏ –∫–ª–∞—Å–∏—á–Ω–∏–º–∏),
—â–æ –¥–ª—è –ø—Ä–æ—Ü–µ—Å—É –±–µ—Ç–∞-–Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó (–µ–≤–∞–ª—É–∞—Ü—ñ—ó) –∞–±–æ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç—É–≤–∞–Ω–Ω—è –≤–∏—Ä–∞–∑—É
–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –≤–Ω—É—Ç—Ä—ñ—à–Ω—î —É—è–≤–ª–µ–Ω–Ω—è, –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–µ –¥–ª—è –ø–æ—Ç—Ä–µ–± –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏—Ö –æ–±—á–∏—Å–ª–µ–Ω—å.

\begin{lstlisting}
type value = | VKan of Z.t | VPre of Z.t | Var of name * value | VHole
\end{lstlisting}

–¢–∞–∫–∏–º —á–∏–Ω–æ–º —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ —Ç–∞–π–ø—á–µ–∫–µ—Ä–∞ –≤–∏–≥–ª—è–¥–∞—î —Ç–∞–∫:

\begin{lstlisting}
and check ctx (e0: exp) (t0: value)
  = traceCheck e0 t0; try match e0, t0 with
\end{lstlisting}

–ê–ª–≥–æ—Ä–∏—Ç–º –∫–ª–∞—Å–∏—á–Ω–∏–π —ñ –∑–≤—É—á–∏—Ç—å —Ç–∞–∫: –¥–ª—è —Ç–∏–ø–æ–≤–æ–≥–æ –≤–∏—Ä–∞–∑—É —Ç–∞ –π–æ–≥–æ
–µ–∫–∑–µ–º–ø–ª—è—Ä–∞ –º–∏ –±–µ—Ä–µ–º–æ –µ–∫–∑–µ–º–ø–ª—è—Ä —Ç–∏–ø–æ–≤–æ–≥–æ –≤–∏—Ä–∞–∑—É –≤–∏–≤–æ–¥–∏–º–æ –π–æ–≥–æ
—Ç–∏–ø —ñ –ø–æ—Ä—ñ–≤–Ω—é—î–º–æ —ñ–∑ –∑–∞–¥–∞–Ω–∏–º —Ç–∏–ø–æ–≤–∏–º –≤–∏—Ä–∞–∑–æ–º. –Ø–∫—â–æ –≤–æ–Ω–∏ –∑–±—ñ–≥–∞—é—Ç—å—Å—è
–≤—Å–µ –¥–æ–±—Ä–µ, —è–∫—â–æ –Ω—ñ --- —Ç–æ –ø–æ–º–∏–ª–∫–∞ —Ç–∏–ø—ñ–∑–∞—Ü—ñ—ó. –î–∞–ª—ñ –π–¥–µ —Å–ø–∏—Å–æ–∫
–ø–∞—Ç–µ—Ä–Ω-–º–∞—Ç—á—ñ–Ω–≥ —Ä—ñ–≤–Ω—è–Ω—å –≤—Å—ñ—Ö —Ñ—É–Ω–∫—Ü—ñ–π –Ω–∞ –¥–µ—Ä–µ–≤–∞—Ö –º–æ–≤–Ω–∏—Ö –≤–∏—Ä–∞–∑—ñ–≤ expr:

\begin{lstlisting}
check:
  | EHole, v -> traceHole v ctx
  | e, VPre u -> begin match infer ctx e with
    | VKan v | VPre v ->
      if ieq u v then ()
      else raise (Ineq (VPre u, VPre v))
    | t -> raise (Ineq (VPre u, t)) end
  | e, t -> eqNf (infer ctx e) t

conv:
  | VKan u, VKan v -> ieq u v | VPre u, VPre v -> ieq u v
  | Var (u, _), Var (v, _) -> u = v

eval:
  | EPre u -> VPre u | EKan u -> VKan u
  | EVar x -> getRho ctx x | EHole -> VHole

infer:
  | VPre n -> VPre (Z.succ n) | VKan n -> VKan (Z.succ n)
  | EPre u -> VPre (Z.succ u) | EKan u -> VKan (Z.succ u)
  | EVar x -> lookup x ctx

inferV:
  | Var (_, t) -> t | VPre n -> VPre (Z.succ n)
  | VKan n -> VKan (Z.succ n)
\end{lstlisting}

\newpage
\begin{lstlisting}
act:
  | Var (i, VI) -> actVar rho i
  | Var (x, t) -> Var (x, act rho t) | VHole -> VHole
  | VKan u -> VKan u | VPre u -> VPre u

check:
  | e, t -> eqNf (infer ctx e) t

and getRho ctx x = match Env.find_opt x ctx with
  | Some (_, _, Value v) -> v
  | Some (_, _, Exp e) -> eval e ctx
  | None -> raise (VariableNotFound x)

and eqNf v1 v2 : unit = traceEqNF v1 v2;
  if conv v1 v2 then () else raise (Ineq (v1, v2))

and lookup (x : name) (ctx : ctx) = match Env.find_opt x ctx with
  | Some (_, Value v, _) -> v
  | Some (_, Exp e, _) -> eval e ctx
  | None -> raise (VariableNotFound x)
\end{lstlisting}

–¢—É—Ç –æ–ø–∏—Å—É—î—Ç—å—Å—è —Ç–∞–∫ –∑–≤–∞–Ω–∞ –±–∞–∑–∞ —Ä–µ–∫—É—Ä—Å—ñ—ó —Ç–∞ —Ä–æ–±–æ—Ç–∞ –∑
–∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ (getRho, lookup).

\subsection*{$\Pi$-—Ç–∏–ø}

–ü–µ—Ä—à–∏–º –º–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∏–º –ø—Ä—É–≤–µ—Ä–æ–º –≤–∑–∞–≥–∞–ª—ñ —Ç–∞ –ø–µ—Ä—à–∏–º –ø—Ä—É–≤–µ—Ä–æ–º
–Ω–∞ —Ñ—ñ–±—Ä–∞—Ü—ñ–π–Ω–æ–º—É —Ç–∏–ø—ñ –≤–≤–∞–∂–∞—î—Ç—å—Å—è [–º–Ω–æ—é] AUTOMATH –¥–µ –ë—Ä–µ–π–Ω–∞. –ü–µ—Ä—à–∞
–ø–æ–≤–Ω–∞ —Ñ–æ—Ä–º–∞–ª—å–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ CoC —Ç–∞ –ª—è–º–±–¥–∞-–∫—É–± –±—É–ª–∏ –¥–µ—Ç–∞–ª—å–Ω–æ —Ä–æ–∑—Ä–æ–±–ª–µ–Ω—ñ
–ë–∞—Ä–µ–Ω–¥—Ä–µ—Ö—Ç–æ–º. –ü—Ä–æ—Ç–µ –±–∞—Ç—å–∫–æ–º —Ñ–æ—Ä–º–∞–ª—å–Ω–æ—ó –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ –ø—Ä–∏–π–Ω—è—Ç–æ –≤–≤–∞–∂–∞—Ç–∏
–ú–∞—Ä—Ç—ñ–Ω–∞-–õ–µ—Ñ–∞. –ô–æ–≥–æ —Ç–∏–ø–æ–≤–∞ —Å–∏—Å—Ç–µ–º–∞ –¥–æ—Å—ñ —Ñ–æ—Ä–º—É—î –æ–±—á–∏—Å–ª—é–≤–∞–ª—å–Ω—É –æ—Å–Ω–æ–≤—É
—Å—É—á–∞—Å–Ω–∏—Ö –ø—Ä—É–≤–µ—Ä—ñ–≤. –¢—Ä–∞–¥–∏—Ü—ñ–π–Ω–æ MLTT —Å–∫–ª–∞–¥–∞—î—Ç—å—Å—è –∑ $\Pi, \Sigma, 0, 1, 2, W, Id$ —Ç–∏–ø—ñ–≤.
–ü—Ä–∏ —Ä–æ–∑—Ä–æ–±—Ü—ñ –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ Anders –º–∏ –∫–µ—Ä—É–≤–∞–ª–∏—Å—è –º–æ—Ç–∏–≤–∞—Ü—ñ—î—é –º—ñ–Ω—ñ–º–∞–ª—ñ—Å—Ç–∏—á–Ω–æ—Å—Ç—ñ,
—Ç–æ–º—É –≤—ñ–¥–∫–∏–Ω—É–ª–∏ –≤–∞—Ä—ñ–∞–Ω—Ç —ñ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü—ñ—ó –∑–∞–≥–∞–ª—å–Ω–æ—ó —Å—Ö–µ–º–∏ —ñ–Ω–¥—É–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∏–ø—ñ–≤ —ñ
–≤–∏—â–∏—Ö —ñ–¥—É–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∏–ø—ñ–≤ (HIT), –∞ –≤–∏—Ä—ñ—à–∏–ª–∏ —Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —è–∫ —ñ–Ω–¥—É–∫—Ç–∏–≤–Ω–µ
—è–¥—Ä–æ –∫–ª–∞—Å–∏—á–Ω—ñ W-—Ç–∏–ø–∏ —Å–∏—Å—Ç–µ–º–∏ MLTT.

\newpage
–î–æ—Å–Ω—ñ–ø–æ–≤–∏–π –∫–æ–¥ –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–ª—è $\Pi$-—Ç–∏–ø—É:
\begin{lstlisting}
eval:
  | EPi (a, (p, b)) -> let t = eval a ctx in
    VPi (t, (fresh p, closByVal ctx p t b))
  | ELam (a,(p, b)) -> let t = eval a ctx in
    VLam (t,(fresh p, closByVal ctx p t b))
  | EApp (f, x) -> app (eval f ctx, eval x ctx)

infer:
  | EPi (a, (p, b)) -> inferTele ctx p a b

inferV:
  | VPi (t, (x, f)) -> imax (inferV t) (inferV (f (Var (x, t))))
  | VLam (t, (x, f)) -> VPi (t, (x, fun x -> inferV (f x)))
  | VApp (f, x) -> begin match inferV f with
    | VPi (_, (_, g)) -> g x
    | v -> raise (ExpectedPi v) end

act:
  | VLam (t, (x, g)) -> VLam (act rho t, (x, g >> act rho))
  | VPi (t, (x, g)) -> VPi (act rho t, (x, g >> act rho))
  | VApp (f, x) -> app (act rho f, act rho x)

app:
  | f, x -> VApp (f, x)

conv:
  | VPi (a,(p,f)), VPi (b,(_,g)) ->
    let x = Var (p,a) in conv a b && conv (f x) (g x)
  | VLam (a,(p,f)), VLam (b,(_,g))
  | VApp (f,a), VApp (g,b) -> conv f g && conv a b

check:
  | ELam (a, (p, b)), VPi (t, (_, g)) ->
    ignore (extSet (infer ctx a)); eqNf (eval a ctx) t;
    let x = Var (p, t) in let ctx' =
    upLocal ctx p t x in check ctx' b (g x)

and inferTele ctx p a b =
    ignore (extSet (infer ctx a));
    let t = eval a ctx in let x = Var (p, t) in
    let ctx' = upLocal ctx p t x in
    let v = infer ctx' b in imax (infer ctx a) v

and inferLam ctx p a e =
    ignore (extSet (infer ctx a)); let t = eval a ctx in
    ignore (infer (upLocal ctx p t (Var (p, t))) e);
    VPi (t, (p, fun x -> inferV (eval e (upLocal ctx p t x))))
\end{lstlisting}

\newpage
$\Pi$-—Ç–∏–ø —Ç–µ—Å—Ç—É—î—Ç—å—Å—è —ñ–Ω—Ç–µ—Ä–Ω–∞–ª—ñ–∑–∞—Ü—ñ—î—é, –∞ –∑–∞ –Ω–∞—è–≤–Ω–æ—Å—Ç—ñ –≥–æ–º–æ—Ç–æ–ø—ñ—á–Ω–æ—ó
—Ä—ñ–≤–Ω–æ—Å—Ç—ñ —â–µ –π —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ—é –µ–∫—Å—Ç–µ–Ω—Å—ñ–æ–Ω–∞–ª—å–Ω—ñ—Å—Ç—é.

\begin{lstlisting}
def Pi (A : U) (B : A ‚Üí U) : U := Œ† (x : A), B x
def lambda (A: U) (B: A ‚Üí U) (b: Pi A B) : Pi A B := $\lambda$ (x : A), b x
def lam (A B: U) (f: A ‚Üí B) : A ‚Üí B := $\lambda$ (x : A), f x
def apply (A: U) (B: A ‚Üí U) (f: Pi A B) (a: A) : B a := f a
def app (A B: U) (f: A ‚Üí B) (x: A): B := f x

def Œ†-$\beta$ (A : U) (B : A ‚Üí U) (a : A) (f : Pi A B)
  : Path (B a) (apply A B (lambda A B f) a) (f a) := idp (B a) (f a)
def Œ†-$\eta$ (A : U) (B : A ‚Üí U) (a : A) (f : Pi A B)
  : Path (Pi A B) f ($\lambda$ (x : A), f x) := idp (Pi A B) f

def funext-form (A B: U) (f g: A ‚Üí B): U := Path (A ‚Üí B) f g
def funext (A B: U) (f g: A ‚Üí B) (p: Œ† (x: A), Path B (f x) (g x))
  : funext-form A B f g := <i> $\lambda$ (a: A), p a @ i

def happly (A B: U) (f g : A ‚Üí B) (p: funext-form A B f g) (x : A)
  : Path B (f x) (g x) := cong (A ‚Üí B) B ($\lambda$ (h: A ‚Üí B), app A B h x) f g p

def funext-$\beta$ (A B: U) (f g: A ‚Üí B) (p: Œ† (x: A), Path B (f x) (g x))
  : Œ† (x: A), Path B (f x) (g x) := $\lambda$ (x: A), happly A B f g (funext A B f g p) x

def funext-$\eta$ (A B: U) (f g: A ‚Üí B) (p: Path (A ‚Üí B) f g)
  : Path (Path (A ‚Üí B) f g) (funext A B f g (happly A B f g p)) p
 := idp (Path (A ‚Üí B) f g) p
\end{lstlisting}

\subsection*{$\Sigma$-—Ç–∏–ø}

–Ø–∫ –≤–∏ –≤–∂–µ –º–æ–≥–ª–∏ –ø–æ–º—ñ—Ç–∏—Ç–∏ —Å–∏—Å—Ç–µ–º–∞ —Ç–∏–ø—ñ–≤ –ø—Ä—É–≤–µ—Ä–∞ –ø–æ—Ä—ñ–∑–∞–Ω–∞ –Ω–∞ –º–æ–¥—É–ª—ñ,
–∫–æ–∂–µ–Ω –∑ —è–∫–∏—Ö —Ä–µ–∞–ª—ñ–∑—É—î –ø–µ–≤–Ω–∏–π —Ç–∏–ø —Å–∏—Å—Ç–µ–º–∏ —Ç–∏–ø—ñ–≤, –∞ —Å–∞–º–µ 5 –ø—Ä–∞–≤–∏–ª
–ú–∞—Ä—Ç—ñ–Ω–∞-–õ–µ—Ñ–∞: 1) –ü—Ä–∞–≤–∏–ª–æ —Å–∏–≥–Ω–∞—Ç—É—Ä–∏ –∞–±–æ —Ñ–æ—Ä–º–∞—Ü—ñ—ó, —â–æ –ø–æ—Å–µ–ª—è—î —Ç–∏–ø
—É –ø–µ–≤–Ω–∏–π –≤—Å–µ—Å–≤—ñ—Ç, 2) –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —è–∫–∏—Ö —Å—Ç–≤–æ—Ä—é—é—Ç—å—Å—è
–µ–ª–µ–º–µ–Ω—Ç–∏ —Ç–∏–ø—É , 3) –ï–ª—ñ–º—ñ–Ω–∞—Ç–æ—Ä–∏ —Ç–∞/–∞–±–æ –Ü–Ω–¥—É–∫—Ç–æ—Ä–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —è–∫–∏—Ö
–¥–æ–≤–æ–¥—è—Ç—å —Ç–µ–æ—Ä–µ–º–∏ –ø—Ä–æ —Ç–∏–ø, 4) –û–±—á–∏—Å–ª—é–≤–∞–ª—å–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è, —â–æ –≥–∞—Ä–∞–Ω—Ç—É—é—Ç—å
–ø—Ä–æ—Ü–µ—Å –æ–±—á–∏—Å–ª–µ–Ω—å (–±–µ—Ç–∞-–ø—Ä–∞–≤–∏–ª–æ);

–ü—Ä–∏ —Ü—å–æ–º—É –¥–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è —Ç–∏–ø—É –≤ —Å–∏—Å—Ç–µ–º—É –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–æ–¥–∞—Ç–∏ —Ä—ñ–≤–Ω—è–Ω–Ω—è
–ø–∞—Ç–µ—Ä–Ω-–º–∞—á–∏–Ω–≥—É –≤ –Ω–∞–±—ñ—Ä —Ñ—É–Ω–∫—Ü—ñ–π –∑ —è–∫–∏—Ö —Å–∫–ª–∞–¥–∞—î—Ç—å—Å—è —Ç–∞–π–ø —á–µ–∫–µ—Ä:
infer, inferV, app, check, act, conv, eval.

\newpage
–î–æ—Å–Ω—ñ–ø–æ–≤–∏–π –∫–æ–¥ –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–ª—è $\Sigma$-—Ç–∏–ø—É:
\begin{lstlisting}
infer:
  | ESig (a, (p, b)) -> inferTele ctx p a b
  | EFst e -> fst (extSigG (infer ctx e))
  | ESnd e -> let (_, (_, g)) = extSigG (infer ctx e) in g (vfst (eval e ctx))
  | EField (e, p) -> inferField ctx p e

inferV:
  | VFst e -> fst (extSigG (inferV e))
  | VSnd e -> let (_, (_, g)) = extSigG (inferV e) in g (vfst e)

eval:
  | ESig (a, (p, b)) -> let t = eval a ctx in VSig (t, (fresh p, closByVal ctx p t b))
  | EPair (r, e1, e2) -> VPair (r, eval e1 ctx, eval e2 ctx)
  | EFst e -> vfst (eval e ctx)
  | EField (e, p) -> evalField p (eval e ctx)

check:
  | EPair (r, e1, e2), VSig (t, (p, g)) ->
    ignore (extSet (inferV t)); check ctx e1 t;
    check ctx e2 (g (eval e1 ctx)); begin match p with
    | Name (v, _) -> r := Some v
    | Irrefutable -> () end

act:
  | VSig (t, (x, g)) -> VSig (act rho t, (x, g >> act rho))
  | VPair (r, u, v) -> VPair (r, act rho u, act rho v)
  | VFst k -> vfst (act rho k) | VSnd k -> vsnd (act rho k)

conv:
  | VFst x, VFst y | VSnd x, VSnd y -> conv x y
  | VPair (_, a, b), VPair (_, c, d) -> conv a c && conv b d
  | VPair (_, a, b), v | v, VPair (_, a, b) -> conv (vfst v) a && conv (vsnd v) b

and inferField ctx p e = snd (getField p (eval e ctx) (infer ctx e))

let rec getField p v = function
  | VSig (t, (q, g)) ->
    if matchIdent p q then (vfst v, t)
    else getField p (vsnd v) (g (vfst v))
  | t -> raise (ExpectedSig t)

let vfst : value -> value = function | VPair (_, u, _) -> u | v -> VFst v
let vsnd : value -> value = function | VPair (_, _, u) -> u | v -> VSnd v
\end{lstlisting}

\newpage
–ù–∞—à $\Sigma$-—Ç–∏–ø —Ä–æ–∑—à–∏—Ä–µ–Ω–∏–π –¥–æ–¥–∞—Ç–∫–æ–≤–∏–º –µ–ª—ñ–º—ñ–Ω–∞—Ç–æ—Ä–æ–º, —è–∫–∏–π –¥–∞—î –¥–æ—Å—Ç—É–ø –¥–æ
—ñ–º–µ–Ω–æ–≤–∞–Ω–æ–≥–æ —Ç—ñ–ª–µ—Å–Ω–æ–≥–æ –ø—Ä—è–º–æ –≤ –ø—Ä–æ—Ü–µ—Å—ñ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó. –¶–µ–π –º–µ—Ö–∞–Ω—ñ–∑–º –¥–æ–∑–≤–æ–ª—è—î
—Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –±–∞–∑–æ–≤–∏–π –º–µ—Ö–∞–Ω—ñ–∑–º –∑–∞–ø–∏—Å—ñ–≤-–∫–æ—Ä—Ç–µ–∂—ñ–≤ –∑ —ñ–º–µ–Ω–æ–≤–∞–Ω–∏–º–∏ –ø–æ–ª—è–º–∏,
–∑–∞ –≤–∏–Ω—è—Ç–∫–æ–º —É—Å–ø–∞–¥–∫—É–≤–∞–Ω–Ω—è —Ç–∞ —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è —Ä–µ–∫–æ—Ä–¥—ñ–≤.
–ï–ª—ñ–º—ñ–Ω–∞—Ç–æ—Ä–∏ .1 —Ç–∞ .2 (–∑ cubicaltt) —Ç–µ–∂ –ø—Ä–∞—Ü—é—é—Ç—å.

\begin{lstlisting}
def Sigma (A : U) (B : A ‚Üí U) : U := summa (x: A), B x
def prod (A B : U) : U := summa (_ : A), B
def pair (A: U) (B: A ‚Üí U) (a: A) (b: B a) : Sigma A B := (a, b)
def pr‚ÇÅ (A: U) (B: A ‚Üí U) (x: Sigma A B) : A := x.1
def pr‚ÇÇ (A: U) (B: A ‚Üí U) (x: Sigma A B) : B (pr‚ÇÅ A B x) := x.2

def Sigma-rec (A: U) (B: A -> U) (C: U) (g: Œ† (x: A), B(x) -> C)
    (p: Œ£ (x: A), B x): C := g p.1 p.2

def Sigma-ind (A : U) (B : A -> U) (C : Œ† (s: Œ£ (x: A), B x), U) 
    (g: Œ† (x: A) (y: B x), C (x,y)) (p: Œ£ (x: A), B x) : C p := g p.1 p.2

def ac (A B: U) (R: A -> B -> U) (g: Œ† (x: A), Œ£ (y: B), R x y)
  : Œ£ (f: A -> B), Œ† (x: A), R x (f x) := ($\lambda$(i:A),(g i).1,$\lambda$(j:A),(g j).2)

def total (A:U) (B C : A -> U) (f : Œ† (x:A), B x -> C x) (w: Œ£(x: A), B x)
  : Œ£ (x: A), C x := (w.1,f (w.1) (w.2))

def funDepTr (A: U) (P: A -> U) (a0 a1: A) (p: PathP (<_>A) a0 a1)
    (u0: P a0) (u1: P a1)
  : PathP (<_>U) (PathP (<i> P (p @ i)) u0 u1) (PathP (<_>P a1)
            (hcomp (P a1) 0 (Œª (k : I), []) (transp (<i> P (p @ i)) 0 u0)) u1)
 := <j> PathP (<i> P (p @ j \\/ i))
            (comp ($\lambda$(i:I), P (p @ j /\\ i)) -j ($\lambda$(k: I), [(j = 0) -> u0 ])
            (inc (P a0) -j u0)) u1

def pathSig0 (A: U) (P: A -> U) (t u: Œ£ (x: A), P x) (p: PathP (<_>A) t.1 u.1)
  : PathP (<_>U) (PathP (<i>P (p @ i)) t.2 u.2) (PathP (<_>P u.1)
          (hcomp (P u.1) 0 ($\lambda$(k:I),[]) (transp (<i> P (p @ i)) 0 t.2)) u.2)
 := funDepTr A P t.1 u.1 p t.2 u.2
\end{lstlisting}

\newpage
\subsection*{0-—Ç–∏–ø}

0-—Ç–∏–ø —î —Ç–∏–ø-–±—Ä–µ—Ö–Ω—è, –ª–æ–≥—ñ—á–Ω–∏–π –Ω—É–ª—å $\mathbbm{0}$, –ø–æ—Ä–æ–∂–Ω–µ—á—É, Empty, Void –∞–±–æ $\bot$.
–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –¥–æ–∫–∞–∑—É –ø—Ä–æ—Ç–∏—Ä—ñ—á, –º—ñ—Å—Ç–∏—Ç—å –ª–∏—à–µ –ø—Ä–∞–≤–∏–ª–∞ —Ñ–æ—Ä–º–∞—Ü—ñ—ó —Ç–∞ —ñ–Ω–¥—É–∫—Ç–æ—Ä.

–î–æ—Å–Ω—ñ–ø–æ–≤–∏–π –∫–æ–¥ –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–ª—è 0-—Ç–∏–ø—É:
\begin{lstlisting}
eval:
  | EEmpty -> VEmpty
  | EIndEmpty e -> VIndEmpty (eval e ctx)

inferV:
  | VEmpty -> VKan Z.zero
  | VIndEmpty t -> implv VEmpty t

act:
  | VEmpty -> VEmpty
  | VIndEmpty v -> VIndEmpty (act rho v)

conv:
  | VEmpty, VEmpty -> true
  | VIndEmpty u, VIndEmpty v -> conv u v

infer:
  | EEmpty | EUnit
  | EIndEmpty e -> ignore (extSet (infer ctx e)); implv VEmpty (eval e ctx)
\end{lstlisting}

\newpage
\subsection*{1-—Ç–∏–ø}
1-—Ç–∏–ø —è–≤–ª—è—î —Å–æ–±–æ—é –ª–æ–≥—ñ—á–Ω—É –æ–¥–∏–Ω–∏—Ü—é $\mathbb{1}$, —Ç–∏–ø-—ñ—Å—Ç–∏–Ω—É
–≤ —ñ–Ω—Ç—É—ó—Ü—ñ–æ–Ω—ñ—Å—Ç—Å—å–∫—ñ–π –ª–æ–≥—ñ—Ü—ñ, Unit –∞–±–æ $\top$. –ú–∞—î —î–¥–∏–Ω–∏–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä $\star$.

–î–æ—Å–Ω—ñ–ø–æ–≤–∏–π –∫–æ–¥ –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–ª—è 1-—Ç–∏–ø—É:
\begin{lstlisting}
eval:
  | EUnit -> VUnit
  | EStar -> VStar
  | EIndUnit e -> VIndUnit (eval e ctx)

app:
  | VApp (VIndUnit _, x), VStar -> x

inferV:
  | VUnit -> VKan Z.zero
  | VStar -> VUnit
  | VIndUnit t -> recUnit t

act:
  | VUnit -> VUnit
  | VStar -> VStar
  | VIndUnit v -> VIndUnit (act rho v)

conv:
  | VUnit, VUnit -> true
  | VStar, VStar -> true
  | VIndUnit u, VIndUnit v -> conv u v

infer:
  | EStar -> VUnit
  | EIndUnit e -> inferInd false ctx VUnit e recUnit

and recUnit t = let x = freshName "x" in
  implv (app (t, VStar)) (VPi (VUnit, (x, fun x -> app (t, x))))
\end{lstlisting}

\newpage
\subsection*{2-—Ç–∏–ø}
2-—Ç–∏–ø —î –ª–æ–≥—ñ—á–Ω–æ—é –¥–≤—ñ–π–∫–æ—é $\mathbbm{2}$, –±—É–ª–µ–≤–∏–º —Ç–∏–ø–æ–º Bool
–∞–±–æ 0-–º—ñ—Ä–Ω–æ—é –≥–æ–º–æ—Ç–æ–ø—ñ—á–Ω–æ—é (–±–µ–∑ –º–µ—Ç—Ä–∏–∫–∏) —Å—Ñ–µ—Ä–æ—é. –ú–∞—î –¥–≤–∞
–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏ false=0$_2$ —Ç–∞ true=1$_2$.

–î–æ—Å–Ω—ñ–ø–æ–≤–∏–π –∫–æ–¥ –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–ª—è 2-—Ç–∏–ø—É:
\begin{lstlisting}
eval:
  | EBool -> VBool
  | EFalse -> VFalse
  | ETrue -> VTrue
  | EIndBool e -> VIndBool (eval e ctx)

app:
  | VApp (VApp (VIndBool _, a), _), VFalse -> a
  | VApp (VApp (VIndBool _, _), b), VTrue -> b

inferV:
  | VBool -> VKan Z.zero
  | VFalse | VTrue -> VBool
  | VIndBool t -> recBool t

act:
  | VBool -> VBool
  | VFalse -> VFalse
  | VTrue -> VTrue
  | VIndBool v -> VIndBool (act rho v)

conv:
  | VBool, VBool -> true
  | VFalse, VFalse -> true
  | VTrue, VTrue -> true
  | VIndBool u, VIndBool v -> conv u v

infer:
  | EBool -> VKan Z.zero
  | EFalse | ETrue -> VBool
  | EIndBool e -> inferInd false ctx VBool e recBool

and recBool t = let x = freshName "x" in
  implv (app (t, VFalse)) (implv (app (t, VTrue))
    (VPi (VBool, (x, fun x -> app (t, x)))))
\end{lstlisting}

\newpage
\subsection*{W-—Ç–∏–ø}
W-—Ç–∏–ø –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –∫–æ–¥—É–≤–∞–Ω–Ω—è –¥–æ–±—Ä–µ –≤–∏–∑–Ω–∞—á–µ–Ω–∏—Ö –¥–µ—Ä–µ–≤.
W-—Ç–∏–ø –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞—Ö —ñ–Ω–¥—É–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞,
–∞ –≥—ñ–ª–∫–∏ —É–º–æ–≤–∏ –≤–∏—Ä–∞–∂–µ–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—î—é –¥—Ä—É–≥–∏–π –∑–∞–ª–µ–∂–Ω–æ—ó –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏.
–ó–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –≥–æ–º–æ—Ç–æ–ø—ñ—á–Ω–æ—ó —Ä—ñ–≤–Ω–æ—Å—Ç—ñ, W-—Ç–∏–ø—ñ–≤, –∞ —Ç–∞–∫–æ–∂ —Ç–∏–ø—ñ–≤ 0,1,2
–≤–∏—Ä–∞–∑–Ω–∞ —ñ–Ω–¥—É–∫—Ü—ñ—è –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–∏—Ö —á–∏—Å–µ–ª.

–î–æ—Å–Ω—ñ–ø–æ–≤–∏–π –∫–æ–¥ –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–ª—è W-—Ç–∏–ø—É:
\begin{lstlisting}
eval:
  | EW (a, (p, b)) -> let t = eval a ctx in W (t, (fresh p, closByVal ctx p t b))
  | ESup (a, b) -> VSup (eval a ctx, eval b ctx)
  | EIndW (a, b, c) -> VIndW (eval a ctx, eval b ctx, eval c ctx)

app: 
  | VApp (VIndW (a, b, c), g), VApp (VApp (VSup (_, _), x), f) ->
    app (app (app (g, x), f),
      VLam (app (b, x), (freshName "b", fun y ->
        app (VApp (VIndW (a, b, c), g), app (f, y)))))

inferV:
  | VSup (a, b) -> inferSup a b
  | VIndW (a, b, c) -> inferIndW a b c

and wtype a b = W (a, (freshName "x", fun x -> app (b, x)))

and inferSup a b = let t = wtype a b in let x = freshName "x" in
  VPi (a, (x, fun x -> implv (implv (app (b, x)) t) t))

and inferIndW a b c = let t = wtype a b in
  implv (VPi (a, (freshName "x", fun x ->
    VPi (implv (app (b, x)) t, (freshName "f", fun f ->
      implv (VPi (app (b, x), (freshName "b", fun b -> app (c, (app (f, b))))))
        (app (c, VApp (VApp (VSup (a, b), x), f))))))))
    (VPi (t, (freshName "w", fun w -> app (c, w))))

act:
  | W (t, (x, g)) -> W (act rho t, (x, g >> act rho))
  | VSup (a, b) -> VSup (act rho a, act rho b)
  | VIndW (a, b, c) -> VIndW (act rho a, act rho b, act rho c)
\end{lstlisting}

\newpage
\begin{lstlisting}
conv:
  | VSup (a1,b1), VSup (a2,b2) -> conv a1 a2 && conv b1 b2
  | VIndW (a1,b1,c1), VIndW (a2,b2,c2) -> conv a1 a2 && conv b1 b2 && conv c1 c2

infer:
  | ESup (a, b) -> let t = eval a ctx in ignore (extSet (infer ctx a));
    let (t', (p, g)) = extPiG (infer ctx b) in eqNf t t';
    ignore (extSet (g (Var (p, t))));
    inferSup t (eval b ctx)
  | EIndW (a, b, c) -> let t = eval a ctx in ignore (extSet (infer ctx a));
    let (t', (p, g)) = extPiG (infer ctx b) in
    eqNf t t'; ignore (extSet (g (Var (p, t))));
    let (w', (q, h)) = extPiG (infer ctx c) in
    eqNf (wtype t (eval b ctx)) w';
    ignore (extSet (h (Var (q, w'))));
    inferIndW t (eval b ctx) (eval c ctx)

and inferIndW a b c = let t = wtype a b in
    implv (VPi (a, (freshName "x", fun x ->
      VPi (implv (app (b, x)) t, (freshName "f", fun f ->
        implv (VPi (app (b, x), (freshName "b", fun b -> app (c, (app (f, b))))))
          (app (c, VApp (VApp (VSup (a, b), x), f))))))))
      (VPi (t, (freshName "w", fun w -> app (c, w))))
\end{lstlisting}

\newpage
–ü—ñ—Å–ª—è —Ç–æ–≥–æ, —è–∫ –º–∏ –≤–∏–∑–Ω–∞—á–∏–ª–∏ W —Ç–∏–ø–∏ –≤ —è–¥—Ä—ñ, –¥–ª—è —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó
–ø—Ä–∏–Ω—Ü–∏–ø—É —ñ–Ω–¥—É–∫—Ü—ñ—ó –Ω–∞–º –∑–Ω–∞–¥–æ–±–∏—Ç—å—Å—è —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç —É —Ñ—ñ–±—Ä–∞—Ü—ñ–π–Ω–æ–º—É —à–ª—è—Ö—É Path.

\begin{lstlisting}
def ind$^W$-$\beta$ (A : U) (B : A ‚Üí U) (C : (W (x : A), B x) ‚Üí U) (g : Œ† (x : A)
    (f : B x ‚Üí (W (x : A), B x)), (Œ† (b : B x), C (f b)) ‚Üí C (sup A B x f))
    (a : A) (f : B a ‚Üí (W (x : A), B x))
  : PathP (<_> C (sup A B a f))
          (ind$^W$ A B C g (sup A B a f)) (g a f (Œª (b : B a), ind$^W$ A B C g (f b)))
 := <_> g a f ($\lambda$ (b : B a), ind$^W$ A B C g (f b))

def trans-W (A : I ‚Üí U) (B : Œ† (i : I), A i ‚Üí U)
    (a : A 0) (f : B 0 a ‚Üí (W (x : A 0), B 0 x))
  : W (x : A 1), B 1 x
 := sup (A 1) (B 1) (transp (<i> A i) 0 a)
        (transp (<i> B i (transFill (A 0)
                (A 1) (A j) a @ i) ‚Üí (W (x : A i), B i x)) 0 f)

def trans-W‚Ä≤ (A : I ‚Üí U) (B : Œ† (i : I), A i ‚Üí U)
    (a : A 0) (f : B 0 a ‚Üí (W (x : A 0), B 0 x))
  : W (x : A 1), B 1 x
 := transp (<i> W (x : A i), B i x) 0 (sup (A 0) (B 0) a f)

def trans-W-is-correct (A : I ‚Üí U) (B : Œ† (i : I), A i ‚Üí U)
    (a : A 0) (f : B 0 a ‚Üí (W (x : A 0), B 0 x))
  : Path (W (x : A 1), B 1 x) (trans-W A B a f) (trans-W‚Ä≤ A B a f)
 := <_> trans-W A B a f

def hcomp-W‚Ä≤ (A : U) (B : A ‚Üí U) (r : I) (a : I ‚Üí Partial A r)
    (f : Œ† (i : I), PartialP [(r = 1) ‚Üí B (a i 1=1) ‚Üí (W (x : A), B x)] r)
    (a$_0$ : A[r $\mapsto$ a 0]) (f‚ÇÄ : (B (ouc a$_0$) ‚Üí (W (x : A), B x)) [r $\mapsto$ f 0])
  : W (x : A), B x
 := hcomp (W (x : A), B x) r
          ($\lambda$ (i : I), [(r = 1) ‚Üí sup A B (a i 1=1) (f i 1=1)])
          (sup A B (ouc a$_0$) (ouc f$_0$))
\end{lstlisting}

\newpage
\subsection*{Path-—Ç–∏–ø}
–ù–∞—Ä–µ—à—Ç—ñ –±–∞–≥–∞—Ç–æ–≤–∏–º—ñ—Ä–Ω–∏–π Path —Ç–∏–ø —î —Ç–∞ –≥–æ–º–æ—Ç–æ–ø—ñ—á–Ω–∞ –∫—É–±—ñ—á–Ω–∞ –≥–µ—Ç–µ—Ä–æ–≥–µ–Ω–Ω–∞
—Ä—ñ–≤–Ω—ñ—Å—Ç—å –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —è–∫–æ—ó –º–æ–∂–Ω–∞ –ø–æ–±—É–¥—É–≤–∞—Ç–∏ –≥—Ä—É–ø–æ—ó–¥–∏ (–¥–∏–≤—ñ—Ç—å—Å—è –±–∞–∑–æ–≤—É –±—ñ–±–ª—ñ–æ—Ç–µ–∫—É –ê–Ω–¥–µ—Ä—Å–∞).

\begin{lstlisting}
eval:
  | EPathP e -> VPathP (eval e ctx)
  | EPLam e -> VPLam (eval e ctx)
  
check:
  | EPLam (ELam (EI, (i, e))), VApp (VApp (VPathP p, u0), u1) ->
    let v = Var (i, VI) in let ctx' = upLocal ctx i VI v in
    let v0 = eval e (upLocal ctx i VI vzero) in
    let v1 = eval e (upLocal ctx i VI vone) in
    check ctx' e (appFormula p v); eqNf v0 u0; eqNf v1 u1

inferV:
  | VPLam (VLam (VI, (_, g))) -> let t = VLam (VI, (freshName "Œπ", g >> inferV)) in
    VApp (VApp (VPathP (VPLam t), g vzero), g vone)
  | VAppFormula (f, x)       -> let (p, _, _) = extPathP (inferV f) in appFormula p x
  | VPathP p -> let (_, _, v) = freshDim () in let t = inferV (appFormula p v) in
    let v0 = appFormula p vzero in let v1 = appFormula p vone in implv v0 (implv v1 t)

act:
  | VPLam f -> VPLam (act rho f)
  | VPathP v -> VPathP (act rho v)
  | VAppFormula (f, x)   -> appFormula (act rho f) (act rho x)


and inferPath ctx p =
  let (_, t0, t1) = extPathP (infer ctx p) in
  let k = extSet (inferV t0) in implv t0 (implv t1 (VKan k))

and appFormula v x = match v with
  | VPLam f -> app (f, x)
  | _       -> let (_, u0, u1) = extPathP (inferV v) in
    begin match x with
      | VDir Zero -> u0
      | VDir One  -> u1
      | i -> VAppFormula (v, i)
    end
\end{lstlisting}

\newpage
\begin{lstlisting}
conv:
  | VPLam f, VPLam g -> conv f g
  | VPLam f, v | v, VPLam f ->
    let (_, _, i) = freshDim () in conv (appFormula v i) (app (f, i))
  | VPathP a, VPathP b -> conv a b

infer:
  | EPathP p -> inferPath ctx p
  | EPLam (ELam (EI, (i, e))) ->
    let ctx' = upLocal ctx i VI (Var (i, VI)) in ignore (infer ctx' e);
    let g = fun j -> eval e (upLocal ctx i VI j) in
    let t = VLam (VI, (freshName "Œπ", g >> inferV)) in
    VApp (VApp (VPathP (VPLam t), g vzero), g vone)
  | EPLam _ -> raise (InferError e)
  | VAppFormula (f, x), VAppFormula (g, y) -> conv f g && conv x y

\end{lstlisting}

–ú–∞—é—á–∏ Œ†,Œ£ —Ç–∞ Path —Ç–∏–ø–∏ —Ç–∞ —É—Ä—ñ–∑–∞–Ω–∏–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç –º–æ–∂–Ω–∞
–ø–æ–±—É–¥—É–≤–∞—Ç–∏ –æ–±—á–∏—Å–ª—é–≤–∞–ª—å–Ω—É —Å–µ–º–∞–Ω—Ç–∏–∫—É MLTT-73:

\begin{lstlisting}
def MLTT (A : U) : U‚ÇÅ ‚âî Œ£
  (Œ†-form  : Œ† (B: A ‚Üí U), U)
  (Œ†-ctor‚ÇÅ : Œ† (B: A ‚Üí U), Pi A B ‚Üí Pi A B)
  (Œ†-elim‚ÇÅ : Œ† (B: A ‚Üí U), Pi A B ‚Üí Pi A B)
  (Œ†-comp‚ÇÅ : Œ† (B: A ‚Üí U) (a: A) (f: Pi A B),
                     Equ (B a) (Œ†-elim‚ÇÅ B (Œ†-ctor‚ÇÅ B f) a) (f a))
  (Œ†-comp‚ÇÇ : Œ† (B : A ‚Üí U) (a : A) (f : Pi A B),
                     Equ (Pi A B) f (Œª (x : A), f x))
  (Œ£-form  : Œ† (B: A ‚Üí U), U)
  (Œ£-ctor‚ÇÅ : Œ† (B: A ‚Üí U) (a: A) (b : B a) , Sigma A B)
  (Œ£-elim‚ÇÅ : Œ† (B: A ‚Üí U) (p: Sigma A B), A)
  (Œ£-elim‚ÇÇ : Œ† (B: A ‚Üí U) (p: Sigma A B), B (pr‚ÇÅ A B p))
  (Œ£-comp‚ÇÅ : Œ† (B: A ‚Üí U) (a: A) (b: B a), Equ A a (Œ£-elim‚ÇÅ B (Œ£-ctor‚ÇÅ B a b)))
  (Œ£-comp‚ÇÇ : Œ† (B: A ‚Üí U) (a: A) (b: B a), Equ (B a) b (Œ£-elim‚ÇÇ B (a, b)))
  (Œ£-comp‚ÇÉ : Œ† (B: A ‚Üí U) (p: Sigma A B),
                     Equ (Sigma A B) p (pr‚ÇÅ A B p, pr‚ÇÇ A B p))
  (=-form  : Œ† (a: A), A ‚Üí U)
  (=-ctor‚ÇÅ : Œ† (a: A), Equ A a a)
  (=-elim‚ÇÅ : Œ† (a: A) (C: D A) (d: C a a (=-ctor‚ÇÅ a)) (y: A) (p: Equ A a y),
             C a y p)
  (=-comp‚ÇÅ : Œ† (a: A) (C: D A) (d: C a a (=-ctor‚ÇÅ a)),
                     Equ (C a a (=-ctor‚ÇÅ a)) d (=-elim‚ÇÅ a C d a (=-ctor‚ÇÅ a))), ùüè

theorem internalizing (A : U) : MLTT A :=
  (Pi A, lambda A, app A, comp‚ÇÅ A, comp‚ÇÇ A,
   Sigma A, pair A, pr‚ÇÅ A, pr‚ÇÇ A, comp‚ÇÉ A, comp‚ÇÑ A, comp‚ÇÖ A,
   Equ A, refl A, J A, comp‚ÇÜ A, A)
\end{lstlisting}
