\documentclass{article}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{url}
\usepackage{tikz-cd}
\usepackage[utf8]{inputenc}

\include{journal}

\begin{document}

\title{Issue VII: Symmetric Interpreter}
\author{Maksym Sokhatskyi $^1$}
\date{ $^1$ National Technical University of Ukraine \\
       \small Igor Sikorsky Kyiv Polytechnical Institute \\
       \today }

\maketitle

\begin{abstract}

Minimal language for parallel computations in symmetric monoidal categories. \\
{\bf Keywords}: Interaction Networks, Symmetric Monoidal Categories
\end{abstract}

\ifincludeTOC
  \tableofcontents
\fi

\newpage

\epigraph{Присвячується автору Interaction Networks Combinators}{Іву Лафону}

\section{The Yves Language}

Мова програмування $\mathbf{Yves}$ — це внутрішня мова симетричних моноїдальних категорій,
що реалізує паралельні обчислення через взаємодію комбінаторів ($\zeta$, $\delta$, $\epsilon$) з правилами
анігіляції та комутації, придатна для моделювання лінійних і паралельних систем.

\subsection{Синтаксис}

\begin{definition}
Терми $\mathbf{Yves}$ складаються зі змінних, комбінаторів (Con, Dup, Era), пар, обміну (Swap),
зв’язування (Let) та одиниці (Unit). Мова підтримує афінну логіку, забороняючи повторне використання змінних.
\begin{lstlisting}[mathescape=true]
I = #identifier
Y = I | Con Y  | Dup Y | Era Y
      | Pair (Y, Y)    | Unit
      | Let (I, Y, Y)  | Swap Y
\end{lstlisting}
\end{definition}

\begin{definition}
Кодування термів у мові OCaml:
\begin{lstlisting}[mathescape=true]
type term =
    | Var of string
    | Con of term
    | Dup of term
    | Era of term
    | Pair of term * term
    | Swap of term
    | Let of string * term * term
    | Unit
\end{lstlisting}
\end{definition}

\subsection{Семантика}

\begin{theorem}
Правила обчислень у $\mathbf{Yves}$ базуються на анігіляції та комутації комбінаторів:
\begin{lstlisting}[mathescape=true]
Con (Con x) → Pair (x, x)
Dup (Dup x) → Pair (x, x)
Era (Era x) → Unit
Con (Dup x) → Dup (Con x)
Con (Era x) → Pair (Era x, Era x)
Dup (Era x) → Pair (Era x, Era x)
Swap (Pair (t, u)) → Pair (u, t)
Let (x, t, u) → subst x t u
\end{lstlisting}
\end{theorem}

\begin{equation}
\tag{$\zeta$-annihilation}
\dfrac
{\zeta (\zeta (x))}
{(x, x)}
\end{equation}

\begin{equation}
\tag{$\delta$-annihilation}
\dfrac
{\delta (\delta (x))}
{(x, x)}
\end{equation}

\begin{equation}
\tag{$\epsilon$-annihilation}
\dfrac
{\varepsilon (\varepsilon (x))}
{\mathbf{1}}
\end{equation}

\subsubsection{Підстановка}

\begin{definition}
Підстановка в $\mathbf{Yves}$:
\begin{lstlisting}[mathescape=true]
let rec subst env var term = function
    | Var v ->
        if v = var then
            if is_bound var env then failwith "Affine violation: variable used twice"
            else term
        else Var v
    | Con t -> Con (subst env var term t)
    | Dup t -> Dup (subst env var term t)
    | Era t -> Era (subst env var term t)
    | Pair (t, u) -> Pair (subst env var term t, subst env var term u)
    | Swap t -> Swap (subst env var term t)
    | Let (x, t1, t2) ->
        let t1' = subst env var term t1 in
        if x = var then Let (x, t1', t2)
        else Let (x, t1', subst env var term t2)
    | Unit -> Unit
\end{lstlisting}
\end{definition}

\subsubsection{Редукція}

\begin{definition}
Редукція термів у $\mathbf{Yves}$:
\begin{lstlisting}[mathescape=true]
let reduce env term =
    match term with
    | Con (Con x) -> Pair (x, x)
    | Dup (Dup x) -> Pair (x, x)
    | Era (Era x) -> Unit
    | Con (Dup x) -> Dup (Con x)
    | Con (Era x) -> Pair (Era x, Era x)
    | Dup (Era x) -> Pair (Era x, Era x)
    | Swap (Pair (t, u)) -> Pair (u, t)
    | Let (x, t, u) -> subst env x t u
    | _ -> term
\end{lstlisting}
\end{definition}

\subsubsection{Пошук пар}

\begin{definition}
Пошук активних пар для редукції:
\begin{lstlisting}[mathescape=true]
let rec find_redexes env term acc =
    match term with
    | Con (Con x) -> (term, Pair (x, x)) :: acc
    | Dup (Dup x) -> (term, Pair (x, x)) :: acc
    | Era (Era x) -> (term, Unit) :: acc
    | Con (Dup x) -> (term, Dup (Con x)) :: acc
    | Con (Era x) -> (term, Pair (Era x, Era x)) :: acc
    | Dup (Era x) -> (term, Pair (Era x, Era x)) :: acc
    | Swap (Pair (t, u)) -> (term, Pair (u, t)) :: acc
    | Let (x, t, u) -> (term, subst env x t u) :: find_redexes env t (find_redexes env u acc)
    | Con t ->
        (match t with
         | Dup _ | Era _ -> acc
         | Con x -> find_redexes env t ((term, reduce env term) :: acc)
         | _ -> find_redexes env t acc)
    | Dup t -> find_redexes env t acc
    | Era t -> find_redexes env t acc
    | Pair (t, u) ->
        let acc' = find_redexes env t acc in
        find_redexes env u acc'
    | Swap t -> find_redexes env t acc
    | Var _ | Unit -> acc
\end{lstlisting}
\end{definition}

\subsubsection{Паралельна редукція}

\begin{definition}
Паралельна редукція:
\begin{lstlisting}[mathescape=true]
let eval_parallel pool env term =
    let rec loop term =
        let redexes = find_redexes env term [] in
        if redexes = [] then term
        else
            let new_term = Task.run pool (fun () ->
                List.fold_left
                    (fun acc (old_t, new_t) -> replace_subterm old_t new_t acc)
                    term redexes
            ) in
            loop new_term
    in
    loop term
\end{lstlisting}
\end{definition}

\subsubsection{Внутрішня мова СМК}

\begin{theorem}
Доведення, що мова $\mathbf{Yves}$ є внутрішньою мовою симетричних моноїдальних категорій:
\[
\begin{cases}
   \mathrm{Let} : A \to C (u \cdot t, t: A \to B, u: B \to C), \\
   \mathrm{Pair} : A \rightarrow B \rightarrow A \otimes B, \\
   \mathrm{Swap} : A \otimes B \rightarrow B \otimes A, \\
   \mathrm{Con} : A \otimes A \rightarrow A, \\
   \mathrm{Dup} : A \rightarrow A \otimes A, \\
   \mathrm{Era} : A \rightarrow \mathbf{1}, \\
   \mathrm{Var} : A, \\
   \mathrm{Unit} : \mathbf{1}.
\end{cases}
\]
\end{theorem}

Конструктори відповідають аксіомам СМК:

- $\mathrm{Pair}$ моделює тензорний добуток $\otimes$.
- $\mathrm{Swap}$ реалізує симетрію $\sigma_{A,B}$ з умовою $\sigma_{B,A} \circ \sigma_{A,B} = \mathrm{id}_{A \otimes B}$.
- $\mathrm{Unit}$ є одиничним об'єктом $I$ для якого $A \otimes I \cong A$.
- $\mathrm{Let}$ моделює композицію морфізмів (асоціативність).
- $\mathrm{Dup}$ та $\mathrm{Era}$ утворюють структуру комоноїда.
- $\mathrm{Con}$ діє як контракція.

Лямбда-функція і аплікація:

\[
\begin{cases}
  \lambda x.t \vdash \mathrm{Con}(\mathrm{Let}(x,\mathrm{Var}(x),t)), \\
  t u \mapsto \mathrm{Con}(\mathrm{Pair}(t,u)).
\end{cases}
\]

\end{document}