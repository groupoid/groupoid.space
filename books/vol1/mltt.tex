\documentclass{article}
\usepackage{hyphenat}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{url}
\usepackage[utf8]{inputenc}

\include{journal}

\begin{document}
\title{Issue I: Type Theory}
\author{Максим Сохацький $^1$}
\date{ $^1$ Національний технічний університет України \\
       \small Київський політехнічний інститут імені Ігоря Сікорського \\
       8 травня 2019 }

\maketitle

\begin{abstract}
Martin-Löf Type Theory (MLTT), introduced by Per Martin-Löf in 1972 as MLTT-72,
is a cornerstone of constructive mathematics, providing a foundation
for formalizing mathematical proofs and programming languages.
Its 1975 variant, MLTT-75, incorporates dependent types ($\Pi$, $\Sigma$)
and identity types, with the J eliminator as a key construct for reasoning about equality.
Historically, internalizing MLTT in a type checker while constructively
proving the J eliminator has been challenging due to limitations in pure
functional systems. This article presents a canonical formalization of
MLTT-75 without disjoin union types and natural numbers $\mathbb{N}$, denoted as MLTT-73
and its complete internalization in \textbf{Per}, a minimal dependent type
theory language equipped with cubical type primitives. Using presented type
theory, we constructively prove all MLTT-73 inference rules, including
the J eliminator, and demonstrate suitability as a robust type checker.
We also provide logical, categorical, and homotopical
interpretations of MLTT to contextualize its significance.
This work advances the mechanization of constructive mathematics and offers
a blueprint for future type-theoretic explorations. \\
\indent \textbf{Keywords}: Martin-Löf Type Theory, Cubical Type Theory.
\end{abstract}

\ifincludeTOC
  \tableofcontents
\fi

\section*{Introduction to MLTT-73}

For decades, type theorists have sought to fully internalize
Martin-Löf Type Theory (MLTT) within a type checker, a task
akin to building a self-verifying blueprint for mathematics.
Introduced by Per Martin-Löf in 1972 \cite{Lof72} and refined
in 1975 \cite{Lof75}, MLTT-75 is a foundational system that
combines dependent types ($\Pi$ for universal quantification,
$\Sigma$ for existential quantification) with identity types,
enabling rigorous reasoning about equality. Central to MLTT-75
is the J eliminator, a rule that governs how identity proofs
are used, but its constructive derivation has long eluded pure
functional type checkers due to the complexity of equality types.

The MLTT-75 without Disjoint Union Types (+) and Natural Numbers ($\mathbb{N}$) we will
denote MLTT-73. This article addresses this challenge by presenting a canonical
formalization of MLTT-73 and its complete internalization in \textbf{Per},
a novel type theory language designed for constructive proofs.
Leveraging cubical type theory \cite{Mortberg17}, \textbf{Per}
incorporates Path types and universe polymorphism to faithfully
embed MLTT-73 rules, achieving a constructive proof of the J
eliminator. This internalization serves as
an ultimate test of a type checker’s robustness, verifying its
ability to fuse introduction and elimination rules through beta and eta equalities.

To make MLTT accessible, we provide intuitive interpretations
of its types: logical (as quantifiers), categorical (as functors),
and homotopical (as spaces). These perspectives highlight MLTT’s role
as a bridge between mathematics and computation. Our work builds on
Martin-Löf’s vision of constructive mathematics, offering a minimal
yet powerful framework for mechanized reasoning. We aim to inspire
researchers and practitioners to explore type theory’s potential in
formalizing mathematics and designing reliable software.

\subsection*{Syntax of Per}
The BNF notation of type checker language used in code samples consists of:
i) telescopes (contexts or sigma chains) and definitions;
ii) pure dependent type theory syntax;
iii) inductive data definitions (sum chains) and split eliminator;
iv) cubical face system;
v) module system. It is slightly based on cubicaltt.

\begin{lstlisting}[mathescape=true]
F = module I where L
L = $\varnothing$ | import I | def I T : O := O
T = $\varnothing$ | ( I : O ) T
O = I | ( O ) | U | O → O | O O
  | Π ( I : O ) , O | λ ( I : O ), O
  | Ξ O O O O O | $\langle$ O $\rangle$ O | O @ O | transp O O
  | 0 | 1 | -O | O ∧ O | O ∨ O | $\Box$
  | Σ ( I : O ) , O | O .1 | O .2 | O , O
\end{lstlisting}

Here = (definition), $\varnothing$ (empty set), $\rvert$, are parts of BNF language and
$\langle$, $\rangle$, (, ), :=, $\vee$, $\wedge$, -, $\rightarrow$, 0, 1, @, $\Box$,
$\mathbf{module}$, $\mathbf{import}$, $\mathbf{where}$, $\mathbf{transp}$, $\mathbf{.1}$, $\mathbf{.2}$,
and $,$ are terminals of type checker language.

\section{Interpretations}

Martin-Löf Type Theory (MLTT), introduced by Per Martin-Löf in 1972 \cite{Lof72}
and refined in 1975 \cite{Lof75}, is a foundational system for constructive
mathematics, blending logical rigor with computational expressiveness.
Its 1975 variant, MLTT-75, centers on dependent types ($\Pi$, $\Sigma$)
and identity types (Id), which underpin its ability to formalize mathematical
reasoning and type checking. This section explores four interpretations
of MLTT-75: logical, categorical, homotopical, and set-theoretical; --- to illuminate
its versatility and contextualize its internalization in the \textbf{Per} language.
These perspectives reveal MLTT-75 as a unifying framework bridging logic,
category theory, homotopy theory, and set theory, with each interpretation
highlighting distinct aspects of its types and rules.

In MLTT, types are defined by five classes of rules:
(1) \textit{formation}, specifying the type’s signature;
(2) \textit{introduction}, defining constructors for its elements;
(3) \textit{elimination}, providing a dependent induction principle;
(4) \textit{computation} (beta-equality), governing reduction; and
(5) \textit{uniqueness} (eta-equality), ensuring canonical forms,
though the latter is absent for identity types in homotopical settings.

For MLTT-73, we focus on $\Pi$ (dependent function types), $\Sigma$ (dependent pair types),
and Id (identity types), with the latter replaced by Path types in cubical type theory
to enable constructive proofs, such as the J eliminator, in \textbf{Per}.
The identity type, introduced in MLTT-75 \cite{Lof75}, is particularly significant,
enabling reasoning about equality constructively. Unlike MLTT-72, which included
only $\Pi$ and $\Sigma$ types, MLTT-75’s Id types originally enforced uniqueness
of identity proofs (UIP) via an eta-rule.

However, modern homotopical interpretations, pioneered by Hofmann and
Streicher \cite{Hofmann96}, refute UIP, adopting Path types that model equality
as paths in a space, aligning with cubical type theory’s constructive framework.
This shift is crucial for \textbf{Per}, as Path types facilitate the internalization of MLTT-75’s rules.

Type checkers operate within contexts, binding variables to indexed universes,
built-in types, or user-defined types via de Bruijn indices or names. These
contexts enable queries about type derivability and code extraction, forming
the core of \textbf{Per}’s type checker. By encoding MLTT-75’s syntax and rules,
\textbf{Per} supports multiple interpretations, each offering unique insights
into its structure and applications.

\begin{table}
  \begin{tabular}{lcccc}
    \hline
       Type Theory & Logic & Category Theory & Homotopy Theory\\
    \hline
       A type & class & object & space \\
       isProp A & proposition & (-1)-truncated object & space \\
       a:A program & proof & generalized element & point \\
       $B(x)$ & predicate & indexed object & fibration \\
       $b(x) : B(x)$ & conditional proof & indexed elements & section\\
       $\mathbf{0}$ & $\bot$ false & initial object & empty space \\
       $\mathbf{1}$ & $\top$ true & terminal object & singleton \\
       $\mathbf{2}$ & boolean & subobject classifier & $\mathbb{S}^0$ \\
       $A + B$ & $A\vee B$ disjunction & coproduct & coproduct space \\
       $A\times B$ & $A\wedge B$ conjunction & product & product space \\
       $A\to B$ & $A\Rightarrow B$ & internal hom & function space \\
       $\sum{x:A},B(x)$ & $\exists_{x:A}B(x)$ & dependent sum & total space \\
       $\prod{x:A},B(x)$ & $\forall_{x:A}B(x)$ & dependent product & space of sections\\
       $\mathbf{Path}_{A}$ & equivalence $=_A$ & path space object & path space $A^I$ \\
       quotient & equivalence class & quotient & quotient \\
       W-type & induction & colimit & complex\\
       type of types & universe & object classifier & universe \\
       quantum circuit & proof net & string diagram & \\
      \hline
  \end{tabular}
\end{table}

\newpage
\subsection{Logical Interpretation}
The logical interpretation casts MLTT-75 as a system for
intuitionistic higher-order logic, where types correspond
to propositions and terms to proofs, embodying the Curry-Howard
correspondence. In this view, a type $A$ represents a proposition,
and a term $a : A$ is a proof of $A$. The $\Pi$-type, $\prod_{x:A} B(x)$,
encodes universal quantification ($\forall x : A, B(x)$),
while the $\Sigma$-type, $\sum_{x:A} B(x)$, represents existential
quantification ($\exists x : A, B(x)$). The identity type, $\text{Id}_A(a, b)$,
captures propositional equality ($a =_A b$), with the J eliminator providing a
constructive means to reason about equalities.

Each type’s five rules (formation, introduction, elimination, computation,
and uniqueness, except for Id in cubical settings) mirror the structure
of logical inference rules. For instance, the introduction rule for $\Pi$
constructs a lambda term (proof of a universal statement), while its elimination
rule applies the term to an argument (using the universal statement).

MLTT-75 is not standalone framework for constructive mathematics
but rather the extended foundational core on top of MLTT-72.
Adding $\mathbf{0}$ (Empty), $\mathbf{1}$ (Unit), $\mathbf{2}$ (Bool) types allows
resulting type system to internalize intuitionistic propositional logic (IPL),
via Gödel’s double-negation translation, classical logic can be encoded within IPL \cite{Nordstrom90}.
In \textbf{Per}, this logical framework underpins the type checker’s ability
to verify MLTT-75’s rules, ensuring constructive consistency.

\subsection{Categorical Interpretation}

The categorical interpretation models MLTT-75 within category theory,
where types are objects, terms are morphisms, and type constructions are functors.
This perspective, formalized by Cartmell and Seely \cite{Jacobs99},
views MLTT-75 with $\mathbf{0}$, $\mathbf{1}$, $\mathbf{2}$ types
as a locally cartesian closed category (LCCC). Here, $\Pi$-types
correspond to dependent products (right adjoints to base change functors),
and $\Sigma$-types to dependent sums (left adjoints). The identity
type, $\text{Id}_A$, is modeled as a path space object, reflecting
equality as a morphism.

For example, given a morphism $f : A \to B$ in a category, the $\Pi_f$
functor maps a dependent type over $B$ to one over $A$, generalizing
function spaces, while $\Sigma_f$ constructs the total space of a fibration.
In \textbf{Per}, this interpretation informs the type checker’s handling
of dependent types, with cubical primitives enabling precise categorical
semantics for Path types. Topos-theoretical models, such as presheaves,
further enrich this interpretation by treating fibrations as functors,
aligning with MLTT-75’s expressive power \cite{Curien14}.

\subsection{Homotopical Interpretation}

The homotopical interpretation, a breakthrough in modern type theory,
views MLTT-75’s types as spaces and terms as points, with identity types as paths.
Introduced by Hofmann and Streicher’s groupoid model \cite{Hofmann96},
this perspective refutes the uniqueness of identity proofs (UIP) in
classical MLTT-75, replacing Id with Path types that model equality
as continuous paths in a space. In cubical type theory, Path types
are functions from an interval $[0,1]$ to a type, enabling constructive
proofs of MLTT-75’s rules, including the J eliminator, in \textbf{Per}.

Here, $\Pi$-types represent spaces of sections, $\Sigma$-types denote
total spaces of fibrations, and Path types form path spaces ($A^I$).
This interpretation connects MLTT-75 to homotopy theory, where types
are $\infty$-groupoids, and fibrations (dependent types) are studied
geometrically. For instance, a $\Pi$-type can be seen as a trivial fiber
bundle, with its introduction rule constructing a section \cite{HoTT13}.
In \textbf{Per}, cubical primitives like connections and compositions support
this interpretation, making MLTT-75’s internalization homotopically robust.

\subsection{Set-Theoretical Interpretation}

The set-theoretical interpretation models MLTT-75’s types as sets and
terms as elements, aligning with classical first-order logic. In this
view, a type $A$ is a set, and a term $a : A$ is an element. The $\Pi$-type
represents a set of functions, $\Sigma$-type a disjoint union of sets,
and $\text{Id}_A(a, b)$ an equality relation. However, this interpretation
is limited, as it cannot capture higher equalities (e.g., paths between paths)
or inductive types directly, due to its 0-truncated nature \cite{HoTT13}.

In homotopical terms, sets are modeled as 0-types (types with no non-trivial
higher paths), but MLTT-75’s identity types introduce higher structure,
making the set-theoretical view less expressive. In \textbf{Per}, the
set-theoretical interpretation serves as a baseline, with cubical Path
types extending it to handle MLTT-75’s full complexity. This interpretation
clarifies the boundaries of classical logic within MLTT-75, emphasizing
the need for homotopical or categorical models for complete internalization.

\section{Dependent Type Theory}

\subsection{Dependent Product ($\Pi$)}

$\Pi$ is a dependent product type, the generalization of functions.
As a function it can serve the wide range of mathematical constructions as its domain and codomain,
which are in general: objects, types, or spaces; and could have as its
instance: sets, functions, polynomial functors, infinitesimals, $\infty$-groupoids,
topological $\infty$-groupoid, CW-complexes,
categories, languages, etc.

At this light there could be many interpretation of $\Pi$ types from different
areas of mathematics. We give here three:
i) logical interpretation of $\Pi$ as $\forall$ quantifier from higher order logic that forms a ground of type theory;
ii) geomeric intepretation of $\Pi$ as fiber bundle;
iii) categorical interpretation of functions as functors.

\subsubsection*{Type-theoretical interpretation}

As a logical system dependent type theory could correspond to higher order logic.
However here only type-theoretical model is given completely.

\begin{definition} ($\Pi$-Formation).
$$(x: A) \rightarrow B(x) =_{def} \prod_{x:A}B(x) : U.$$
\begin{lstlisting}
Pi (A: U) (B: A -> U): U = (x: A) -> B x
\end{lstlisting}
\end{definition}

\begin{definition} ($\Pi$-Introduction).
$$\backslash (x: A) \rightarrow b =_{def} \prod_{A:U}\prod_{B:A \rightarrow U}\prod_{a: A}\prod_{b:B(a)}\lambda x.b : \prod_{y:A}B(a).$$
\begin{lstlisting}
lambda (A B: U) (b: B): A -> B = \ (x: A) -> b
lam (A:U) (B: A -> U) (a:A) (b:B a)
   : A -> B a = \ (x: A) -> b
\end{lstlisting}
\end{definition}

\begin{definition} ($\Pi$-Elimination).
$$f\ a =_{def} \prod_{A:U}\prod_{B: A \rightarrow U}\prod_{a:A}\prod_{f: \prod_{x:A}B(a)}f(a) : B(a).$$
\begin{lstlisting}
apply (A B: U) (f: A -> B) (a: A) : B = f a
app (A: U) (B: A -> U) (a: A)
    (f: A -> B a) : B a = f a
\end{lstlisting}
\end{definition}

\begin{theorem} ($\Pi$-Computation).
$$f(a) =_{B(a)} (\lambda (x:A) \rightarrow f(a))(a).$$
\begin{lstlisting}
Beta (A: U) (B: A -> U) (a: A) (f: A -> B a)
   : Path (B a) (app A B a (lam A B a (f a)))
                (f a)
\end{lstlisting}
\end{theorem}

\begin{theorem} ($\Pi$-Uniqueness).
$$f =_{(x:A)\rightarrow B(a)} (\lambda (y:A) \rightarrow f(y)).$$
\begin{lstlisting}
Eta (A: U) (B: A -> U) (a: A) (f: A -> B a)
  : Path (A -> B a) f (\(x:A) -> f x)
\end{lstlisting}
\end{theorem}

\subsubsection*{Categorical interpretation}

The adjoints $\Pi$ and $\Sigma$ is not the only adjoints could be presented in type system.
Axiomatic cohesions could contain a set of adjoint pairs as a core type checker operations.

\begin{definition} (Dependent Product).
The dependent product along morphism $g: B \rightarrow A$ in category $C$ is the right
adjoint $\Pi_g : C_{/B} \rightarrow C_{/A}$ of the base change functor.
\end{definition}

\begin{definition} (Space of Sections).
Let $\mathbf{H}$ be a $(\infty,1)$-topos, and let $E \rightarrow B : \mathbf{H}_{/B}$ a bundle in
$\mathbf{H}$, object in the slice topos. Then the space of sections $\Gamma_\Sigma(E)$
of this bundle is the Dependent Product:
$$ \Gamma_\Sigma(E) = \Pi_\Sigma (E) \in \mathbf{H}. $$
\end{definition}

\begin{theorem} (HomSet).
If codomain is set then space of sections is a set.
\begin{lstlisting}
setFun (A B : U) (_: isSet B)
  : isSet (A -> B)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Contractability).
If domain and codomain is contractible then the space of sections is contractible.
\begin{lstlisting}
piIsContr (A: U) (B: A -> U) (u: isContr A)
          (q: (x: A) -> isContr (B x))
        : isContr (Pi A B)
\end{lstlisting}
\end{theorem}

\begin{definition} (Section).
A section of morphism $f: A \rightarrow B$ in some category is the morphism $g: B \rightarrow A$
such that $f \circ g: B \xrightarrow{g} A \xrightarrow{f} B$ equals the identity morphism on B.
\end{definition}

\subsubsection*{Homotopical interpretation}

Geometrically, $\Pi$ type is a space of sections, while the dependent codomain is a space of fibrations.
Lambda functions are sections or points in these spaces, while the function result is a fibration.
$\Pi$ type also represents the cartesian family of sets, generalizing the cartesian product of sets.

\begin{definition} (Fiber).
The fiber of the map $p: E \rightarrow B$ in a point $y: B$ is all points $x: E$ such that $p(x)=y$.
\end{definition}

\begin{definition} (Fiber Bundle).
The fiber bundle $ F \rightarrow E \xrightarrow{p} B$ on a total space $E$ with fiber layer $F$ and base $B$ is a
structure $(F,E,p,B)$ where $p: E \rightarrow B$ is a surjective map with following property:
for any point $y: B$ exists a neighborhood $U_b$ for which a homeomorphism $f: p^{-1}(U_b) \rightarrow U_b \times F$
making the following diagram commute.
\begin{center}
\begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=2em]
  {
     {p^{-1}(U_b)} & {U_b \times F} \\
     U_b & \\};
  \path[-stealth]
    (m-1-1) edge node [above] {$f$}    (m-1-2)
            edge node [left]  {$p$}    (m-2-1)
    (m-1-2) edge node [right] {$pr_1$} (m-2-1);
\end{tikzpicture}
\end{center}
\end{definition}

\begin{definition} (Cartesian Product of Family over B).
Is a set $F$ of sections of the bundle with elimination map $app : F \times B \rightarrow E$ such that
\begin{equation}
F \times B \xrightarrow{app} E \xrightarrow{pr_1} B
\end{equation}
$pr_1$ is a product projection, so $pr_1$, $app$ are morphisms
of slice category $Set_{/B}$. The universal mapping property of $F$:
for all $A$ and morphism $A \times B \rightarrow E$ in $Set_{/B}$ exists
unique map $A \rightarrow F$ such that everything commute. So a category
with all dependent products is necessarily a category with all pullbacks.
\end{definition}

\begin{definition} (Trivial Fiber Bundle).
When total space $E$ is cartesian product $\Sigma(B,F)$ and $p = pr_1$
then such bundle is called trivial $(F,\Sigma(B,F),pr_1,B)$.
\end{definition}

\begin{theorem} (Functions Preserve Paths).
For a function $f: (x:A) \rightarrow B(x)$
there is an $ap_f : x =_A y \rightarrow f(x) =_{B(x)} f(y)$. This is called
application of $f$ to path or congruence property (for non-dependent case ---
$cong$ function). This property behaves functoriality
as if paths are groupoid morphisms and types are objects.
\end{theorem}

\begin{theorem} (Trivial Fiber equals Family of Sets).
Inverse image (fiber) of fiber bundle $(F,B*F,pr_1,B)$ in point $y:B$ equals $F(y)$.
\begin{lstlisting}
FiberPi (B: U) (F: B -> U) (y: B)
  : Path U (fiber (Sigma B F) B (pi1 B F) y)
           (F y)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Homotopy Equivalence).
If fiber space is set for all base, and
there are two functions $f,g : (x:A) \rightarrow B(x)$ and two
homotopies between them, then these homotopies are equal.
\begin{lstlisting}
setPi (A: U) (B: A -> U)
    (h: (x: A) -> isSet (B x)) (f g: Pi A B)
    (p q: Path (Pi A B) f g)
  : Path (Path (Pi A B) f g) p q
\end{lstlisting}
\end{theorem}

Note that we will not be able to prove this theorem
until {\bf Issue III: Homotopy Type Theory} because
bi-invertible iso type will be announced there.

\subsection{Dependent Sum ($\Sigma$)}

$\Sigma$ is a dependent sum type, the generalization of products.
$\Sigma$ type is a total space of fibration. Element of total
space is formed as a pair of basepoint and fibration.

\subsubsection*{Type-theoretical interpretation}

\begin{definition} ($\Sigma$-Formation).
\begin{lstlisting}
Sigma (A : U) (B : A -> U)
  : U = (x : A) * B x
\end{lstlisting}
\end{definition}

\begin{definition} ($\Sigma$-Introduction).
\begin{lstlisting}
dpair (A: U) (B: A -> U) (a: A) (b: B a)
  : Sigma A B = (a,b)
\end{lstlisting}
\end{definition}

\begin{definition} ($\Sigma$-Elimination).
\begin{lstlisting}
pr1 (A: U) (B: A -> U)
    (x: Sigma A B): A = x.1

pr2 (A: U) (B: A -> U)
    (x: Sigma A B): B (pr1 A B x) = x.2

sigInd (A: U) (B: A -> U)
       (C: Sigma A B -> U)
       (g: (a: A) (b: B a) -> C (a, b))
       (p: Sigma A B) : C p = g p.1 p.2
\end{lstlisting}
\end{definition}

\begin{theorem} ($\Sigma$-Computation).
\begin{lstlisting}
Beta1 (A: U) (B: A -> U)
      (a:A) (b: B a)
    : Equ A a (pr1 A B (a,b))

Beta2 (A: U) (B: A -> U)
      (a: A) (b: B a)
    : Equ (B a) b (pr2 A B (a,b))
\end{lstlisting}
\end{theorem}

\begin{theorem} ($\Sigma$-Uniqueness).
\begin{lstlisting}
Eta2 (A: U) (B: A -> U) (p: Sigma A B)
   : Equ (Sigma A B) p (pr1 A B p,pr2 A B p)
\end{lstlisting}
\end{theorem}

\subsubsection*{Categorical interpretation}

\begin{definition} (Dependent Sum).
The dependent sum along the morphism $f: A \rightarrow B$ in category $C$ is the left
adjoint $\Sigma_f : C_{/A} \rightarrow C_{/B}$ of the base change functor.
\end{definition}

\subsubsection*{Set-theoretical interpretation}

\begin{theorem} (Axiom of Choice).
If for all $x : A$ there is $y : B$ such that $R(x,y)$,
then there is a function $f : A \rightarrow B$
such that for all $x : A$ there is a witness of $R(x,f(x))$.
\begin{lstlisting}
ac (A B: U) (R: A -> B -> U)
 : (p: (x:A) -> (y:B)*(R x y))
-> (f:A->B) * ((x:A)->R(x)(f x))
\end{lstlisting}
\end{theorem}

\begin{theorem} (Total).
If fiber over base implies another fiber
over the same base then we can construct total space of section
over that base with another fiber.
\begin{lstlisting}
total (A:U) (B C: A -> U)
      (f: (x:A) -> B x -> C x) (w: Sigma A B)
    : Sigma A C = (w.1,f (w.1) (w.2))
\end{lstlisting}
\end{theorem}

\begin{theorem} ($\Sigma$-Contractability). If the fiber is set then the $\Sigma$ is set.
\begin{lstlisting}
setSig (A:U) (B: A -> U) (sA: isSet A)
       (sB : (x:A) -> isSet (B x))
     : isSet (Sigma A B)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Path Between Sigmas).
Path between two sigmas $t,u: \Sigma(A,B)$ could be decomposed to
sigma of two paths $p:t_1=_{A}u_1)$ and $(t_2=_{B(p@i)}u_2)$.
\begin{lstlisting}
pathSig (A:U) (B : A -> U) (t u : Sigma A B)
      : Path U (Path (Sigma A B) t u)
               ((p: Path A t.1 u.1)
              * PathP (<i>B(p@i)) t.2 u.2)
\end{lstlisting}
\end{theorem}

\subsection{Path Space ($\Xi$)}

The Path identity type or $\Xi$ defines a Path space with elements and values.
Elements of that space are functions from interval $[0,1]$ to a values of that path space.
This ctt file reflects \footnote{Cyril Cohen, Thierry Coquand, Simon Huber, Anders M{\"{o}}rtberg. Cubical Type Theory: a constructive interpretation of the univalence axiom. 2015. \url{https://5ht.co/cubicaltt.pdf}}{CCHM} cubicaltt model with connections.
For \footnote{Carlo Angiuli, Brunerie, Coquand, Kuen-Bang Hou (Favonia), Robert Harper, Dan Licata. Cartesian Cubical Type Theory. 2017. \url{https://5ht.co/cctt.pdf}}{ABCFHL} yacctt model with
variables please refer to ytt file. You may also want to
read \footnote{Marc Bezem, Thierry Coquand, Simon Huber. A model of type theory in cubical sets. 2014. \url{http://www.cse.chalmers.se/~coquand/mod1.pdf}}{BCH},
\footnote{Carlo Angiuli, Kuen-Bang Hou (Favonia), Robert Harper. Cartesian Cubical Computational Type Theory: Constructive Reasoning with Paths and Equalities. 2018. \\ \url{https://www.cs.cmu.edu/~cangiuli/papers/ccctt.pdf}}{AFH}.
There is a \footnote{Andrew Pitts, Ian Orton. Axioms for Modelling Cubical Type Theory in a Topos. 2016. \url{https://arxiv.org/pdf/1712.04864.pdf}}{PO} paper about CCHM axiomatic in a topos.

\subsubsection*{Cubical interpretation}

Cubical interpretation was first given by Simon Huber \cite{Huber16} and later was
written first constructive type checker in the world by Anders M{\"{o}}rtberg \cite{Mortberg17}.

\begin{definition} (Path Formation).
\begin{lstlisting}
Hetero (A B: U)(a: A)(b: B)(P: Path U A B)
  : U = PathP P a b
Path (A: U) (a b: A)
  : U = PathP (<i> A) a b
\end{lstlisting}
\end{definition}

\begin{definition} (Path Reflexivity).
Returns an element of reflexivity path space for a given value of the type.
The inhabitant of that path space is the lambda on the homotopy
interval $[0,1]$ that returns a constant value a. Written in
syntax as |<i>a| which equals to $\lambda\ (i: I) \rightarrow a$.
\begin{lstlisting}
refl (A: U) (a: A) : Path A a a
\end{lstlisting}
\end{definition}

\begin{definition} (Path Application).
You can apply face to path.
\begin{lstlisting}
app1 (A: U)(a b:A)(p:Path A a b):A=p@0
app2 (A: U)(a b:A)(p:Path A a b):A=p@1
\end{lstlisting}
\end{definition}

\begin{definition} (Path Composition).
Composition operation allows to build a new path by given to paths
in a connected point.
\begin{center}
\begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=3em]
  {
     a & c \\ % (1,1) (1,2)
     a & b \\ % (2,1) (2,2)
  };
  \path[-stealth]
    (m-1-1) edge node [above] {$comp$} (m-1-2)
    (m-2-1) edge node [left]  {$\lambda(i:I)\rightarrow a$} (m-1-1)
    (m-2-2) edge node [right] {$q$} (m-1-2)
    (m-2-1) edge node [above] {$p @ i$} (m-2-2);
\end{tikzpicture}
\end{center}
\begin{lstlisting}
composition
    (A: U) (a b c: A)
    (p: Path A a b) (q: Path A b c)
  : Path A a c
  = comp (<i>Path A a (q@i)) p []
\end{lstlisting}
\end{definition}

\begin{theorem} (Path Inversion).
\begin{lstlisting}
inv (A: U) (a b: A) (p: Path A a b)
  : Path A b a = <i> p @ -i
\end{lstlisting}
\end{theorem}

\begin{definition} (Connections).
Connections allows you to build square
with given only one element of path: i) $\lambda\ (i,j: I) \rightarrow p\ @\ min(i,j)$;
ii) $\lambda\ (i,j:I) \rightarrow p\ @\ max(i,j)$.
\begin{center}
  \begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=3em]
  {
     a & b \\ % (1,1) (1,2)
     a & a                    \\ % (2,1) (2,2)
  };
  \path[-stealth]
    (m-1-1) edge node [above] {$p$}    (m-1-2)
    (m-2-1) edge node [left]  {$\lambda\ (i:I)\rightarrow a$}    (m-1-1)
    (m-2-2) edge node [right] {$p$} (m-1-2)
    (m-2-1) edge node [above] {$\lambda\ (i:I)\rightarrow a$} (m-2-2);
  \end{tikzpicture}
  \begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=3em]
  {
     b & b \\ % (1,1) (1,2)
     a & b                    \\ % (2,1) (2,2)
  };
  \path[-stealth]
    (m-1-1) edge node [above] {$\lambda\ (i:I) \rightarrow b$}    (m-1-2)
    (m-2-1) edge node [left]  {$p$}    (m-1-1)
    (m-2-2) edge node [right] {$\lambda\ (i:I) \rightarrow b$} (m-1-2)
    (m-2-1) edge node [above] {$p$} (m-2-2);
  \end{tikzpicture}
\end{center}
\begin{lstlisting}
meet (A: U) (a b: A) (p: Path A a b)
  : PathP (<x> Path A a (p@x)) (<i>a) p
  = <x y> p @ (x /\ y)

join (A: U) (a b: A) (p: Path A a b)
  : PathP (<x> Path A (p@x) b) p (<i>b)
  = <y x> p @ (x \/ y)
\end{lstlisting}
\end{definition}

\begin{theorem} (Congruence).
Is a map between values of one type
to path space of another type by an encode function between types.
Implemented as lambda defined on $[0,1]$ that returns
application of encode function to path application of
the given path to lamda argument |$\lambda$ (i:I) $\rightarrow$ f (p @ i)|
for both cases.
\begin{lstlisting}
ap  (A B: U) (f: A -> B)
    (a b: A) (p: Path A a b)
  : Path B (f a) (f b)

apd (A: U) (a x:A) (B: A -> U) (f: A -> B a)
    (b: B a) (p: Path A a x)
  : Path (B a) (f a) (f x)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Transport).
Transports a value of the domain type to the value of the codomain type
by a given path element of the path space between domain and codomain types.
Defined as path composition with |[]| of a over a path $p$ --- |comp p a []|.
\begin{lstlisting}
trans (A B: U) (p: Path U A B) (a: A) : B
\end{lstlisting}
\end{theorem}

\subsubsection*{Type-theoretical interpretation}
\begin{definition} (Singleton).
\begin{lstlisting}
singl (A: U) (a: A): U = (x: A) * Path A a x
\end{lstlisting}
\end{definition}

\begin{theorem} (Singleton Instance).
\begin{lstlisting}
eta (A: U) (a: A): singl A a = (a,refl A a)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Singleton Contractability).
\begin{lstlisting}
contr (A: U) (a b: A) (p: Path A a b)
  : Path (singl A a) (eta A a) (b,p)
  = <i> (p @ i,<j> p @ i/\j)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Path Elimination, Paulin-Mohring).
J is formulated in a form of Paulin-Mohring and implemented using
two facts that singleton are contractible and dependent function
transport.
\begin{lstlisting}
J (A: U) (a b: A)
  (P: singl A a -> U)
  (u: P (a,refl A a))
  (p: Path A a b) : P (b,p)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Path Elimination, HoTT).
J from HoTT book.
\begin{lstlisting}
J (A: U) (a b: A)
  (C: (x: A) -> Path A a x -> U)
  (d: C a (refl A a))
  (p: Path A a b) : C b p
\end{lstlisting}
\end{theorem}

\begin{theorem} (Path Computation).
\begin{lstlisting}
trans_comp (A: U) (a: A)
  : Path A a (trans A A (<_> A) a)
  = fill (<i> A) a []
subst_comp (A: U) (P: A -> U) (a: A) (e: P a)
  : Path (P a) e (subst A P a a (refl A a) e)
  = trans_comp (P a) e
J_comp (A: U) (a: A) (C: (x: A)
 -> Path A a x -> U) (d: C a (refl A a))
  : Path (C a(refl A a)) d
         (J A a C d a(refl A a))
  = subst_comp (singl A a) T (eta A a) d
    where T (z:singl A a)
        : U = C a (z.1) (z.2)
\end{lstlisting}
\end{theorem}

Note that  Path type has no Eta rule due to groupoid interpretation.

\subsubsection*{Groupoid interpretation}
The groupoid interpretation of type theory is well known article by Martin Hofmann and Thomas Streicher,
more specific interpretation of identity type as infinity groupoid.

\subsection{Contexts and Universes}
Speaking of type checker execution, we introduce context or dictionary with types and terms,
from which we can derive typed variables. This chain could be implemented as
nested sigma types (due to R.A.G.Seely) or list types (due to Voevodsky). Categorically
dependent type theory is built upon categories of contexts.

\begin{definition} (Empty Context).
$$
    \gamma_0 : \Gamma =_{def} \star.
$$
\end{definition}

\begin{definition} (Context Comprehension).
$$
\Gamma\ ; A =_{def} \sum_{\gamma:\Gamma}A(\gamma).
$$
\end{definition}

\begin{definition} (Context Derivability).
$$
\Gamma \vdash A =_{def} \prod_{\gamma:\Gamma}A(\gamma).
$$
\end{definition}

\begin{definition} (Terms). Point in initial object of language AST
inductive definition is called a term. If type theory or language is defined as
an inductive type (AST) then the term is defined as its instance.
\end{definition}

\begin{definition} (Sorts). N-indexed set of universes $\mathrm{U}_{n \in \mathrm{N}}$.
Could have any number of elements which defines different type systems. All built-in
types as long as user defined types are landed usually by default in $U_0$ universe.
Sorts represented in type checker as a separate constructor.
\end{definition}

\begin{definition} (Axioms). The inclusion rules {\bf $\mathrm{U_i : U_j}, i,j \in \mathrm{N}$},
that define which universe is element of another given universe. You may attach
any rules that joins $i,j$ in some way. Axioms with sorts define universe hierarchy.
\end{definition}

\begin{definition} (Rules). The set of landings
$\mathrm{U_i} \rightarrow \mathrm{U_j} : \mathrm{U_{\lambda(i,j), i,j \in \mathrm{N}}}$,
where $\mathrm{\lambda : N \times N \rightarrow N}$. These rules define term dependence or
how we land (in which universe) formation rules in definitions.
\end{definition}

\begin{definition} (Predicative hierarchy). If $\mathrm{\lambda}$ in Rules
is an uncurried function $\mathrm{max : N \times N \rightarrow N}$
then such universe hierarchy is called predicative.
\end{definition}

\begin{definition} (Impredicative hierarchy). If $\lambda$ in Rules
is a second projection of a tuple $\mathrm{snd : N \times N \rightarrow N}$
then such universe hierarchy is called impredicative.
\end{definition}

\begin{definition} (Definitional Equality). For any $\mathrm{U}_i, i \in \mathrm{N}$ there is
defined an equality between its members and between its instances.
For all x,y $\in$ A, there is defined a x=y. Definitional equality
compares normalized term instances.
\end{definition}

\begin{definition} (SAR). The universum space is configured with a triple of:
i) sorts, a set of universes  $\mathrm{U}_{n \in \mathrm{N}}$ indexed over set N;
ii) axioms, a set of inclusions {\bf $\mathrm{U_i : U_j}, i,j \in \mathrm{N}$};
iii) rules of term dependence universe landing, a set of landings
$\mathrm{U_i} \rightarrow \mathrm{U_j} : \mathrm{U_{\lambda(i,j), i,j \in \mathrm{N}}}$, where $\lambda$ could be function $max$ (predicative) or $snd$ (impredicative).
\end{definition}

\begin{example} (CoC). SAR = $\{ \{\star , \Box \},\{ \star : \Box \},
        \{ i \rightarrow j : j; i, j \in \{ \star, \Box \}
        \}$. Terms live in universe $\star$, and types live in universe $\Box$. In CoC $\mathrm{\lambda=snd}$.
\end{example}

\begin{example} ($\mathrm{PTS}^\infty$, $\mathrm{MLTT}^\infty$).\\ SAR = $\{ \mathrm{U}_{i \in \mathrm{N}},
    \mathrm{U_i : U_{j; i < j; i,j \in N}},
    \mathrm{U_i} \rightarrow \mathrm{U_j} : \mathrm{U_{\lambda(i,j); i,j \in \mathrm{N}}}
    \}$. Where $U_i$ is a universe of $i$-level or $i$-category in categorical interpretation.
\end{example}

\subsection{MLTT-73}
Here is given formal model of type-theoretical interpretation of Martin-Löf Type Theory.
It combines 4 Path rules (no eta), 5 $\Pi$ rules, and 6 $\Sigma$ rules (two elims).
The proof is provided by direct embedding (internalizing) the model intro the model
of type checker which is even more powerful.

\begin{definition} (MLTT-73).
The MLTT as a Type is defined by taking all rules
for $\Pi$, $\Sigma$ and Path types into one $\Sigma$ telescope or context.
\begin{lstlisting}[mathescape=true]
MLTT (A: U): U
  = (Pi_Former: (A $\rightarrow$ U) $\rightarrow$ U)
  * (Pi_Intro: (B: A $\rightarrow$ U) (a: A) $\rightarrow$ B a $\rightarrow$ (A $\rightarrow$ B a))
  * (Pi_Elim: (B: A $\rightarrow$ U) (a: A) $\rightarrow$ (A $\rightarrow$ B a) $\rightarrow$ B a)
  * (Pi_Comp$_1$: (B: A $\rightarrow$ U) (a: A)
    (f: A $\rightarrow$ B a) $\rightarrow$ Path (B a)
    (Pi_Elim B a(Pi_Intro B a(f a)))(f a))
  * (Pi_Comp$_2$: (B: A $\rightarrow$ U) (a: A)
    (f: A $\rightarrow$ B a) $\rightarrow$ Path (A $\rightarrow$ B a) f (\(x:A) $\rightarrow$ f x))
  * (Sigma_Former: (A $\rightarrow$ U) $\rightarrow$ U)
  * (Sigma_Intro: (B: A $\rightarrow$ U) (a: A) (b: B a) $\rightarrow$ Sigma A B)
  * (Sigma_Elim1: (B: A $\rightarrow$ U)
    (_: Sigma A B) $\rightarrow$ A)
  * (Sigma_Elim2: (B: A $\rightarrow$ U)
    (x: Sigma A B) $\rightarrow$ B (pr1 A B x))
  * (Sigma_Comp1: (B: A $\rightarrow$ U) (a: A) (b: B a) 
      $\rightarrow$ Path A a (Sigma_Elim1 B (Sigma_Intro B a b)))
  * (Sigma_Comp2: (B: A $\rightarrow$ U) (a: A)
    (b: B a) $\rightarrow$ Path (B a) b
    (Sigma_Elim2 B (a,b)))
  * (Sigma_Comp3: (B: A $\rightarrow$ U) (p: Sigma A B)
      $\rightarrow$ Path (Sigma A B) p (pr1 A B p,pr2 A B p))
  * (Id_Former: A $\rightarrow$ A $\rightarrow$ U)
  * (Id_Intro: (a: A) $\rightarrow$ Path A a a)
  * (Id_Elim: (x: A) (C: D A)
    (d: C x x (Id_Intro x))
    (y: A) (p: Path A x y) $\rightarrow$ C x y p)
  * (Id_Comp: (a:A)(C: D A)
    (d: C a a (Id_Intro a)) $\rightarrow$
    Path (C a a (Id_Intro a))
       d (Id_Elim a C d a (Id_Intro a))) * U
\end{lstlisting}
\end{definition}

\begin{theorem} (Model Check).
There is an instance of MLTT.
\begin{lstlisting}
instance (A: U) : MLTT A
  = ( Pi A, lam A, app A, Beta A, Eta A,
      Sigma A, dpair A, pr1 A, pr2 A, Beta1 A, Beta2 A, Eta2 A,
      Path A, refl A, J A, J_comp A, A
    )
\end{lstlisting}
\end{theorem}

The result of the work is a \texttt{mltt.ctt} file which can be runned using \texttt{cubicaltt}.
Note that MLTT-73 internalization includes only eliminator and computational rule (without uniquness rule)
for identity system, as cubical Path spaces refute uniqueness of identity proofs.

\subsection*{Conclusions}

This article presents a landmark achievement in type theory:
the constructive internalization of Martin-Löf Type Theory (MLTT-73)
within the \textbf{Per} language, a minimal type system equipped with
cubical type theory primitives. By embedding MLTT-73’s core types
--- dependent function types ($\Pi$), dependent pair types ($\Sigma$),
and identity types (Id, modeled as Path ($\Xi$) types in cubical syntax) ---
we have constructively verified all inference rules, including the pivotal
J eliminator, using the cubical type checker \cite{Mortberg17}.

This internalization, formalized in the \texttt{mltt.ctt} file and
validated with cubicaltt, marks a significant advance in mechanized
reasoning, as it provides a rigorous test of a type checker’s ability
to fuse introduction and elimination rules through beta and eta equalities.

\begin{table}[!ht]
  \begin{tabular}{lccccccccc}
    \hline
       Language    & $U^n$ & $\Pi$ & $\Sigma$ & Id & $\Xi$ & $\mathbb{N}$ & 0/1/2 & $W$ & Ind  \\
    \hline
Systen P$_\omega$ (CoC-88)  &   & x &   &   &   &   &   &   &   \\
       MLTT-72              &   & x & x &   &   &   &   &   &   \\
       Henk (ECC)           & x & x &   &   &   &   &   &   &   \\
       Errett (LCCC/IPL)    & x & x & x &   &   &   & x &   &   \\
       MLTT-73              & x & x & x & x &   &   &   &   &   \\
       Per                  & x & x & x &   & x &   &   &   &   \\
       MLTT-75              & x & x & x & x &   & x & x &   &   \\
       MLTT-80              & x & x & x & x &   & & x   & x &   \\
       Anders (HTS)         & x & x & x & x & x &   & x & x &   \\
       Frank (CoC+CIC)      & x & x &   &   &   &   &   &   & x \\
       Christine (Coq)      & x & x & x & x &   &   &   &   & x \\
    \hline
       cubicaltt            &   & x & x &   & x &   &   &   & x \\
       Agda                 & x & x & x & x & x &   &   &   & x \\
       Lean                 & x & x & x & x &   &   &   &   & x \\
       NuPRL                &   & x & x & x &   &   &   &   &   \\
    \hline
  \end{tabular}
\end{table}

The significance of this work lies in its constructive approach to the
J eliminator, a cornerstone of MLTT-75’s identity type, which previous
internalization attempts failed to derive constructively \cite{Lof75, Nordstrom90}.
By leveraging cubical type theory’s Path types and operations (e.g., connections,
compositions), \textbf{Per} achieves a compact and robust framework for encoding
MLTT-75, as demonstrated by the type-theoretical model presented herein.
The article also elucidates MLTT-75’s versatility through logical, categorical,
homotopical, and set-theoretical interpretations, offering a comprehensive
landscape for researchers and newcomers to type theory.

The internalization of MLTT-75 in \textbf{Per} advances the mechanization
of constructive mathematics by providing a verified foundation for type checkers.
\textbf{Per}’s cubical framework ensures that all inference rules,
except for Path types refuting UIP are derivable, fulfilling a core objective
of constructive reasoning: verifiable mathematical proofs.

\begin{thebibliography}{99}

\bibitem{HoTT13}
Vladimir Voevodsky et al.,
\textit{Homotopy Type Theory},
in \textit{Univalent Foundations of Mathematics},
2013.

\bibitem{Cavallo19}
Evan Cavallo, Anders Mörtberg, and Andrew W. Swan,
\textit{Unifying Cubical Models of Univalent Type Theory},
Preprint, 2019.
\url{http://www.cs.cmu.edu/~amoertbe/papers/unifying.pdf}

\bibitem{Lof72}
Per Martin-Löf and Giovanni Sambin,
\textit{The Theory of Types},
in \textit{Studies in Proof Theory},
1972.

\bibitem{Lof75}
Per Martin-Löf,
\textit{An Intuitionistic Theory of Types: Predicative Part},
in \textit{Studies in Logic and the Foundations of Mathematics},
vol. 80, pp. 73–118, 1975.
\texttt{doi:10.1016/S0049-237X(08)71945-1}

\bibitem{Lof84}
Per Martin-Löf and Giovanni Sambin,
\textit{Intuitionistic Type Theory},
in \textit{Studies in Proof Theory},
1984.

\bibitem{Coq88}
Thierry Coquand and Gérard Huet,
\textit{The Calculus of Constructions},
in \textit{Information and Computation},
pp. 95–120, 1988.
\texttt{doi:10.1016/0890-5401(88)90005-3}

\bibitem{Hofmann96}
Martin Hofmann and Thomas Streicher,
\textit{The Groupoid Interpretation of Type Theory},
in \textit{Venice Festschrift},
Oxford University Press, pp. 83–111, 1996.

\bibitem{Hermida95}
Claudio Hermida and Bart Jacobs,
\textit{Fibrations with Indeterminates: Contextual and Functional Completeness for Polymorphic Lambda Calculi},
in \textit{Mathematical Structures in Computer Science},
vol. 5, pp. 501–531, 1995.

\bibitem{Dybjer08}
Alexandre Buisse and Peter Dybjer,
\textit{The Interpretation of Intuitionistic Type Theory in Locally Cartesian Closed Categories -- an Intuitionistic Perspective},
in \textit{Electronic Notes in Theoretical Computer Science},
pp. 21–32, 2008.
\texttt{doi:10.1016/j.entcs.2008.10.003}

\bibitem{Abel08}
Andreas Abel, Thierry Coquand, and Peter Dybjer,
\textit{On the Algebraic Foundation of Proof Assistants for Intuitionistic Type Theory},
in \textit{Functional and Logic Programming},
Springer, Berlin, Heidelberg, pp. 3–13, 2008.

\bibitem{Curien14}
Pierre-Louis Curien et al.,
\textit{Revisiting the Categorical Interpretation of Dependent Type Theory},
in \textit{Theoretical Computer Science},
vol. 546, pp. 99–119, 2014.
\texttt{doi:10.1016/j.tcs.2014.03.003}

\bibitem{Bishop67}
Errett Bishop,
\textit{Foundations of Constructive Analysis},
1967.

\bibitem{Nordstrom90}
Bengt Nordström, Kent Petersson, and Jan M. Smith,
\textit{Programming in Martin-Löf’s Type Theory},
Oxford University Press, 1990.

\bibitem{Sozeau}
Matthieu Sozeau and Nicolas Tabareau,
\textit{Internalizing Intensional Type Theory},
unpublished.

\bibitem{Hofmann94}
Martin Hofmann and Thomas Streicher,
\textit{The Groupoid Model Refutes Uniqueness of Identity Proofs},
in \textit{Logic in Computer Science (LICS'94)}, IEEE, pp. 208–212, 1994.

\bibitem{Jacobs99}
Bart Jacobs,
\textit{Categorical Logic and Type Theory},
vol. 141, 1999.

\bibitem{Mortberg17}
Anders Mörtberg et al.,
\textit{Cubical Type Theory: A Constructive Interpretation of the Univalence Axiom},
arXiv:1611.02108, 2017.

\bibitem{Huber16}
Simon Huber,
\textit{Cubical Interpretations of Type Theory},
Ph.D. thesis, Dept. of Computer Science and Engineering, University of Gothenburg, 2016.

\bibitem{Tonpa18}
Maksym Sokhatskyi and Pavlo Maslianko,
\textit{The Systems Engineering of Consistent Pure Language with Effect Type System for Certified Applications and Higher Languages},
in \textit{Proc. 4th Int. Conf. Mathematical Models and Computational Techniques in Science and Engineering},
2018.
\texttt{doi:10.1063/1.5045439}
\end{thebibliography}

\end{document}

