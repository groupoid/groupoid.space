\documentclass{article}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{url}
\usepackage{tikz-cd}
\usepackage[utf8]{inputenc}

\setlength{\parindent}{15pt}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\lstset{basicstyle=\footnotesize,inputencoding=utf8,
literate=
{𝟎}{{\ensuremath{\mathbf{0}}}}1
{𝟏}{{\ensuremath{\mathbf{1}}}}1
{≔}{{\ensuremath{\mathrm{:=}}}}1
{α}{{\ensuremath{\mathrm{\alpha}}}}1
{ᵂ}{{\ensuremath{^W}}}1
{β}{{\ensuremath{\mathrm{\beta}}}}1
{γ}{{\ensuremath{\mathrm{\gamma}}}}1
{δ}{{\ensuremath{\mathrm{\delta}}}}1
{ε}{{\ensuremath{\mathrm{\varepsilon}}}}1
{ζ}{{\ensuremath{\mathrm{\zeta}}}}1
{η}{{\ensuremath{\mathrm{\eta}}}}1
{θ}{{\ensuremath{\mathrm{\theta}}}}1
{ι}{{\ensuremath{\mathrm{\iota}}}}1
{κ}{{\ensuremath{\mathrm{\kappa}}}}1
{λ}{{\ensuremath{\mathrm{\lambda}}}}1
{μ}{{\ensuremath{\mathrm{\mu}}}}1
{ν}{{\ensuremath{\mathrm{\nu}}}}1
{ξ}{{\ensuremath{\mathrm{\xi}}}}1
{π}{{\ensuremath{\mathrm{\mathnormal{\pi}}}}}1
{ρ}{{\ensuremath{\mathrm{\rho}}}}1
{σ}{{\ensuremath{\mathrm{\sigma}}}}1
{τ}{{\ensuremath{\mathrm{\tau}}}}1
{φ}{{\ensuremath{\mathrm{\varphi}}}}1
{χ}{{\ensuremath{\mathrm{\chi}}}}1
{ψ}{{\ensuremath{\mathrm{\psi}}}}1
{ω}{{\ensuremath{\mathrm{\omega}}}}1
{Π}{{\ensuremath{\mathrm{\Pi}}}}1
{Γ}{{\ensuremath{\mathrm{\Gamma}}}}1
{Δ}{{\ensuremath{\mathrm{\Delta}}}}1
{Θ}{{\ensuremath{\mathrm{\Theta}}}}1
{Λ}{{\ensuremath{\mathrm{\Lambda}}}}1
{Σ}{{\ensuremath{\mathrm{\Sigma}}}}1
{Φ}{{\ensuremath{\mathrm{\Phi}}}}1
{Ξ}{{\ensuremath{\mathrm{\Xi}}}}1
{Ψ}{{\ensuremath{\mathrm{\Psi}}}}1
{Ω}{{\ensuremath{\mathrm{\Omega}}}}1
{ℵ}{{\ensuremath{\aleph}}}1
{≤}{{\ensuremath{\leq}}}1
{≥}{{\ensuremath{\geq}}}1
{≠}{{\ensuremath{\neq}}}1
{≈}{{\ensuremath{\approx}}}1
{≡}{{\ensuremath{\equiv}}}1
{≃}{{\ensuremath{\simeq}}}1
{≤}{{\ensuremath{\leq}}}1
{≥}{{\ensuremath{\geq}}}1
{∂}{{\ensuremath{\partial}}}1
{∆}{{\ensuremath{\triangle}}}1 % or \laplace?
{∫}{{\ensuremath{\int}}}1
{∑}{{\ensuremath{\mathrm{\Sigma}}}}1
{→}{{\ensuremath{\rightarrow}}}1
{⊥}{{\ensuremath{\perp}}}1
{∞}{{\ensuremath{\infty}}}1
{∂}{{\ensuremath{\partial}}}1
{∓}{{\ensuremath{\mp}}}1
{±}{{\ensuremath{\pm}}}1
{×}{{\ensuremath{\times}}}1
{⊕}{{\ensuremath{\oplus}}}1
{⊗}{{\ensuremath{\otimes}}}1
{⊞}{{\ensuremath{\boxplus}}}1
{∇}{{\ensuremath{\nabla}}}1
{√}{{\ensuremath{\sqrt}}}1
{⬝}{{\ensuremath{\cdot}}}1
{•}{{\ensuremath{\cdot}}}1
{∘}{{\ensuremath{\circ}}}1
{⁻}{{\ensuremath{^{-}}}}1
{▸}{{\ensuremath{\blacktriangleright}}}1
{∧}{{\ensuremath{\wedge}}}1
{∨}{{\ensuremath{\vee}}}1
{¬}{{\ensuremath{\neg}}}1
{⊢}{{\ensuremath{\vdash}}}1
{⟨}{{\ensuremath{\langle}}}1
{⟩}{{\ensuremath{\rangle}}}1
{↦}{{\ensuremath{\mapsto}}}1
{→}{{\ensuremath{\rightarrow}}}1
{↔}{{\ensuremath{\leftrightarrow}}}1
{⇒}{{\ensuremath{\Rightarrow}}}1
{⟹}{{\ensuremath{\Longrightarrow}}}1
{⇐}{{\ensuremath{\Leftarrow}}}1
{⟸}{{\ensuremath{\Longleftarrow}}}1
{∩}{{\ensuremath{\cap}}}1
{∪}{{\ensuremath{\cup}}}1
{⊂}{{\ensuremath{\subseteq}}}1
{⊆}{{\ensuremath{\subseteq}}}1
{⊄}{{\ensuremath{\nsubseteq}}}1
{⊈}{{\ensuremath{\nsubseteq}}}1
{⊃}{{\ensuremath{\supseteq}}}1
{⊇}{{\ensuremath{\supseteq}}}1
{⊅}{{\ensuremath{\nsupseteq}}}1
{⊉}{{\ensuremath{\nsupseteq}}}1
{∈}{{\ensuremath{\in}}}1
{∉}{{\ensuremath{\notin}}}1
{∋}{{\ensuremath{\ni}}}1
{∌}{{\ensuremath{\notni}}}1
{∅}{{\ensuremath{\emptyset}}}1
{∖}{{\ensuremath{\setminus}}}1
{†}{{\ensuremath{\dag}}}1
{ℕ}{{\ensuremath{\mathbb{N}}}}1
{ℤ}{{\ensuremath{\mathbb{Z}}}}1
{ℝ}{{\ensuremath{\mathbb{R}}}}1
{ℚ}{{\ensuremath{\mathbb{Q}}}}1
{ℂ}{{\ensuremath{\mathbb{C}}}}1
{⌞}{{\ensuremath{\llcorner}}}1
{⌟}{{\ensuremath{\lrcorner}}}1
{⦃}{{\ensuremath{ \{\!| }}}1
{⦄}{{\ensuremath{ |\!\} }}}1
{₁}{{\ensuremath{_1}}}1
{₂}{{\ensuremath{_2}}}1
{₃}{{\ensuremath{_3}}}1
{₄}{{\ensuremath{_4}}}1
{₅}{{\ensuremath{_5}}}1
{₆}{{\ensuremath{_6}}}1
{₇}{{\ensuremath{_7}}}1
{₈}{{\ensuremath{_8}}}1
{₉}{{\ensuremath{_9}}}1
{₀}{{\ensuremath{_0}}}1
{¹}{{\ensuremath{^1}}}1
{ₙ}{{\ensuremath{_n}}}1
{ₘ}{{\ensuremath{_m}}}1
{↑}{{\ensuremath{\uparrow}}}1
{↓}{{\ensuremath{\downarrow}}}1
{▸}{{\ensuremath{\triangleright}}}1
{∀}{{\ensuremath{\forall}}}1
{∃}{{\ensuremath{\exists}}}1
{λ}{{\ensuremath{\mathrm{\lambda}}}}1
{=}{{\ensuremath{=}}}1
{<}{{\ensuremath{\langle}}}1
{>}{{\ensuremath{\rangle}}}1
{(}{(}1
{(}{(}1
{‖}{‖}1
{+}{{+}}1
{*}{{*}}1,
}

\begin{document}

\title{Issue II: Inductive Types}
\author{Maksym Sokhatskyi $^1$}
\date{ $^1$ National Technical University of Ukraine \\
       \small Igor Sikorsky Kyiv Polytechnical Institute \\
       \today }

\maketitle

\begin{abstract}

Impredicative Encoding of Inductive Types in HoTT.
\\
\\
{\bf Keywords}: Formal Methods, Type Theory, Programming Languages,
          Theoretical Computer Science, Applied Mathematics,
          Cubical Type Theory, Martin-Löf Type Theory
\end{abstract}

\ifincludeTOC
  \tableofcontents
\fi

\newpage
\section{Inductive Encodings}

\subsection{Church Encoding}

You know Church encoding which also has its dependent alanolgue in CoC, however
in Coq it is imposible to detive Inductive Principle as type system lacks fixpoint
and functional extensionality. The example of working compiler of PTS languages are Om and Morte.
Assume we have Church encoded NAT:

\begin{lstlisting}[mathescape=true]
nat = (X:U) -> (X -> X) -> X -> X
\end{lstlisting}

where first parameter $(X -> X)$ is a $succ$, the second parameter $X$ is $zero$,
and the result of encoding is landed in X. Even if we encode the parameter

\begin{lstlisting}[mathescape=true]
list (A: U) = (X:U) -> X -> (A -> X) -> X
\end{lstlisting}

and paremeter A let's say live in 42 universe and X live in 2 universe, then by
the signature of encoding the term will be landed in X, thus 2 universe. In other words
such dependency is called impredicative displaying that landed term is not a predicate over parameters.
This means that Church encoding is incompatible with predicative type checkers with predicative
of predicative-cumulative hierarchies.


\subsection{Scott Encoding}

\subsection{Parigot Encoding}

\subsection{CPS Encoding}

\subsection{Interaction Networks Encoding}

\subsection{Impredicative Encoding}

In HoTT n-types is encoded as n-groupoids, thus we need to add a predicate in which n-type
we would like to land the encoding:

\begin{lstlisting}[mathescape=true]
NAT (A: U) = (X:U) -> isSet X -> X -> (A -> X) -> X
\end{lstlisting}

Here we added isSet predicate. With this motto we can implement propositional
truncation by landing term in isProp or even HIT by langing in isGroupoid:

\begin{lstlisting}[mathescape=true]
TRUN (A:U) type = (X: U) -> isProp X -> (A -> X) -> X
S1 = (X:U) -> isGroupoid X -> ((x:X) -> Path X x x) -> X
MONOPLE (A:U) = (X:U) -> isSet X -> (A -> X) -> X
NAT = (X:U) -> isSet X -> X -> (A -> X) -> X
\end{lstlisting}

The main publication on this topic could be found at \cite{Awodey17} and \cite{Speight17}.

\subsubsection*{The Unit Example}

Here we have the implementation of Unit impredicative encoding in HoTT.

\begin{lstlisting}[mathescape=true]
upPath     (X Y:U)(f:X->Y)(a:X->X): X -> Y = o X X Y f a
downPath   (X Y:U)(f:X->Y)(b:Y->Y): X -> Y = o X Y Y b f
naturality (X Y:U)(f:X->Y)(a:X->X)(b:Y->Y): U
  = Path (X->Y)(upPath X Y f a)(downPath X Y f b)

unitEnc': U = (X: U) -> isSet X -> X -> X
isUnitEnc (one: unitEnc'): U
  = (X Y:U)(x:isSet X)(y:isSet Y)(f:X->Y) ->
    naturality X Y f (one X x)(one Y y)

unitEnc: U = (x: unitEnc') * isUnitEnc x
unitEncStar: unitEnc = (\(X:U)(_:isSet X) ->
  idfun X,\(X Y: U)(_:isSet X)(_:isSet Y)->refl(X->Y))
unitEncRec  (C: U) (s: isSet C) (c: C): unitEnc -> C
  = \(z: unitEnc) -> z.1 C s c
unitEncBeta (C: U) (s: isSet C) (c: C)
  : Path C (unitEncRec C s c unitEncStar) c = refl C c
unitEncEta (z: unitEnc): Path unitEnc unitEncStar z = undefined
unitEncInd (P: unitEnc -> U) (a: unitEnc): P unitEncStar -> P a
  = subst unitEnc P unitEncStar a (unitEncEta a)
unitEncCondition (n: unitEnc'): isProp (isUnitEnc n)
  =  \ (f g: isUnitEnc n) ->
     <h> \ (x y: U) -> \ (X: isSet x) -> \ (Y: isSet y)
  -> \ (F: x -> y) -> <i> \ (R: x) -> Y (F (n x X R)) (n y Y (F R))
       (<j> f x y X Y F @ j R) (<j> g x y X Y F @ j R) @ h @ i
\end{lstlisting}

\subsection{Lambek Encoding: Homotopy Initial Algebras}

\newpage
\section{Inductive Types}

\subsection{W}

Well-founded trees without mutual recursion represented as $\mathrm{W}$-types.

\begin{definition} ($\mathrm{W}$-Formation).
For $A : \mathcal{U}$ and $B : A \rightarrow \mathcal{U}$, type $\mathrm{W}$
is defined as $\mathrm{W}(A,B) : \mathcal{U}$ or
$$
   \mathrm{W}_{(x : A)} B(x) : \mathcal{U}.
$$
\begin{lstlisting}[mathescape=true]
def W$'$ (A : U) (B : A → U) : U := W (x : A), B x
\end{lstlisting}
\end{definition}

\begin{definition} ($\mathrm{W}$-Introduction).
Elements of $\mathrm{W}_{(x : A)} B(x)$ are called
well-founded trees and created with single $\mathrm{sup}$ constructor:
$$
  \mathrm{sup} : \mathrm{W}_{(x: A)} B(x).
$$
\begin{lstlisting}
def sup$'$ (A: U) (B: A → U) (x: A) (f: B x → W' A B)
  : W' A B
 := sup A B x f
\end{lstlisting}
\end{definition}

\begin{theorem} (Induction Principle $\mathrm{ind_W}$).
The induction principle states that for any types $A: \mathcal{U}$
and $B: A \rightarrow \mathcal{U}$ and type family $C$ over $\mathrm{W}(A,B)$
and the function $g : G$, where
$$
  G = \prod_{x: A}\prod_{f: B(x) → \mathrm{W}(A,B)}\prod_{b: B(x)} C(f(b)) → C(\mathrm{sup}(x,f))
$$
there is a dependent function:
$$
   \mathrm{ind_W} : \prod_{C: \mathrm{W}(A,B) → \mathcal{U}}\prod_{g:G}\prod_{a: A}\prod_{f: B(a) → \mathrm{W}(A,B)}\prod_{b: B(a)}C(f(b)).
$$
\begin{lstlisting}
def W-ind (A : U) (B : A → U)
    (C : (W (x : A), B x) → U)
    (g : Π (x : A) (f : B x → (W (x : A), B x)),
           (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x)) (b : B a)
  : C (f b) := indᵂ A B C g (f b)
\end{lstlisting}
\end{theorem}

\begin{theorem}($\mathrm{ind_W}$ Computes).
The induction principle $\mathrm{ind^W}$ satisfies the equation:
$$
\mathrm{ind_W}\mbox{-}\beta : g(a,f,\lambda b.\mathrm{ind^W}(g,f(b))) 
$$
$$
  =_{def} \mathrm{ind_W}(g,\mathrm{sup}(a,f)).
$$
\begin{lstlisting}
def indᵂ-β (A : U) (B : A → U)
    (C : (W (x : A), B x) → U) (g : Π (x : A)
    (f : B x → (W (x : A), B x)), (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x))
   : PathP (<_> C (sup A B a f))
     (indᵂ A B C g (sup A B a f))
     (g a f (λ (b : B a), indᵂ A B C g (f b)))
  := <_> g a f (λ (b : B a), indᵂ A B C g (f b))
\end{lstlisting}
\end{theorem}

\subsection{M}

\newpage
\subsection{Empty}

The Empty type represents False-type logical $\mathbf{0}$, type without inhabitants, void or $\bot$ (Bottom).
As it has not inhabitants it lacks both constructors and eliminators, however, it has induction.

\begin{definition} (Formation).
Empty-type is defined as built-in $\mathbf{0}$-type:
$$
 \mathbf{0} : \mathcal{U}.
$$
\end{definition}

\begin{theorem} (Induction Principle $\mathrm{ind_0}$).
$\mathbf{0}$-type is satisfying the induction principle:
$$
  \mathrm{ind_0} : \prod_{C\ :\ \mathbf{0}\ \rightarrow\ \mathcal{U}} \prod_{z\ :\ \mathbf{0}} C(z).
$$
\begin{lstlisting}
def Empty-ind (C: 𝟎 → U) (z: 𝟎) : C z := ind₀ (C z) z
\end{lstlisting}
\end{theorem}

\begin{definition} (Negation or isEmpty).
For any type A negation of A is defined as arrow from A to $\mathbf{0}$:
$$
  \neg A := A \rightarrow \mathbf{0}.
$$
\begin{lstlisting}
def isEmpty (A: U): U := A → 𝟎
\end{lstlisting}
\end{definition}

The witness of $\neg A$ is obtained by assuming A and deriving a contradiction.
This techniques is called proof of negation and is applicable to any types in constrast
to proof by contradiction which implies $\neg\neg A \rightarrow A$ (double negation elimination) and is
applicable only to decidable types with $\neg A + A$ property.

\newpage
\subsection{Unit}
Unit type is the simplest type equipped with full set of MLTT inference rules. It contains single inhabitant $\star$ (star).

\newpage
\subsection{Bool}

\subsection{Maybe}

\subsection{Either}

\subsection{Nat}

\subsection{List}

\subsection{Vector}

\subsection{Stream}

\subsection{Interpreter}

\begin{thebibliography}{99}

\bibitem{Speight17}
Sam Speight,
\textit{Impredicative Encoding of Inductive Types in HoTT},
2017.
\url{https://github.com/sspeight93/Papers/}

\bibitem{Awodey17}
Steve Awodey,
\textit{Impredicative Encodings in HoTT},
2017.
\url{https://www.newton.ac.uk/files/seminar/20170711090010001-1009680.pdf}

\bibitem{Pfenning89}
Frank Pfenning and Christine Paulin-Mohring,
\textit{Inductively Defined Types in the Calculus of Constructions},
in \textit{Proc. 5th Int. Conf. Mathematical Foundations of Programming Semantics}, 1989, pp. 209–228.
\texttt{doi:10.1007/BFb0040259}

\bibitem{Dybjer94}
Peter Dybjer,
\textit{Inductive Families},
in \textit{Formal Aspects of Computing},
pp. 440–465, 1994.
\texttt{doi:10.1016/S0049-237X(08)71945-1}

\end{thebibliography}


\end{document}
