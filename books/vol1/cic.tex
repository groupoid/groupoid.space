\documentclass{article}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{url}
\usepackage{tikz-cd}
\usepackage[utf8]{inputenc}

\setlength{\parindent}{15pt}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\lstset{basicstyle=\footnotesize,inputencoding=utf8,
literate=
{ùüé}{{\ensuremath{\mathbf{0}}}}1
{ùüè}{{\ensuremath{\mathbf{1}}}}1
{‚âî}{{\ensuremath{\mathrm{:=}}}}1
{Œ±}{{\ensuremath{\mathrm{\alpha}}}}1
{·µÇ}{{\ensuremath{^W}}}1
{Œ≤}{{\ensuremath{\mathrm{\beta}}}}1
{Œ≥}{{\ensuremath{\mathrm{\gamma}}}}1
{Œ¥}{{\ensuremath{\mathrm{\delta}}}}1
{Œµ}{{\ensuremath{\mathrm{\varepsilon}}}}1
{Œ∂}{{\ensuremath{\mathrm{\zeta}}}}1
{Œ∑}{{\ensuremath{\mathrm{\eta}}}}1
{Œ∏}{{\ensuremath{\mathrm{\theta}}}}1
{Œπ}{{\ensuremath{\mathrm{\iota}}}}1
{Œ∫}{{\ensuremath{\mathrm{\kappa}}}}1
{Œª}{{\ensuremath{\mathrm{\lambda}}}}1
{Œº}{{\ensuremath{\mathrm{\mu}}}}1
{ŒΩ}{{\ensuremath{\mathrm{\nu}}}}1
{Œæ}{{\ensuremath{\mathrm{\xi}}}}1
{œÄ}{{\ensuremath{\mathrm{\mathnormal{\pi}}}}}1
{œÅ}{{\ensuremath{\mathrm{\rho}}}}1
{œÉ}{{\ensuremath{\mathrm{\sigma}}}}1
{œÑ}{{\ensuremath{\mathrm{\tau}}}}1
{œÜ}{{\ensuremath{\mathrm{\varphi}}}}1
{œá}{{\ensuremath{\mathrm{\chi}}}}1
{œà}{{\ensuremath{\mathrm{\psi}}}}1
{œâ}{{\ensuremath{\mathrm{\omega}}}}1
{Œ†}{{\ensuremath{\mathrm{\Pi}}}}1
{Œì}{{\ensuremath{\mathrm{\Gamma}}}}1
{Œî}{{\ensuremath{\mathrm{\Delta}}}}1
{Œò}{{\ensuremath{\mathrm{\Theta}}}}1
{Œõ}{{\ensuremath{\mathrm{\Lambda}}}}1
{Œ£}{{\ensuremath{\mathrm{\Sigma}}}}1
{Œ¶}{{\ensuremath{\mathrm{\Phi}}}}1
{Œû}{{\ensuremath{\mathrm{\Xi}}}}1
{Œ®}{{\ensuremath{\mathrm{\Psi}}}}1
{Œ©}{{\ensuremath{\mathrm{\Omega}}}}1
{‚Ñµ}{{\ensuremath{\aleph}}}1
{‚â§}{{\ensuremath{\leq}}}1
{‚â•}{{\ensuremath{\geq}}}1
{‚â†}{{\ensuremath{\neq}}}1
{‚âà}{{\ensuremath{\approx}}}1
{‚â°}{{\ensuremath{\equiv}}}1
{‚âÉ}{{\ensuremath{\simeq}}}1
{‚â§}{{\ensuremath{\leq}}}1
{‚â•}{{\ensuremath{\geq}}}1
{‚àÇ}{{\ensuremath{\partial}}}1
{‚àÜ}{{\ensuremath{\triangle}}}1 % or \laplace?
{‚à´}{{\ensuremath{\int}}}1
{‚àë}{{\ensuremath{\mathrm{\Sigma}}}}1
{‚Üí}{{\ensuremath{\rightarrow}}}1
{‚ä•}{{\ensuremath{\perp}}}1
{‚àû}{{\ensuremath{\infty}}}1
{‚àÇ}{{\ensuremath{\partial}}}1
{‚àì}{{\ensuremath{\mp}}}1
{¬±}{{\ensuremath{\pm}}}1
{√ó}{{\ensuremath{\times}}}1
{‚äï}{{\ensuremath{\oplus}}}1
{‚äó}{{\ensuremath{\otimes}}}1
{‚äû}{{\ensuremath{\boxplus}}}1
{‚àá}{{\ensuremath{\nabla}}}1
{‚àö}{{\ensuremath{\sqrt}}}1
{‚¨ù}{{\ensuremath{\cdot}}}1
{‚Ä¢}{{\ensuremath{\cdot}}}1
{‚àò}{{\ensuremath{\circ}}}1
{‚Åª}{{\ensuremath{^{-}}}}1
{‚ñ∏}{{\ensuremath{\blacktriangleright}}}1
{‚àß}{{\ensuremath{\wedge}}}1
{‚à®}{{\ensuremath{\vee}}}1
{¬¨}{{\ensuremath{\neg}}}1
{‚ä¢}{{\ensuremath{\vdash}}}1
{‚ü®}{{\ensuremath{\langle}}}1
{‚ü©}{{\ensuremath{\rangle}}}1
{‚Ü¶}{{\ensuremath{\mapsto}}}1
{‚Üí}{{\ensuremath{\rightarrow}}}1
{‚Üî}{{\ensuremath{\leftrightarrow}}}1
{‚áí}{{\ensuremath{\Rightarrow}}}1
{‚üπ}{{\ensuremath{\Longrightarrow}}}1
{‚áê}{{\ensuremath{\Leftarrow}}}1
{‚ü∏}{{\ensuremath{\Longleftarrow}}}1
{‚à©}{{\ensuremath{\cap}}}1
{‚à™}{{\ensuremath{\cup}}}1
{‚äÇ}{{\ensuremath{\subseteq}}}1
{‚äÜ}{{\ensuremath{\subseteq}}}1
{‚äÑ}{{\ensuremath{\nsubseteq}}}1
{‚äà}{{\ensuremath{\nsubseteq}}}1
{‚äÉ}{{\ensuremath{\supseteq}}}1
{‚äá}{{\ensuremath{\supseteq}}}1
{‚äÖ}{{\ensuremath{\nsupseteq}}}1
{‚äâ}{{\ensuremath{\nsupseteq}}}1
{‚àà}{{\ensuremath{\in}}}1
{‚àâ}{{\ensuremath{\notin}}}1
{‚àã}{{\ensuremath{\ni}}}1
{‚àå}{{\ensuremath{\notni}}}1
{‚àÖ}{{\ensuremath{\emptyset}}}1
{‚àñ}{{\ensuremath{\setminus}}}1
{‚Ä†}{{\ensuremath{\dag}}}1
{‚Ñï}{{\ensuremath{\mathbb{N}}}}1
{‚Ñ§}{{\ensuremath{\mathbb{Z}}}}1
{‚Ñù}{{\ensuremath{\mathbb{R}}}}1
{‚Ñö}{{\ensuremath{\mathbb{Q}}}}1
{‚ÑÇ}{{\ensuremath{\mathbb{C}}}}1
{‚åû}{{\ensuremath{\llcorner}}}1
{‚åü}{{\ensuremath{\lrcorner}}}1
{‚¶É}{{\ensuremath{ \{\!| }}}1
{‚¶Ñ}{{\ensuremath{ |\!\} }}}1
{‚ÇÅ}{{\ensuremath{_1}}}1
{‚ÇÇ}{{\ensuremath{_2}}}1
{‚ÇÉ}{{\ensuremath{_3}}}1
{‚ÇÑ}{{\ensuremath{_4}}}1
{‚ÇÖ}{{\ensuremath{_5}}}1
{‚ÇÜ}{{\ensuremath{_6}}}1
{‚Çá}{{\ensuremath{_7}}}1
{‚Çà}{{\ensuremath{_8}}}1
{‚Çâ}{{\ensuremath{_9}}}1
{‚ÇÄ}{{\ensuremath{_0}}}1
{¬π}{{\ensuremath{^1}}}1
{‚Çô}{{\ensuremath{_n}}}1
{‚Çò}{{\ensuremath{_m}}}1
{‚Üë}{{\ensuremath{\uparrow}}}1
{‚Üì}{{\ensuremath{\downarrow}}}1
{‚ñ∏}{{\ensuremath{\triangleright}}}1
{‚àÄ}{{\ensuremath{\forall}}}1
{‚àÉ}{{\ensuremath{\exists}}}1
{Œª}{{\ensuremath{\mathrm{\lambda}}}}1
{=}{{\ensuremath{=}}}1
{<}{{\ensuremath{\langle}}}1
{>}{{\ensuremath{\rangle}}}1
{(}{(}1
{(}{(}1
{‚Äñ}{‚Äñ}1
{+}{{+}}1
{*}{{*}}1,
}

\begin{document}

\title{Issue II: Inductive Types}
\author{Maksym Sokhatskyi $^1$}
\date{ $^1$ National Technical University of Ukraine \\
       \small Igor Sikorsky Kyiv Polytechnical Institute \\
       \today }

\maketitle

\begin{abstract}

Impredicative Encoding of Inductive Types in HoTT.
\\
\\
{\bf Keywords}: Formal Methods, Type Theory, Programming Languages,
          Theoretical Computer Science, Applied Mathematics,
          Cubical Type Theory, Martin-L√∂f Type Theory
\end{abstract}

\ifincludeTOC
  \tableofcontents
\fi

\newpage
\section{Inductive Encodings}

\subsection{Church Encoding}

You know Church encoding which also has its dependent alanolgue in CoC, however
in Coq it is imposible to detive Inductive Principle as type system lacks fixpoint
and functional extensionality. The example of working compiler of PTS languages are Om and Morte.
Assume we have Church encoded NAT:

\begin{lstlisting}[mathescape=true]
nat = (X:U) -> (X -> X) -> X -> X
\end{lstlisting}

where first parameter $(X -> X)$ is a $succ$, the second parameter $X$ is $zero$,
and the result of encoding is landed in X. Even if we encode the parameter

\begin{lstlisting}[mathescape=true]
list (A: U) = (X:U) -> X -> (A -> X) -> X
\end{lstlisting}

and paremeter A let's say live in 42 universe and X live in 2 universe, then by
the signature of encoding the term will be landed in X, thus 2 universe. In other words
such dependency is called impredicative displaying that landed term is not a predicate over parameters.
This means that Church encoding is incompatible with predicative type checkers with predicative
of predicative-cumulative hierarchies.


\subsection{Scott Encoding}

\subsection{Parigot Encoding}

\subsection{CPS Encoding}

\subsection{Interaction Networks Encoding}

\subsection{Impredicative Encoding}

In HoTT n-types is encoded as n-groupoids, thus we need to add a predicate in which n-type
we would like to land the encoding:

\begin{lstlisting}[mathescape=true]
NAT (A: U) = (X:U) -> isSet X -> X -> (A -> X) -> X
\end{lstlisting}

Here we added isSet predicate. With this motto we can implement propositional
truncation by landing term in isProp or even HIT by langing in isGroupoid:

\begin{lstlisting}[mathescape=true]
TRUN (A:U) type = (X: U) -> isProp X -> (A -> X) -> X
S1 = (X:U) -> isGroupoid X -> ((x:X) -> Path X x x) -> X
MONOPLE (A:U) = (X:U) -> isSet X -> (A -> X) -> X
NAT = (X:U) -> isSet X -> X -> (A -> X) -> X
\end{lstlisting}

The main publication on this topic could be found at \cite{Awodey17} and \cite{Speight17}.

\subsubsection*{The Unit Example}

Here we have the implementation of Unit impredicative encoding in HoTT.

\begin{lstlisting}[mathescape=true]
upPath     (X Y:U)(f:X->Y)(a:X->X): X -> Y = o X X Y f a
downPath   (X Y:U)(f:X->Y)(b:Y->Y): X -> Y = o X Y Y b f
naturality (X Y:U)(f:X->Y)(a:X->X)(b:Y->Y): U
  = Path (X->Y)(upPath X Y f a)(downPath X Y f b)

unitEnc': U = (X: U) -> isSet X -> X -> X
isUnitEnc (one: unitEnc'): U
  = (X Y:U)(x:isSet X)(y:isSet Y)(f:X->Y) ->
    naturality X Y f (one X x)(one Y y)

unitEnc: U = (x: unitEnc') * isUnitEnc x
unitEncStar: unitEnc = (\(X:U)(_:isSet X) ->
  idfun X,\(X Y: U)(_:isSet X)(_:isSet Y)->refl(X->Y))
unitEncRec  (C: U) (s: isSet C) (c: C): unitEnc -> C
  = \(z: unitEnc) -> z.1 C s c
unitEncBeta (C: U) (s: isSet C) (c: C)
  : Path C (unitEncRec C s c unitEncStar) c = refl C c
unitEncEta (z: unitEnc): Path unitEnc unitEncStar z = undefined
unitEncInd (P: unitEnc -> U) (a: unitEnc): P unitEncStar -> P a
  = subst unitEnc P unitEncStar a (unitEncEta a)
unitEncCondition (n: unitEnc'): isProp (isUnitEnc n)
  =  \ (f g: isUnitEnc n) ->
     <h> \ (x y: U) -> \ (X: isSet x) -> \ (Y: isSet y)
  -> \ (F: x -> y) -> <i> \ (R: x) -> Y (F (n x X R)) (n y Y (F R))
       (<j> f x y X Y F @ j R) (<j> g x y X Y F @ j R) @ h @ i
\end{lstlisting}

\subsection{Lambek Encoding: Homotopy Initial Algebras}

\newpage
\section{Inductive Types}

\subsection{W}

Well-founded trees without mutual recursion represented as $\mathrm{W}$-types.

\begin{definition} ($\mathrm{W}$-Formation).
For $A : \mathcal{U}$ and $B : A \rightarrow \mathcal{U}$, type $\mathrm{W}$
is defined as $\mathrm{W}(A,B) : \mathcal{U}$ or
$$
   \mathrm{W}_{(x : A)} B(x) : \mathcal{U}.
$$
\begin{lstlisting}[mathescape=true]
def W$'$ (A : U) (B : A ‚Üí U) : U := W (x : A), B x
\end{lstlisting}
\end{definition}

\begin{definition} ($\mathrm{W}$-Introduction).
Elements of $\mathrm{W}_{(x : A)} B(x)$ are called
well-founded trees and created with single $\mathrm{sup}$ constructor:
$$
  \mathrm{sup} : \mathrm{W}_{(x: A)} B(x).
$$
\begin{lstlisting}
def sup$'$ (A: U) (B: A ‚Üí U) (x: A) (f: B x ‚Üí W' A B)
  : W' A B
 := sup A B x f
\end{lstlisting}
\end{definition}

\begin{theorem} (Induction Principle $\mathrm{ind_W}$).
The induction principle states that for any types $A: \mathcal{U}$
and $B: A \rightarrow \mathcal{U}$ and type family $C$ over $\mathrm{W}(A,B)$
and the function $g : G$, where
$$
  G = \prod_{x: A}\prod_{f: B(x) ‚Üí \mathrm{W}(A,B)}\prod_{b: B(x)} C(f(b)) ‚Üí C(\mathrm{sup}(x,f))
$$
there is a dependent function:
$$
   \mathrm{ind_W} : \prod_{C: \mathrm{W}(A,B) ‚Üí \mathcal{U}}\prod_{g:G}\prod_{a: A}\prod_{f: B(a) ‚Üí \mathrm{W}(A,B)}\prod_{b: B(a)}C(f(b)).
$$
\begin{lstlisting}
def W-ind (A : U) (B : A ‚Üí U)
    (C : (W (x : A), B x) ‚Üí U)
    (g : Œ† (x : A) (f : B x ‚Üí (W (x : A), B x)),
           (Œ† (b : B x), C (f b)) ‚Üí C (sup A B x f))
    (a : A) (f : B a ‚Üí (W (x : A), B x)) (b : B a)
  : C (f b) := ind·µÇ A B C g (f b)
\end{lstlisting}
\end{theorem}

\begin{theorem}($\mathrm{ind_W}$ Computes).
The induction principle $\mathrm{ind^W}$ satisfies the equation:
$$
\mathrm{ind_W}\mbox{-}\beta : g(a,f,\lambda b.\mathrm{ind^W}(g,f(b))) 
$$
$$
  =_{def} \mathrm{ind_W}(g,\mathrm{sup}(a,f)).
$$
\begin{lstlisting}
def ind·µÇ-Œ≤ (A : U) (B : A ‚Üí U)
    (C : (W (x : A), B x) ‚Üí U) (g : Œ† (x : A)
    (f : B x ‚Üí (W (x : A), B x)), (Œ† (b : B x), C (f b)) ‚Üí C (sup A B x f))
    (a : A) (f : B a ‚Üí (W (x : A), B x))
   : PathP (<_> C (sup A B a f))
     (ind·µÇ A B C g (sup A B a f))
     (g a f (Œª (b : B a), ind·µÇ A B C g (f b)))
  := <_> g a f (Œª (b : B a), ind·µÇ A B C g (f b))
\end{lstlisting}
\end{theorem}

\subsection{M}

\newpage
\subsection{Empty}

The Empty type represents False-type logical $\mathbf{0}$, type without inhabitants, void or $\bot$ (Bottom).
As it has not inhabitants it lacks both constructors and eliminators, however, it has induction.

\begin{definition} (Formation).
Empty-type is defined as built-in $\mathbf{0}$-type:
$$
 \mathbf{0} : \mathcal{U}.
$$
\end{definition}

\begin{theorem} (Induction Principle $\mathrm{ind_0}$).
$\mathbf{0}$-type is satisfying the induction principle:
$$
  \mathrm{ind_0} : \prod_{C\ :\ \mathbf{0}\ \rightarrow\ \mathcal{U}} \prod_{z\ :\ \mathbf{0}} C(z).
$$
\begin{lstlisting}
def Empty-ind (C: ùüé ‚Üí U) (z: ùüé) : C z := ind‚ÇÄ (C z) z
\end{lstlisting}
\end{theorem}

\begin{definition} (Negation or isEmpty).
For any type A negation of A is defined as arrow from A to $\mathbf{0}$:
$$
  \neg A := A \rightarrow \mathbf{0}.
$$
\begin{lstlisting}
def isEmpty (A: U): U := A ‚Üí ùüé
\end{lstlisting}
\end{definition}

The witness of $\neg A$ is obtained by assuming A and deriving a contradiction.
This techniques is called proof of negation and is applicable to any types in constrast
to proof by contradiction which implies $\neg\neg A \rightarrow A$ (double negation elimination) and is
applicable only to decidable types with $\neg A + A$ property.

\newpage
\subsection{Unit}
Unit type is the simplest type equipped with full set of MLTT inference rules. It contains single inhabitant $\star$ (star).

\newpage
\subsection{Bool}

\subsection{Maybe}

\subsection{Either}

\subsection{Nat}

\subsection{List}

\subsection{Vector}

\subsection{Stream}

\subsection{Interpreter}

\newpage
\begin{thebibliography}{99}

% CIC

\bibitem{Pfenning89}
Frank Pfenning and Christine Paulin-Mohring,
\textit{Inductively Defined Types in the Calculus of Constructions},
in \textit{Proc. 5th Int. Conf. Mathematical Foundations of Programming Semantics}, 1989, pp. 209‚Äì228.
\textit{doi:10.1007/BFb0040259}

\bibitem{PaulinMohring93}
Christine Paulin-Mohring,
\textit{Inductive Definitions in the System Coq: Rules and Properties},
in \textit{Typed Lambda Calculi and Applications (TLCA)}, 1993, pp. 328‚Äì345.
\textit{doi:10.1007/BFb0037116}

\bibitem{Paulin94}
Christine Paulin-Mohring,
\textit{Defining Inductive Sets in Type Theory},
in: G. Huet and G. Plotkin (eds), \textit{Logical Environments}, Cambridge University Press, 1994, pp. 249‚Äì272.

\bibitem{dybjer1991}
Peter Dybjer,
\textit{Inductive Sets and Families in Martin-L√∂f's Type Theory and Their Set-Theoretic Semantics},
\textit{Lecture Notes in Computer Science}, 530, 1991, pp. 280‚Äì306.
\textit{doi:10.1007/BFb0014059}

\bibitem{Dybjer94}
Peter Dybjer,
\textit{Inductive Families},
\textit{Formal Aspects of Computing}, 6(4), 1994, pp. 440‚Äì465.
\textit{doi:10.1007/BF01211308}

\bibitem{dybjer1997}
Peter Dybjer,
\textit{Representing inductively defined sets by wellorderings in Martin-L√∂f‚Äôs type theory},
\textit{Theoretical Computer Science}, 176(1‚Äì2), 1997, pp. 329‚Äì335.
\textit{doi:10.1016/S0304-3975(96)00145-4}

\bibitem{hofmann1994}
Martin Hofmann,
\textit{Extensional Constructs in Intensional Type Theory},
PhD thesis, University of Edinburgh, 1995.
\url{https://www2.informatik.uni-freiburg.de/~mhofmann/phdthesis.pdf}

\bibitem{hofmann1995}
Martin Hofmann,
\textit{Syntax and Semantics of Dependent Types},
in: \textit{Semantics and Logics of Computation}, 1995, pp. 79‚Äì130.

\bibitem{Newstead2018}
Newstead, C. (2018).
\textit{Algebraic Models of Dependent Type Theory}.
PhD thesis, Carnegie Mellon University.
Available at \url{https://arxiv.org/abs/2103.06155}.

% HoTT W-Types

\bibitem{Speight17}
Sam Speight,
\textit{Impredicative Encoding of Inductive Types in HoTT},
2017.
\url{https://github.com/sspeight93/Papers/}

\bibitem{Awodey17}
Steve Awodey,
\textit{Impredicative Encodings in HoTT},
2017.
\url{https://www.newton.ac.uk/files/seminar/20170711090010001-1009680.pdf}

\bibitem{awodey2010typetheoryhomotopy}
Steve Awodey.
\textit{Type theory and homotopy},
2010.
\url{https://arxiv.org/abs/1010.1810}

\bibitem{altenkirch2022indexed}
Thorsten Altenkirch, Neil Ghani, Peter Hancock, Conor McBride, and Peter Morris.
\textit{Indexed Containers}.
\textit{Logical Methods in Computer Science}, 18(2), 2022, pp. 15:1--15:37.
\url{https://lmcs.episciences.org/}

\bibitem{fiore2022qit}
Marcelo P. Fiore, Andrew M. Pitts, and S. C. Steenkamp.
\textit{Quotients, Inductive Types, \& Quotient Inductive Types}.
University of Cambridge, 2022.
\url{https://arxiv.org/pdf/1705.07088}

\bibitem{altenkirch2012containers}
Thorsten Altenkirch, Neil Ghani, and Peter Morris.
\textit{Containers‚ÄîConstructively},
2012.
\url{https://arxiv.org/pdf/1201.3898}

\bibitem{altenkirch2013containers2}
Thorsten Altenkirch, Conor McBride, and James Chapman.
\textit{Towards Observational Type Theory},
2013.
\url{https://arxiv.org/pdf/1307.2765}

\bibitem{dybjer1997}
Peter Dybjer,
\textit{Representing inductively defined sets by wellorderings in Martin-L√∂f‚Äôs type theory},
\textit{Theoretical Computer Science}, 176(1‚Äì2), 1997, pp. 329‚Äì335.
\textit{doi:10.1016/S0304-3975(96)00145-4}

\bibitem{moerdijk2000}
Ieke Moerdijk and Erik Palmgren,
\textit{Wellfounded trees in categories},
\textit{Annals of Pure and Applied Logic}, 104(1‚Äì3), 2000, pp. 189‚Äì218.
\textit{doi:10.1016/S0168-0072(00)00012-9}

\bibitem{abbott2005containers}
Michael Abbott, Thorsten Altenkirch, and Neil Ghani,
\textit{Containers: Constructing strictly positive types},
\textit{Theoretical Computer Science}, 342(1), 2005, pp. 3‚Äì27.
\textit{doi:10.1016/j.tcs.2005.06.002}

\bibitem{berg2008wtypes}
Benno van den Berg and Ieke Moerdijk,
\textit{W-types in sheaves},
2008.
\url{https://arxiv.org/abs/0810.2398}

\bibitem{gambino2004}
Nicola Gambino and Martin Hyland,
\textit{Wellfounded Trees and Dependent Polynomial Functors},
in \textit{TYPES 2003}, LNCS 3085, Springer, 2004, pp. 210‚Äì225.
\textit{doi:10.1007/978-3-540-24849-1\_14}

\bibitem{abbott2004nested}
Michael Abbott, Thorsten Altenkirch, and Neil Ghani,
\textit{Representing Nested Inductive Types using W-types},
in \textit{ICALP 2004}, LNCS 3142, Springer, 2004, pp. 124‚Äì135.
\textit{doi:10.1007/978-3-540-27836-8\_8}

\bibitem{awodey2012lics}
Steve Awodey, Nicola Gambino, and Kristina Sojakova,
\textit{Inductive types in homotopy type theory},
\textit{LICS 2012}, pp. 95‚Äì104.
\textit{doi:10.1109/LICS.2012.21},
\url{https://arxiv.org/abs/1201.3898}

\bibitem{berg2015wtypeshott}
Benno van den Berg and Ieke Moerdijk,
\textit{W-types in Homotopy Type Theory},
\textit{Mathematical Structures in Computer Science}, 25(5), 2015, pp. 1100‚Äì1115.
\textit{doi:10.1017/S0960129514000516},
\url{https://arxiv.org/abs/1307.2765}

\bibitem{sojakova2015}
Kristina Sojakova,
\textit{Higher Inductive Types as Homotopy-Initial Algebras},
\textit{ACM SIGPLAN Notices}, 50(1), 2015, pp. 31‚Äì42.
\textit{doi:10.1145/2775051.2676983},
\url{https://arxiv.org/abs/1402.0761}

\bibitem{awodey2017jacm}
Steve Awodey, Nicola Gambino, and Kristina Sojakova,
\textit{Homotopy-initial algebras in type theory},
\textit{Journal of the ACM}, 63(6), 2017, Article 45.
\textit{doi:10.1145/3006383},
\url{https://arxiv.org/abs/1504.05531}

\bibitem{sattler2015}
Christian Sattler,
\textit{On relating indexed W-types with ordinary ones},
in \textit{TYPES 2015}, pp. 71‚Äì72.
\url{https://types2015.inria.fr/slides/sattler.pdf}

\bibitem{martinlof1982}
Per Martin-L√∂f,
\textit{Constructive Mathematics and Computer Programming},
in: Proc. 6th Int. Congress of Logic, Methodology and Philosophy of Science, 1979. \textit{Studies in Logic and the Foundations of Mathematics} 104 (1982), pp. 153‚Äì175.
\textit{doi:10.1016/S0049-237X(09)70189-2}

\bibitem{martinlof1984}
Per Martin-L√∂f (notes by Giovanni Sambin),
\textit{Intuitionistic type theory}, Lecture notes Padua 1984, Bibliopolis, Napoli (1984).

\bibitem{hugunin2021}
Jasper Hugunin,
\textit{Why Not W?},
\textit{LIPIcs}, 188 (TYPES 2020), 2021.
\textit{doi:10.4230/LIPIcs.TYPES.2020.8}

\bibitem{danielsson2012}
Nils Anders Danielsson,
\textit{Positive h-levels are closed under W},
2012.
\url{https://www.cse.chalmers.se/~nad/listings/w-level/WLevel.html}

\bibitem{huguninIWTypes}
Jasper Hugunin,
\textit{IWTypes Repository}.
\url{https://github.com/jashug/IWTypes}

\end{thebibliography}

\end{document}
