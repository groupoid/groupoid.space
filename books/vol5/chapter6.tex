\chapter{Бібліотека вищих мов}
\epigraph{Присвячується вчителям американської школи формальної філософії та авторам HoTT}{}
У попередньому п'ятому розділі дається опис гомотопічної мови програмування,
реалізація якої вперше була представлена CCHM в 2017 році, та для якої написана
гомотопічна базова бібліотека представлена у цьому та наступному розділах.

\section*{Вступне слово}

\section{Інтерналізація теорії типів}
Кожна мовна імплементація повинна бути протестована. Один з можливих сценаріїв
тестування типових верифікаторів це пряме вбудовування в модель теорії типів
виконуючого верифікатора. Так як всі типи в теорії формулюються за допомогою п'яти
правил: формації, інтро, елімінації, обчисленя, рівності; ми зконструювали
номінальні типи-синоніми для виконуючого верифікатора та довели,
що це є реалізацією MLTT. Це може розглядатися як універсальний
тест для імплементації типового верифікатора, позаяк компенсаця
інтро правила та правила елімінатора пов'язані в правилі обчислення
та рівності (бета та ета редукціях). Таким чином, доводжуючи реалізацію MLTT,
ми доводимо властивості самого виконуючого верифікатора.
MLTT-75 розкладається у спектр $\Pi$, $\Sigma$, та $=$ типів.
У цьому розділі ми побудуємо мінімальну кубічну систему необхідну
для вбудовування MLTT-75 у саму себе.

Більш формально, кубічне MLTT вбудовування конструктивно виражає
J елімінатор типу-рівності та його рівняння — правило обчислення,
що було неможливо до кубічної інтерпретації. Також цей розділ
відкриває серію параграфів присвячених формалізації основ математики у кубічній теорії типів,
MLTT моделюванню та кубічної верифікації. Так як не всі можуть бути знайомі з теорією типів,
цей розділ також містить їх інтерпретації з точки зору різних розділів математики.

Додамо, що це тільки вхід в техніку прямого вбудовування і після MLTT моделювання,
ми можем піднятися вище — до вбудовування в систему індуктивних типів, і далі,
до вбудовування CW-комплексів як зклейок вищих індуктивних типів.

\subsubsection{Теорія типів}
Теорія типів --- це універсальна мова програмування чистої
математики (для доведення теорем), яка може містити довільну
кількість консистентних аксіом, впорядкованих у вигляді псевдо-ізоморфізмів:
1) сигнатури типу або формації;
2) функції encode, способи конструювання елементів типу або конструкція;
3) функції decode, залежні елімінатори принципу індукції типу або елімінація;
4) рівняння бета правила або обчислювальності;
5) рівняння ета правила або унікальності.
Таке визначення було дано Мартіном-Льофом,
від чого теорія типів носить його ім'я MLTT.

Головна мотивація гомотопічної теорії типів — надати обчислювальну
семантику гомотопічним типам та CW-комплексам. Головна ідея
гомотопічної теорії [1] полягає в поєднанні просторів функцій,
просторів контекстів  і просторів шляхів  таким чином, що вони
утворюють фібраційну рівність яка збігається (доводиться в самій
теорії) з простором шляхів.

Завдяки відсутності ета-правила у рівності, не кожні два
доведення одного простору шляхів дорівнюють між собою, отже
простір шляхів утворює багатовимірну структуру інфініті-групоїда.

Кожен тип в MLTT описується за допомогою пяти правил:
1) правила формації або сигнатура типу;
2) множина конструкторів за допомогою яких рекурсивно будують елементи типу певної сигнатури;
3) залежний елімінатор принципу індукції для цього типу;
4) бета-рівняння або правило обчислення;
5) ета-рівняння або принцип унікальності.

\begin{table}[ht]
  \caption{Інтерпретації теорії типів які відповідають математичним теоріям}
 \begin{tabular}{lcccc}
    \hline
       \textbf{Теорія типів} & \textbf{Логіка} & \textbf{Теорія категорій} & \textbf{Теорія гомотопій} \\
    \hline
       A тип & клас & об'єкт & простір \\
       isProp A & твердження & (-1)-обрізаний об'єкт & простір \\
       a:A програма & доведення & узагальнений елемени & точка \\
       $B(x)$ & предикат & індексований об'єкт & розшарування \\
       $b(x) : B(x)$ & умовне доведення & індексовані елементи & секції\\
       $\emptyset$ & $\bot$ неправда & термінальний об'єкт & пустий простір \\
       $\mathbf{1}$ & $\top$ істина & ініціальний об'єкт & сінглтон \\
       $A + B$ & $A\vee B$ діз'юнкція & кодобуток & простір кодобутків \\
       $A\times B$ & $A\wedge B$ кон'юнкція & добуток & простір добутків \\
       $A\to B$ & $A\Rightarrow B$ & внутрішній Hom & простір функції \\
       $\sum{x:A},B(x)$ & $\exists_{x:A}B(x)$ & залежна сума & повний простір \\
       $\prod{x:A},B(x)$ & $\forall_{x:A}B(x)$ & залежний добуток & простір секцій\\
       $\mathbf{Path}_{A}$ & еквівалентність $=_A$ & об'єкт типу шляхів & тип шляхів $A^I$ \\
       факторизація & клас еквівалентн. & фактор & фактор \\
       W-тип & індукція & коліміт & комплекс\\
       тип типів & всесвіт & класифікаторо об'єктів & всесвіт \\
       квантова схема & граф доведення & струнна діаграма & \\
      \hline
  \end{tabular}
\end{table}

Найбільш цікаві --- Id типи, які були додані в теорію типів в 1984 році
\footnote{P. Martin-Löf, G. Sambin. Intuitionistic type theory. 1984.}
у той час як оригінальна теорія була представлена
\footnote{P. Martin-Löf, G. Sambin. The Theory of Types. 1972.} в 1972 році.
Предикативна ієрархія всесвітів була додана \footnote{P. Martin-Löf. An
intuitionistic theory of types: predicative part. 1975.} в 1975.

MLTT з Id типами зберігає властивість стягуваного простору усіх
доведень (uniquness of identity proofs, UIP), або ета-правило Id типа,
але HoTT відхиляє UIP --- ета правило не виконується, а натомість
вводиться простір шляхів --- Path тип \footnote{M. Hofmann, T. Streicher.
The groupoid interpretation of type theory. 1996.} --- так
звана $\infty$-Groupoid інтерпретація.

Простори шляхів є ключовими для доведення властивостей обчислюваності
та унікальності (бета та ета правил). Також в цій роботі ми покажемо
мінімальну систему де можна довести всі всластивості MLTT теорії типів.

\newpage
\subsection{Cтруктура бібліотеки}

\subsubsection{Основи}
Перша частина базової бібліотеки --- модальні унівалентні MLTT основи,
що розділені на три групи. Перша група містить класичні типи MLTT
системи описані Мартіном-Льофом, які присутні у мовах $\textcolor{magenta}{Per}$
та $\textcolor{magenta}{Anders}$. Друга група містить унівалентні ідентифікаційні
системи мови $\textcolor{magenta}{Anders}$. Третя група містить модальності мови
$\textcolor{magenta}{Anders}$, які використовуються в диференціальній геометріїї
та в теорії гомотопій. Основи пропонують фундаментальний базис який
використовується для формалізації сучасної математики в таких системах
доведення теорем як: Coq, Agda, Lean.
\\
\\
\noindent
--- Фібраційні \\
--- Унівалентні \\
--- Модальні

\subsubsection{Математики}

Друга частина базової бібліотеки $\textcolor{magenta}{Anders}$ містить формалізації математичних
теорій з різних галузей математики: аналіз, алгебра, геометрія,
теорія гомотопій, теорія категорій.

Слухачам курсу (10) пропонується застосувати теорію типів для
доведення початкового але нетривіального результу, який є
відкритою проблемою в теорії типів для однєї із математик,
що є курсами на кафедрі чистої математики (КМ-111):\\
\\
\noindent
--- Функціональний аналіз \\
--- Гомологічна алгебра \\
--- Диференціальна геометрія \\
--- Теорія гомотопій \\
--- Теорія категорій \\

\newpage
\subsubsection{Програми}

Третя частини базової бібліотеки, присутня у мовах $\textcolor{magenta}{Anders}$ та $\textcolor{magenta}{Per}$,
присвячена прикладам з промислового програмування в області автоматизації
підприємств та інформаційних технологій, а саме для специфікації програмних інтерфейсів.
\\
\\
\noindent --- Формалізація двонаправленого тракту \\
--- Формалізація графічного веб інтерфейсу \\
--- Формалізація бази даних з єдиним простором ключів \\
--- Формалізація реляційної бази даних \\
--- Формалізація системи управління процесами \\

\subsubsection{Філософії}

З сучасників формальною філософією в HoTT загалом займається Девід Корфілд,
а формалізацією свідомості як окремий предмет вивчають Хенк Барендрегт та Горо Като.
Формальна теорія природніх мов теж формалізується за допомогою MLTT,
а основні теореми доводять в HoTT. В четвертій частині базової
бібліотеки $\textcolor{magenta}{Anders}$ наводяться приклади програм, які
маніфестують висловлювання і теореми з формальної філософії про пустотність
всіх феноменів та синтаксис, морфологію і семантику природньої української мови.
\\
\\
\noindent
--- Формалізація Мадг'яміки \\
--- Формалізація української мови в кванторах
\newpage
\subsection{Інтерпретації теорії типів}
Використовуючи теорію типів як мову, можливо закодувати на ній як
різні математичні теорії, так і використовувати ці математичні
теорії як взаємозамінювані фундаменти математики.
Така взаємозамінюваність, яка показана в таблиці 6.1 говорить про те,
що і теорія типів і математичні теорії є інтерпретаціями однієї конструкції.

Тут ми будемо говорити про наступні інтерпретації:
1) теоертико-типову;
2) категоріальну;
3) теоретико-множинну;
4) гомотопічну;
5) фібраційну або геометричну.

Реалізовуючи компаративістику інтерпретацій розглянемо на прикладах
перші та основні типи теоретико-типової MLTT системи ($\Pi$, $\Sigma$, $Id$) зразу
з точки зору декількох інтерпретацій:
1) логічної або осучасненої теоретико-типової інтерпретації, похідних системах від MLTT;
2) категоріальної або топосо-теоретичної фібраційної геометричної інтерпретації;
3) гомотопічної або кубічної інтерпретації.

\subsubsection{Теоретико-множинна інтерпертація}
Теоретико-множинна інтерпретація не зображена в таблиці 6.1, тому
що є домінуючою робочою інтерпретацією фундамента сучасної математики.

Теортико-множинна інтерпретація може замістити логіку перших порядків, але не може
безпосередньо оперувати вищими рівностями. Індуктивні типи в терію множин повинні
вбудовуватися додатково, а саме визначення множини моделюється в гомотопічній
теорії як n-тип. Наявність принципу унікальності
доведень рівності (UIP) в типовій системі вже означає теоретико-множинну інтерпретацію.
Не зважаючи на це теореми теорії множин без зусиль вбудовуються
в будь-яку з інтерпретацій.

\subsubsection{Логічна або теоретико-типова інтерпретація}
Виходячи з засад MLTT теорії типів, кожен тип або сигнатура визначається
п'ятьома правилами:
1) формації або типової сигнатури;
2) представлення або інтро-правила;
3) елімінації або загальний принцип залежної індукції;
4) правила обчислення або бета-правила;
5) принципу унікальності або ета-правила.

Формальна репрезентація всіх правила MLTT теорії буде надана в кінці цього розділу.
Є загальновідомим той факт, що класичні логіки можуть бути вбудовані в інтуіціоністичну
пропозиційну логіку (intuitionistic propositional logic, IPL), яка безпосередньо
вбудована та є природнім (інтуіціоністичним) продовженням MLTT.

Хоча класично-логічна інтерпретація відрізняється від модернової теоретико-типової
інтерпретації, вони можуть бути об'єднані як загальні логічні, тому що всі є
формами механізовуваних мов програмування.

\subsubsection{Категоріальна або топосо-теоритична інтерпретація}
Категоріальна інтерпретація розповідає про теорію типів як внутрішню мову
декартово-замкнених категорій та їх функторів. Головним результатом
категорної інтерпретації можна назвати спряженість функторів $\Pi$ та $\Sigma$,
які є носіями відповідних MLTT типів та формують собою локальну
декартово-замкнену категорію, яка буде надана у розділі 7.

Топосо-теоретична інтерпретація з досніповими моделями теорії типів Кокана,
де фібрації конструюються як функтори, є сучасним математичним апаратом
аналізу не тільки залежних але і кубічних теорій.

\subsubsection{Гомотопічна інтерпретація}
В класичних системах MLTT-72, MLTT-75 та MLTT-80 правило унікальносьі для
Id типу виконується строго. Однак в гомотопічній інтерпретації просторів шляхів
нам потрібно виключити це правило, аби надати багатовимірну глибину поняття рівності.
Групоїдна інтерпретація теорії типів розкриває цю мотивацію та її необхідність, що
було показано Мартіном Хофманом та Томасом Стрейхером в 1996.

\newpage
\subsection{Типи $\Pi$, $\Sigma$, \textbf{Path}}

\subsubsection{$\Pi$-тип}
$\Pi$-тип --- це простір, що містить залежні функції, тип кодомену
яких залежить від значення типу домену. Оскільки домен розшарування
присутній у кожній визначеній функції $\Pi$-тип також є залежним добутком.
Простори залежних функцій використовуються в теорії типів для моделювання
різноманітних математичних конструкцій, об’єктів, типів або
просторів та їхніх відображень: залежних функцій, неперервних відображень,
етальних відображень, розшарувань, квантору узагальнення, імплікацій тощо.

\subsubsection*{Теоретико-типова інтерпретація}
Як логічна система теорія залежних типів відповідає логіці вищих порядків,
одна тут даються виключно правила теоретико-типової MLTT інтерпретації.

\begin{definition} ($\Pi$-Формація). $\Pi$-тип визначає спосіб у який
в певному всесвіті створюється простір залежних фукнцій $f: \Pi(x:A), B(x)$ з
доменом в $A$, та кодоменом $B: A \rightarrow U_i$.
$$\Pi : U =_{def} \prod_{x:A}B(x).$$
\begin{lstlisting}
def Pi (A: U) (B: A $\rightarrow$ U): U := $\Pi$ (x: A), B(x)
\end{lstlisting}
\end{definition}

\begin{definition} ($\Pi$-Представлення). Лямбда-конструктор визначає
нову лямбда-функцію в просторі залежних функцій — це називається
лямбда-абстракцією і позначається як $\lambda x. b(x)$ або $x \mapsto b(x)$.
$$\backslash (x: A) \rightarrow b(x) =_{def} \prod_{A:U}\prod_{B:A \rightarrow U}\prod_{b:\prod_{a:A}B(a)}\lambda x.b(x) : \prod_{y:A}B(y).$$
\begin{lstlisting}
def lambda (A: U) (B: A $\rightarrow$ U) (b: Pi A B) : Pi A B := $\lambda$ (x : A), b x
def lam (A B: U) (f: A $\rightarrow$ B) : A → B :=  $\lambda$ (x : A), f x
\end{lstlisting}
\end{definition}
Коли кодомен не є залежним від значення в домені, функції $f: A \rightarrow B$ вивчаються в моделі теорії типів,
яка називається System $P_\omega$ або числення конструкцій (Caluculus of Constructions).

\newpage
\begin{definition} ($\Pi$-Елімінація). Загальний принцип індукції $\Pi$-типу стверджує, що якщо предикат утримується
для лямбда функцій, тоді існує функція з простору функцій в простір предикатів. Частовий випадок загальної індукції
$\Pi$-типу називається $\lambda$-аплікацією, яка скорочує терм шляхом рекурсивної підстановки виразу замість аргументу з
подальшою нормалізацією.
$$f\ a =_{def} \prod_{A:U}\prod_{B: A \rightarrow U}\prod_{a:A}\prod_{f: \prod_{x:A}B(a)}f(a) : B(a).$$
\begin{lstlisting}
def apply (A B: U) (f: A $\rightarrow$ B) (a: A) : B := f a
def app (A: U) (B: A $\rightarrow$ U) (a: A) (f: Pi A B): B a := f a
\end{lstlisting}
\end{definition}

\begin{definition} (Композиція функцій). Композиція використовує аплікацію відповідних сигнатур.
\begin{lstlisting}
def $\circ^T$ (a b c: U) : U := (b → c) → (a → b) → (a → c)
def $\circ$ (a b c : U) : $\circ^T$ a b c := $\lambda$ (g: b → c) (f: a → b) (x: a), g (f x)
\end{lstlisting}
\end{definition}

\begin{theorem} ($\Pi$-Обчислюваність). $\beta$-правило лямбда числення, або рівняння
обчислювальності показує, що композиція $\mathrm{lam} \circ \mathrm{app}$ може бути скорочена.
$$f(a) =_{B(a)} (\lambda (x:A) \rightarrow f(a))(a).$$
\begin{lstlisting}
def $\Pi$-$\beta$ (A : U) (B : A → U) (a : A) (f : Pi A B)
  : Path (B a) (Π-apply A B (Π-lambda A B f) a) (f a)
 := idp (B a) (f a)
\end{lstlisting}
\end{theorem}

\begin{theorem} ($\Pi$-Унікальність). $\eta$-правило лямбда числення, або рівняння
унікальності показує, що композиція $\mathrm{app} \circ \mathrm{lam}$ може бути скорочена.
$$f =_{(x:A)\rightarrow B(a)} (\lambda (y:A) \rightarrow f(y)).$$
\begin{lstlisting}
def $\Pi$-$\eta$ (A : U) (B : A → U) (a : A) (f : Pi A B)
  : Path (Pi A B) f (λ (x : A), f x)
 := idp (Pi A B) f
\end{lstlisting}
\end{theorem}

\newpage

\subsubsection*{Гомотопічна інтерпретація}
Геометрично, $\Pi$-тип — це простір секцій, у той час коли кодомен — це простір розшарувань.
Лямбда-функції — це простір секцій, або точки в цих просторах, у той час, коли результат функції — це розшарування.
$\Pi$-тип також репрезентує декартовий добуток сім'ї множин, узагальнюючи звичайний декартовий добуток множин.

\begin{definition} (Розшарування).
Розшарування відображення $p: E \rightarrow B$ у точку $y: B$ є всіма точками $x: E$, такими, що $p(x)=y$.
\end{definition}

\begin{definition} (Пучок розрашувань).
Пучок розшарувань $ F \rightarrow E \mapright{p} B$ над тотальним простором $E$ з розшаруванням $F$ і базою $B$ — це
структура $(F,E,p,B)$, де $p: E \rightarrow B$ — це сур'єктивне відображення з наступними властивостями:
для будь-якої точки $y: B$ існує окіл $U_b$ для якого гомеоморфізм $f: p^{-1}(U_b) \rightarrow U_b \times F$
робить наступну діаграму комутативною.
\begin{center}
\begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=2em]
  {
     {p^{-1}(U_b)} & {U_b \times F} \\
     U_b & \\};
  \path[-stealth]
    (m-1-1) edge node [above] {$f$}    (m-1-2)
            edge node [left]  {$p$}    (m-2-1)
    (m-1-2) edge node [right] {$pr_1$} (m-2-1);
\end{tikzpicture}
\end{center}
\end{definition}

\begin{definition} (Декартовий добуток сімейства над B).
Декартовй добуток $F$ над сімейством $B$ — це розшарування секцій пучка з елімінюючим відображенням $app : F \times B \rightarrow E$, таким, що
\begin{equation}
F \times B \mapright{app} E \mapright{pr_1} B
\end{equation}
$pr_1$ — це перша проекція добутка, таким чином $pr_1$, $app$ — це морфізми
слайс категорії $Set_{/B}$. Універсальна властивість відображень розшарування $F$:
для всіх $A$ і морфізму $A \times B \rightarrow E$ в $Set_{/B}$ існує
унікальне відображення $A \rightarrow F$, таке, що робить все комутуючим.
Таким чином, категорія з залежними добутками — це категорія зі всіма пулбеками.
\end{definition}

\begin{definition} (Тривіальний пучок розшарувань).
Коли тотальний простір $E$ є декартовим добутком $\Sigma(B,F)$ і $p = pr_1$,
тоді такий пучок розшарувань називається тривіальним $(F,\Sigma(B,F),pr_1,B)$.
\end{definition}

% \begin{theorem} (Functions Preserve Paths).
% For a function $f: (x:A) \rightarrow B(x)$
% there is an $ap_f : x =_A y \rightarrow f(x) =_{B(x)} f(y)$. This is called
% a pplication of $f$ to path or congruence property (for non-dependent case ---
% $cong$ function). This property behaves functoriality
% as if paths are groupoid morphisms and types are objects.
% \end{theorem}

\begin{theorem} (Тривіальний пучок розшарувань дорівнює сімейству множин).
Inverse image (fiber) of fiber bundle $(F,B*F,pr_1,B)$ in point $y:B$ equals $F(y)$.
\begin{lstlisting}
FiberPi (B: U) (F: B -> U) (y: B)
      : Path U (fiber (Sigma B F) B (pi1 B F) y) (F y)
\end{lstlisting}
\end{theorem}

\subsubsection*{Категоріальна інтерпретація}
Спряження $\Pi$ і $\Sigma$ не єдині які можуть представлені в системі.

\begin{definition} (Залежний добуток).
The dependent product along morphism $g: B \rightarrow A$ in category $C$ is the right
adjoint $\Pi_g : C_{/B} \rightarrow C_{/A}$ of the base change functor.
\end{definition}

\begin{definition} (Простір шарів розшарувань).
Нехай $\mathbf{H}$ --- це $(\infty,1)$-топос, а $E \rightarrow B : \mathbf{H}_{/B}$ ---  розшарування в
$\mathbf{H}$, тобто об'єкт у зрізаному топосі.  Тоді простір перерізів $\Gamma_\Sigma(E)$
цього розшарування є залежним добутком:
$$ \Gamma_\Sigma(E) = \Pi_\Sigma (E) \in \mathbf{H}. $$
\end{definition}

\begin{theorem} (Множина морфізмів).
Якщо область значень є множиною, тоді простір перерізів є множиною.
\begin{lstlisting}
setFun (A B : U) (_: isSet B) : isSet (A -> B)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Стягуваність).
Якщо область визначення і область значень є стягуваними, то простір перерізів також є стягуваним.
\begin{lstlisting}
piIsContr (A: U) (B: A -> U) (u: isContr A)
          (q: (x: A) -> isContr (B x)) : isContr (Pi A B)
\end{lstlisting}
\end{theorem}

\begin{definition} (Шар розшарування).
Перерізом морфізму $f: A \rightarrow B$ у деякій категорії називається морфізм $g: B \rightarrow A$
такий, що їхня композиція $f \circ g: B \mapright{g} A \mapright{f} B$ дорівнює тотожному морфізму на $B$.
\end{definition}

\newpage
\subsubsection{$\Sigma$-тип}
$\Sigma$ --- це залежний тип суми, узагальнення добутків.
Тип $\Sigma$ є повним простором розшарування.
Елемент повного простору формується як пара, що складається з базової точки та розшарування.



\subsubsection{Теоретико-типов інтерпретація}

\begin{definition} ($\Sigma$-Формація).Тип $\Sigma$ утворює залежну суму для базового типу $A$ та залежного типу $B$.
Це правило формування типу в теорії типів, де $U$ — універсум типів. Задане $A:U$ та $B:A\rightarrow U$
(функція, що кожному $a:A$ ставить у відповідність тип $B(a)$, тип $\Sigma(A,B)$ є сукупністю всіх пар $(x,B(x))$,
що описують залежність між базою та розшаруванням.
\begin{lstlisting}
def Sigma (A : U) (B : A -> U) : U := Σ (x : A), B x
\end{lstlisting}
\end{definition}

\begin{definition} ($\Sigma$-Предствалення).
Пара $(a,b)$ є конструктором для типу $\Sigma(A,B)$.
Конструктор $\Sigma(A,B)$ через пару $(a,b)$, де $b:B(a)$.
Це базовий спосіб введення елементів у залежний тип суми.
\begin{lstlisting}
def dpair (A: U) (B: A -> U) (a: A) (b: B a) : Sigma A B = (a,b)
\end{lstlisting}
\end{definition}

\begin{definition}[$\Sigma$-Елімінація]
Ці правила визначають проєкції та індукцію для типу $\Sigma$.
\begin{lstlisting}
def pr1 (A: U) (B: A -> U) (x: Sigma A B): A := x.1
def pr2 (A: U) (B: A -> U) (x: Sigma A B): B (pr1 A B x) := x.2
def sigInd (A: U) (B: A -> U) (C: Sigma A B -> U)
    (g: (a: A) (b: B a) -> C (a, b)) (p: Sigma A B)
  : C p := g p.1 p.2
\end{lstlisting}
\end{definition}

\begin{theorem}[$\Sigma$-Обчислюваність]
Теорема стверджує, що проєкції $pr_1$ і $pr_2$, застосовані до сконструйованої пари $(a,b)$, повертають відповідно $a$ та $b$.
$Equ$ позначає еквівалентність у термінах теорії типів, гарантуючи коректність обчислень.
\begin{lstlisting}
def Beta1 (A: U) (B: A -> U) (a:A) (b: B a)
  : Equ A a (pr1 A B (a,b))

def Beta2 (A: U) (B: A -> U) (a: A) (b: B a)
  : Equ (B a) b (pr2 A B (a,b))
\end{lstlisting}
\end{theorem}

\begin{theorem} ($\Sigma$-Унікальність).
Теорема стверджує, що будь-який елемент $p:\Sigma(A,B)$ еквівалентний парі, складеній із його проєкцій $(pr_1,pr_2)$,
Це відображає принцип унікальності в теорії типів, де структура пари повністю визначається її компонентами.

\begin{lstlisting}
def Eta2 (A: U) (B: A -> U) (p: Sigma A B)
  : Equ (Sigma A B) p (pr1 A B p,pr2 A B p)
\end{lstlisting}
\end{theorem}

\subsubsection{Категоріальна інтерпретація}

\begin{definition} (Залежна сума).
The dependent sum along the morphism $f: A \rightarrow B$ in category $C$ is the left
adjoint $\Sigma_f : C_{/A} \rightarrow C_{/B}$ of the base change functor.
\end{definition}

\subsubsection{Теоретико-множинна інтерпретація}

\begin{theorem} (Аксіома вибору).
If for all $x : A$ there is $y : B$ such that $R(x,y)$,
then there is a function $f : A \rightarrow B$
such that for all $x : A$ there is a witness of $R(x,f(x))$.
\begin{lstlisting}
ac (A B: U) (R: A -> B -> U)
 : (p: (x:A) -> (y:B)*(R x y)) -> (f:A->B) * ((x:A)->R(x)(f x))
\end{lstlisting}
\end{theorem}

\begin{theorem} (Повний простір).
If fiber over base implies another fiber
over the same base then we can construct total space of section
over that base with another fiber.
\begin{lstlisting}
total (A:U) (B C: A -> U)
      (f: (x:A) -> B x -> C x) (w: Sigma A B)
    : Sigma A C = (w.1,f (w.1) (w.2))
\end{lstlisting}
\end{theorem}

\begin{theorem} ($\Sigma$-Стягуваність). If the fiber is set then the $\Sigma$ is set.
\begin{lstlisting}
setSig (A:U) (B: A -> U) (sA: isSet A)
       (sB : (x:A) -> isSet (B x)) : isSet (Sigma A B)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Шлях між сімами).
Path between two sigmas $t,u: \Sigma(A,B)$ could be decomposed to
sigma of two paths $p:t_1=_{A}u_1)$ and $(t_2=_{B(p@i)}u_2)$.
\begin{lstlisting}
pathSig (A:U) (B : A -> U) (t u : Sigma A B)
      : Path U (Path (Sigma A B) t u)
               ((p: Path A t.1 u.1) * PathP (<i>B(p@i)) t.2 u.2)
\end{lstlisting}
\end{theorem}

\newpage
\subsubsection{Path-тип}
The Path identity type defines a Path space with elements and values.
Elements of that space are functions from interval $[0,1]$ to a values of that path space.
This ctt file reflects \footnote{Cyril Cohen, Thierry Coquand, Simon Huber, Anders M{\"{o}}rtberg. Cubical Type Theory: a constructive interpretation of the univalence axiom. 2015. \url{https://5ht.co/cubicaltt.pdf}}{CCHM} cubicaltt model with connections.
For \footnote{Carlo Angiuli, Brunerie, Coquand, Kuen-Bang Hou (Favonia), Robert Harper, Dan Licata. Cartesian Cubical Type Theory. 2017. \url{https://5ht.co/cctt.pdf}}{ABCFHL} yacctt model with
variables please refer to ytt file. You may also want to
read \footnote{Marc Bezem, Thierry Coquand, Simon Huber. A model of type theory in cubical sets. 2014. \url{http://www.cse.chalmers.se/~coquand/mod1.pdf}}{BCH},
\footnote{Carlo Angiuli, Kuen-Bang Hou (Favonia), Robert Harper. Cartesian Cubical Computational Type Theory: Constructive Reasoning with Paths and Equalities. 2018. \\ \url{https://www.cs.cmu.edu/~cangiuli/papers/ccctt.pdf}}{AFH}.
There is a \footnote{Andrew Pitts, Ian Orton. Axioms for Modelling Cubical Type Theory in a Topos. 2016. \url{https://arxiv.org/pdf/1712.04864.pdf}}{PO} paper about CCHM axiomatic in a topos.

\subsubsection{Кубічна інтерпретація}

\begin{definition} (Path-Формація).
\begin{lstlisting}
Hetero (A B: U) (a: A) (b: B) (P: Path U A B) : U = PathP P a b
Path (A: U) (a b: A) : U = PathP (<i> A) a b
\end{lstlisting}
\end{definition}

\begin{definition} (Path-рефлексивність).
Returns an element of reflexivity path space for a given value of the type.
The inhabitant of that path space is the lambda on the homotopy
interval $[0,1]$ that returns a constant value a. Written in
syntax as \lstinline{<i>a} which equals to $\lambda\ (i: I) \rightarrow a$.
\begin{lstlisting}
refl (A: U) (a: A) : Path A a a
\end{lstlisting}
\end{definition}

\begin{definition} (Path-аплікація).
You can apply face to path.
\begin{lstlisting}
app1 (A: U) (a b: A) (p: Path A a b): A = p @ 0
app2 (A: U) (a b: A) (p: Path A a b): A = p @ 1
\end{lstlisting}
\end{definition}

\begin{definition} (Path-композиція).
Composition operation allows to build a new path by given to paths
in a connected point.
\begin{center}
\begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=3em]
  {
     a & c \\ % (1,1) (1,2)
     a & b \\ % (2,1) (2,2)
  };
  \path[-stealth]
    (m-1-1) edge node [above] {$comp$} (m-1-2)
    (m-2-1) edge node [left]  {$\lambda(i:I)\rightarrow a$} (m-1-1)
    (m-2-2) edge node [right] {$q$} (m-1-2)
    (m-2-1) edge node [above] {$p @ i$} (m-2-2);
\end{tikzpicture}
\end{center}
\begin{lstlisting}
composition (A: U) (a b c: A) (p: Path A a b) (q: Path A b c)
          : Path A a c = comp (<i>Path A a (q@i)) p []
\end{lstlisting}
\end{definition}

\begin{theorem} (Path-інверсія).
\begin{lstlisting}
inv (A: U) (a b: A) (p: Path A a b): Path A b a = <i> p @ -i
\end{lstlisting}
\end{theorem}

\begin{definition} (Path-з'єднання).
Connections allows you to build square
with given only one element of path: i) $\lambda\ (i,j: I) \rightarrow p\ @\ min(i,j)$;
ii) $\lambda\ (i,j:I) \rightarrow p\ @\ max(i,j)$.
\begin{center}
  \begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=3em]
  {
     a & b \\ % (1,1) (1,2)
     a & a                    \\ % (2,1) (2,2)
  };
  \path[-stealth]
    (m-1-1) edge node [above] {$p$}    (m-1-2)
    (m-2-1) edge node [left]  {$\lambda\ (i:I)\rightarrow a$}    (m-1-1)
    (m-2-2) edge node [right] {$p$} (m-1-2)
    (m-2-1) edge node [above] {$\lambda\ (i:I)\rightarrow a$} (m-2-2);
  \end{tikzpicture}
  \begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=3em]
  {
     b & b \\ % (1,1) (1,2)
     a & b                    \\ % (2,1) (2,2)
  };
  \path[-stealth]
    (m-1-1) edge node [above] {$\lambda\ (i:I) \rightarrow b$}    (m-1-2)
    (m-2-1) edge node [left]  {$p$}    (m-1-1)
    (m-2-2) edge node [right] {$\lambda\ (i:I) \rightarrow b$} (m-1-2)
    (m-2-1) edge node [above] {$p$} (m-2-2);
  \end{tikzpicture}
\end{center}
\begin{lstlisting}
connection1 (A: U) (a b: A) (p: Path A a b)
          : PathP (<x> Path A (p@x) b) p (<i>b)
          = <y x> p @ (x \/ y)

connection2 (A: U) (a b: A) (p: Path A a b)
          : PathP (<x> Path A a (p@x)) (<i>a) p
          = <x y> p @ (x /\ y)
\end{lstlisting}
\end{definition}

\begin{theorem} (Конгруентність).
Is a map between values of one type
to path space of another type by an encode function between types.
Implemented as lambda defined on $[0,1]$ that returns
application of encode function to path application of
the given path to lamda argument |$\lambda$ (i:I) $\rightarrow$ f (p @ i)|
for both cases.
\begin{lstlisting}
ap  (A B: U) (f: A -> B)
    (a b: A) (p: Path A a b)
  : Path B (f a) (f b)

apd (A: U) (a x:A) (B: A -> U) (f: A -> B a)
    (b: B a) (p: Path A a x)
  : Path (B a) (f a) (f x)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Транспорт).
Transports a value of the domain type to the value of the codomain type
by a given path element of the path space between domain and codomain types.
Defined as path composition with |[]| of a over a path $p$ --- |comp p a []|.
\begin{lstlisting}
trans (A B: U) (p: Path U A B) (a: A) : B
\end{lstlisting}
\end{theorem}

\newpage
\subsubsection{Теоретико-типова інтерпретація}

\begin{definition} (Сінглтон).
\begin{lstlisting}
singl (A: U) (a: A): U = (x: A) * Path A a x
\end{lstlisting}
\end{definition}

\begin{theorem} (Інстанс сінглтона).
\begin{lstlisting}
eta (A: U) (a: A): singl A a = (a,refl A a)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Стягуваність сінглтона).
\begin{lstlisting}
contr (A: U) (a b: A) (p: Path A a b)
  : Path (singl A a) (eta A a) (b,p)
  = <i> (p @ i,<j> p @ i/\j)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Path Elimination, Diagonal).
\begin{lstlisting}
D (A: U) : U = (x y: A) -> Path A x y -> U
J (A: U) (x y: A) (C: D A)
  (d: C x x (refl A x))
  (p: Path A x y) : C x y p
= subst (singl A x) T (eta A x) (y, p) (contr A x y p) d where
  T (z: singl A x) : U = C x (z.1) (z.2)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Path Elimination, Paulin-Mohring).
J is formulated in a form of Paulin-Mohring and implemented using
two facts that singleton are contractible and dependent function
transport.
\begin{lstlisting}
J (A: U) (a b: A)
  (P: singl A a -> U)
  (u: P (a,refl A a))
  (p: Path A a b) : P (b,p)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Path Elimination, HoTT).
J from HoTT book.
\begin{lstlisting}
J (A: U) (a b: A)
  (C: (x: A) -> Path A a x -> U)
  (d: C a (refl A a))
  (p: Path A a b) : C b p
\end{lstlisting}
\end{theorem}

\begin{theorem} (Path Computation).
\begin{lstlisting}
trans_comp (A: U) (a: A)
  : Path A a (trans A A (<_> A) a)
  = fill (<i> A) a []
subst_comp (A: U) (P: A -> U) (a: A) (e: P a)
  : Path (P a) e (subst A P a a (refl A a) e)
  = trans_comp (P a) e
J_comp (A: U) (a: A) (C: (x: A) -> Path A a x -> U) (d: C a (refl A a))
  : Path (C a (refl A a)) d (J A a C d a (refl A a))
  = subst_comp (singl A a) T (eta A a) d where T (z: singl A a)
  : U = C a (z.1) (z.2)
\end{lstlisting}
\end{theorem}

Note that  Path type has no Eta rule due to groupoid interpretation.

\newpage
\subsubsection{Групоїдна інтерпретація}

The groupoid interpretation of type theory is well known article by Martin Hoffman and Thomas Streicher,
more specific interpretation of identity type as infinity groupoid.
The groupoid interpretation of Path equality will be given along with category theory library
in \textbf{Issue VII: Category Theory}.

\subsection{Всесвіти}

This introduction is a bit wild strives to be simple yet precise.
As we defined a language BNF we could define a language AST by
using inductive types which is yet to be defined
in \textbf{Issue II: Inductive Types and Models}. This SAR notation is due Barendregt.

\begin{definition} (Terms). Point in initial object of language AST
inductive definition is called a term. If type theory or language is defined as
an inductive type (AST) then the term is defined as its instance.
\end{definition}

\begin{definition} (Sorts). N-indexed set of universes $\mathrm{U}_{n \in \mathrm{N}}$.
Could have any number of elements which defines different type systems. All built-in
types as long as user defined types are landed usually by default in $U_0$ universe.
Sorts represented in type checker as a separate constructor.
\end{definition}

\begin{definition} (Axioms). The inclusion rules \textbf{$\mathrm{U_i : U_j}, i,j \in \mathrm{N}$},
that define which universe is element of another given universe. You may attach
any rules that joins $i,j$ in some way. Axioms with sorts define universe hierarchy.
\end{definition}

\begin{definition} (Rules). The set of landings
$\mathrm{U_i} \rightarrow \mathrm{U_j} : \mathrm{U_{\lambda(i,j), i,j \in \mathrm{N}}}$,
where $\mathrm{\lambda : N \times N \rightarrow N}$. These rules define term dependence or
how we land (in which universe) formation rules in definitions.
\end{definition}

\begin{definition} (Predicative hierarchy). If $\mathrm{\lambda}$ in Rules
is an uncurried function $\mathrm{max : N \times N \rightarrow N}$
then such universe hierarchy is called predicative.
\end{definition}

\begin{definition} (Impredicative hierarchy). If $\lambda$ in Rules
is a second projection of a tuple $\mathrm{snd : N \times N \rightarrow N}$
then such universe hierarchy is called impredicative.
\end{definition}

\begin{definition} (Definitional Equality). For any $\mathrm{U}_i, i \in \mathrm{N}$ there is
defined an equality between its members and between its instances.
For all x,y $\in$ A, there is defined a x=y. Definitional equality
compares normalized term instances.
\end{definition}

\begin{definition} (SAR). The universum space is configured with a triple of:
i) sorts, a set of universes  $\mathrm{U}_{n \in \mathrm{N}}$ indexed over set N;
ii) axioms, a set of inclusions \textbf{$\mathrm{U_i : U_j}, i,j \in \mathrm{N}$};
iii) rules of term dependence universe landing, a set of landings
$\mathrm{U_i} \rightarrow \mathrm{U_j} : \mathrm{U_{\lambda(i,j), i,j \in \mathrm{N}}}$, where $\lambda$ could be function $max$ (predicative) or $snd$ (impredicative).
\end{definition}

\begin{example} (CoC). SAR = $\{ \{\star , \Box \},\{ \star : \Box \},
        \{ i \rightarrow j : j; i, j \in \{ \star, \Box \}
        \}$. Terms live in universe $\star$, and types live in universe $\Box$. In CoC $\mathrm{\lambda=snd}$.
\end{example}

\begin{example} ($\mathrm{PTS}^\infty$). SAR = $\{ \mathrm{U}_{i \in \mathrm{N}},
    \mathrm{U_i : U_{j; i < j; i,j \in N}},
    \mathrm{U_i} \rightarrow \mathrm{U_j} : \mathrm{U_{\lambda(i,j); i,j \in \mathrm{N}}}
    \}$. Where $U_i$ is a universe of $i$-level or $i$-category in categorical interpretation.
    The working prototype of $\mathrm{PTS}^\infty$ is given in
    \textbf{Addendum I: Pure Type System for Erlang}\footnote{M.Sokhatsky,P.Maslianko. The Systems Engineering of Consistent Pure Language with Effect Type System for Certified Applications and Higher Languages. AIP Conference Proceedings. 2018.
    doi:10.1063/1.5045439}.
\end{example}

\subsection{Контексти}

Speaking of type checker execution, we introduce context or dictionary with types and terms,
from which we can derive typed variables. This chain could be implemented as
nested sigma types (due to R.A.G.Seely) or list types (due to Voevodsky). Categorically
dependent type theory is built upon categories of contexts.

\begin{definition} (Empty Context).
$$
    \gamma_0 : \Gamma =_{def} \star.
$$
\end{definition}

\begin{definition} (Context Comprehension).
$$
\Gamma\ ; A =_{def} \sum_{\gamma:\Gamma}A(\gamma).
$$
\end{definition}

\begin{definition} (Context Derivability).
$$
\Gamma \vdash A =_{def} \prod_{\gamma:\Gamma}A(\gamma).
$$
\end{definition}

\newpage
\subsection{Інтерналізація}

Here is given formal model of type-theoretical interpretation of Martin-Löf Type Theory.
It combines 4 Path rules (no eta), 5 $\Pi$ rules, and 6 $\Sigma$ rules (two elims).
The proof is provided by direct embedding (internalizing) the model intro the model
of type checker which is even more powerful.

\begin{definition} (MLTT).
The MLTT as a Type is defined by taking all rules
for $\Pi$, $\Sigma$ and Path types into one $\Sigma$ telescope or context.
\end{definition}

\begin{lstlisting}
def MLTT (A: U) : U := Σ
    (Π-form  : Π (B: A → U), U)
    (Π-ctor₁ : Π (B: A → U), Pi A B → Pi A B)
    (Π-elim₁ : Π (B: A → U), Pi A B → Pi A B)
    (Π-comp₁ : Π (B: A → U) (a: A) (f: Pi A B),
               Equ (B a) (Π-elim₁ B (Π-ctor₁ B f) a) (f a))
    (Π-comp₂ : Π (B: A → U) (a:  A) (f: Pi A B),
               Equ (Pi A B) f (λ (x : A), f x))
    (Σ-form  : Π (B: A → U), U)
    (Σ-ctor₁ : Π (B: A → U) (a : A) (b : B a), Sigma A B)
    (Σ-elim₁ : Π (B: A → U) (p : Sigma A B), A)
    (Σ-elim₂ : Π (B: A → U) (p : Sigma A B), B (pr₁ A B p))
    (Σ-comp₁ : Π (B: A → U) (a : A) (b: B a),
               Equ A a (Σ-elim₁ B (Σ-ctor₁ B a b)))
    (Σ-comp₂ : Π (B: A → U) (a : A) (b: B a),
               Equ (B a) b (Σ-elim₂ B (a, b)))
    (Σ-comp₃ : Π (B: A → U) (p : Sigma A B),
               Equ (Sigma A B) p (pr₁ A B p, pr₂ A B p))
    (=-form  : Π (a: A), A → U)
    (=-ctor₁ : Π (a: A), Equ A a a)
    (=-elim₁ : Π (a: A) (C: D A) (d: C a a (=-ctor₁ a))
                 (y: A) (p: Equ A a y), C a y p)
    (=-comp₁ : Π (a: A) (C: D A) (d: C a a (=-ctor₁ a)),
               Equ (C a a (=-ctor₁ a)) d (=-elim₁ a C d a (=-ctor₁ a))), U
\end{lstlisting}

\begin{theorem} (Model Check).
There is an instance of MLTT.
\begin{lstlisting}
theorem instance (A : U) : MLTT A :=
    (Pi A, lambda A, app A, comp₁ A, comp₂ A,
     Sigma A, pair A, pr₁ A, pr₂ A, comp₃ A, comp₄ A, comp₅ A,
     Equ A, refl A, J A, comp₆ A, A)
\end{lstlisting}
\end{theorem}

\newpage
\subsection*{Перевірка в кубічній теорії}

The result of the work is a \lstinline{mltt.ctt} file which can be runned using \lstinline{cubicaltt}.
Note that computation rules take a seconds to type check.

\begin{lstlisting}
$\$$ rlwrap ./anders.native check ./experiments/mltt.anders
File loaded.
> :n instance
TYPE: Π (A : U), Σ (Π-form : Π (B : (A → U)), U), Σ (Π-ctor₁ : Π (B : (A → U)), (Π (x : A), (B x) → Π (x : A), (B x))), Σ (Π-elim₁ : Π (B : (A → U)), (Π (x : A), (B x) → Π (x : A), (B x))), Σ (Π-comp₁ : Π (B : (A → U)), Π (a : A), Π (f : Π (x : A), (B x)), Π (P : ((B a) → U)), ((P (((Π-elim₁ B) ((Π-ctor₁ B) f)) a)) → (P (f a)))), Σ (Π-comp₂ : Π (B : (A → U)), Π (a : A), Π (f : Π (x : A), (B x)), Π (P : (Π (x : A), (B x) → U)), ((P f) → (P λ (x : A), (f x)))), Σ (Σ-form : Π (B : (A → U)), U), Σ (Σ-ctor₁ : Π (B : (A → U)), Π (a : A), Π (b : (B a)), Σ (x : A), (B x)), Σ (Σ-elim₁ : Π (B : (A → U)), Π (p : Σ (x : A), (B x)), A), Σ (Σ-elim₂ : Π (B : (A → U)), Π (p : Σ (x : A), (B x)), (B p.1)), Σ (Σ-comp₁ : Π (B : (A → U)), Π (a : A), Π (b : (B a)), Π (P : (A → U)), ((P a) → (P ((Σ-elim₁ B) (((Σ-ctor₁ B) a) b))))), Σ (Σ-comp₂ : Π (B : (A → U)), Π (a : A), Π (b : (B a)), Π (P : ((B a) → U)), ((P b) → (P ((Σ-elim₂ B) (a, b))))), Σ (Σ-comp₃ : Π (B : (A → U)), Π (p : Σ (x : A), (B x)), Π (P : (Σ (x : A), (B x) → U)), ((P p) → (P (p.1, p.2)))), Σ (=-form : Π (a : A), (A → U)), Σ (=-ctor₁ : Π (a : A), Π (P : (A → U)), ((P a) → (P a))), Σ (=-elim₁ : Π (a : A), Π (C : Π (x : A), Π (y : A), (Π (P : (A → U)), ((P x) → (P y)) → U)), Π (d : (((C a) a) (=-ctor₁ a))), Π (y : A), Π (p : Π (P : (A → U)), ((P a) → (P y))), (((C a) y) p)), Σ (=-comp₁ : Π (a : A), Π (C : Π (x : A), Π (y : A), (Π (P : (A → U)), ((P x) → (P y)) → U)), Π (d : (((C a) a) (=-ctor₁ a))), Π (P : ((((C a) a) (=-ctor₁ a)) → U)), ((P d) → (P (((((=-elim₁ a) C) d) a) (=-ctor₁ a))))), U
NORMEVAL: λ (A : U), (λ (B : (A → U)), Π (x : A), (B x), (λ (B : (A → U)), λ (b : Π (x : A), (B x)), λ (x : A), (b x), (λ (B : (A → U)), λ (f : Π (x : A), (B x)), λ (a : A), (f a), (λ (B : (A → U)), λ (a : A), λ (f : Π (x : A), (B x)), λ (P : ((B a) → U)), λ (u : (P (f a))), u, (λ (B : (A → U)), λ (a : A), λ (f : Π (x : A), (B x)), λ (P : (Π (x : A), (B x) → U)), λ (u : (P f)), u, (λ (B : (A → U)), Σ (x : A), (B x), (λ (B : (A → U)), λ (a : A), λ (b : (B a)), (a, b), (λ (B : (A → U)), λ (x : Σ (x : A), (B x)), x.1, (λ (B : (A → U)), λ (x : Σ (x : A), (B x)), x.2, (λ (B : (A → U)), λ (a : A), λ (b : (B a)), λ (P : (A → U)), λ (u : (P a)), u, (λ (B : (A → U)), λ (a : A), λ (b : (B a)), λ (P : ((B a) → U)), λ (u : (P b)), u, (λ (B : (A → U)), λ (p : Σ (x : A), (B x)), λ (P : (Σ (x : A), (B x) → U)), λ (u : (P p)), u, (λ (x : A), λ (y : A), Π (P : (A → U)), ((P x) → (P y)), (λ (x : A), λ (P : (A → U)), λ (u : (P x)), u, ((J A), ((comp₆ A), A))))))))))))))))
\end{lstlisting}

\newpage
\section{Індуктивні типи}

\subsection{Empty, Unit}

empty type lacks both introduction rules and eliminators. However, it has recursor and induction.

\begin{lstlisting}
data empty =
emptyRec (C: U): empty -> C = split {}
emptyInd (C: empty -> U): (z: empty) -> C z = split {}
\end{lstlisting}

\begin{lstlisting}
data unit = star
unitRec (C: U) (x: C): unit -> C = split tt -> x
unitInd (C: unit -> U) (x: C tt): (z: unit) -> C z = split tt -> x
\end{lstlisting}

\newpage
\subsection{Bool, Maybe, Either, Tuple}

\begin{definition} (Bool).
bool is a run-time version of the boolean logic you may use
in your general purpose applications. bool is isomorphic
to 1+1: either unit unit.
\begin{lstlisting}
data bool = false | true
b1: U = bool -> bool
b2: U = bool -> bool -> bool
negation: b1 = split { false -> true; true -> false }
or: b2 = split { false -> idfun bool; true -> lambda bool bool true }
and: b2 = split { false -> lambda bool bool false; true -> idfun boo }
boolEq: b2 = lamb bool (bool -> bool) negation
boolRec (C: U) (f t: C): bool -> C = split { false -> f ; true -> t }
boolInd (C: bool -> U) (f: A false) (t: A true): (n:bool) -> A n
  = split { false -> f ; true -> t }
\end{lstlisting}
\end{definition}

\begin{definition} (Maybe).
Maybe has representing functor $M_A(X) = 1 + A$.
It is used for wrapping values with optional nothing constructor.
In ML-family languages this type is called Option (Miranda, ML).
There is an isomorphims between (fix maybe) and nat.
\begin{lstlisting}
data maybe (A: U) = nothing | just (x: A)
maybeRec (A P: U) (n: P) (j: A -> P): maybe A -> P
       = split { nothing -> n; just a -> j a }

maybeInd (A: U) (P: maybe A -> U) (n: P nothing)
         (j: (a: A) -> P (just a)): (a: maybe A) -> P a
       = split { nothing -> n ; just x -> j x }
\end{lstlisting}
\end{definition}

either is a representation for sum types or disjunction.
\begin{lstlisting}[mathescape=true]
data either (A B: U) = left (x: A) | right (y: B)
eitherRec (A B C: U) (b: A -> C) (c: B -> C): either A B -> C
        = split { inl x -> b(x) ; inr y -> c(y) }

eitherInd (A B: U) (C: either A B -> U)
          (x: (a: A) -> C (inl a))
          (y: (b: B) -> C (inr b))
        : (x: either A B) -> C x
        = split { inl i -> x i ; inr j -> y j }
\end{lstlisting}

tuple is a representation for non-dependent product types or conjunction.
\begin{lstlisting}
data tuple (A B: U) = pair (x: A) (y: B)
prod (A B: U) (x: A) (y: B): (_: A) * B = (x,y)
tupleRec  (A B C: U) (c: (x:A) (y:B) -> C): (x: tuple A B) -> C
        = split pair a b -> c a b
tupleInd  (A B: U) (C: tuple A B -> U)
          (c: (x:A)(y:B) -> C (pair x y))
        : (x: tuple A B) -> C x
        = split pair a b -> c a b
\end{lstlisting}

\newpage
\subsection{Nat, List, Stream}
Pointed Unary System is a category nat with the terminal
object and a carrier nat having morphism [zero: 1nat → nat, succ: nat → nat].
The initial object of nat is called Natural Number Object and models Peano axiom set.

\begin{lstlisting}[mathescape=true]
data nat = zero | succ (n: nat)
natEq: nat -> nat -> bool
natCase (C:U) (a b: C): nat -> C
natRec  (C:U) (z: C) (s: nat->C->C) : (n:nat) -> C
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
natElim (C:nat->U) (z: C zero)
        (s: (n:nat)->C(succ n)): (n:nat) -> C(n)
natInd  (C:nat->U) (z: C zero)
        (s: (n:nat)->C(n)->C(succ n)): (n:nat) -> C(n)
\end{lstlisting}

\begin{definition} (List).
The data type of list L over a given set A can be represented
as the initial algebra $(\mu L_A, in)$ of the functor $L_A(X) = 1 + (A \times X)$.
Denote $\mu L_A = List(A)$. The constructor functions
$nil: 1 \rightarrow List(A)$ and $cons: A \times List(A) \rightarrow
List(A)$ are defined by $nil = in \circ inl$ and $cons = in \circ inr$,
so $in = [nil,cons]$.
\begin{lstlisting}[mathescape=true]
data list (A: U) = nil | cons (x:A) (xs: list A)
listCase (A C:U) (a b: C): list A -> C
listRec (A C:U) (z: C) (s: A->list A->C->C): (n:list A) -> C
listElim (A: U) (C:list A->U) (z: C nil)
   (s: (x:A)(xs:list A)->C(cons x xs)): (n:list A) -> C(n)
listInd (A: U) (C:list A->U) (z: C nil)
   (s: (x:A)(xs:list A)->C(xs)->C(cons x xs)): (n:list A) -> C(n)
\end{lstlisting}
\begin{lstlisting}[mathescape=true]
null (A: U): list A -> bool
head (A: U): list A -> maybe A
tail (A:U): list A -> maybe (list A)
nth (A:U): nat -> list A -> maybeA
append (A: U): list A -> list A -> list A
reverse (A: U): list A -> list A
map (A B: U): (A -> B) -> list A -> list B
zip (AB: U): list A -> list B -> list (tuple A B)
foldr (AB: U): (A -> B -> B) -> B -> list A -> B
foldl (AB: U): (B -> A -> B) -> B -> list A -> B
switch (A: U): (Unit -> list A) -> bool -> list A
filter (A: U): (A -> bool) -> list A -> list A
length (A: U): list A -> nat
listEq (A: eq): list A.1 -> list A.1 -> bool
\end{lstlisting}
\end{definition}

stream is a record form of the list's cons constructor. It models the infinity list that has no terminal element.
\begin{lstlisting}
data stream (A: U) = cons (x: A) (xs: stream A)
\end{lstlisting}

\subsection{Fin, Vector, Seq}

fin is the inductive defintion of set with finite elements.
\begin{lstlisting}
data fin (n: nat)
   = fzero | fsucc (_: fin (pred n))

fz (n: nat): fin (succ n)          = fzero
fs (n: nat): fin n -> fin (succ n) = \(x: fin n) -> fsucc x
\end{lstlisting}

vector is the inductive defintion of limited length list.
\begin{lstlisting}
data vector (A: U) (n: nat)
   = nil | cons (_: A) (_: vector A (pred n))
\end{lstlisting}

seq — abstract compositional sequences.
\begin{lstlisting}
data seq (A: U) (B: A -> A -> U) (X Y: A)
   = seqNil (_: A)
   | seqCons (X Y Z: A) (_: B X Y) (_: Seq A B Y Z)
\end{lstlisting}

\subsection{Імпредикативне кодування}

You know Church encoding which also has its dependent alanolgue in CoC, however
in Coq it is imposible to detive Inductive Principle as type system lacks fixpoint
and functional extensionality. The example of working compiler of PTS languages are Om and Morte.
Assume we have Church encoded NAT:

\begin{lstlisting}[mathescape=true]
nat = (X:U) -> (X -> X) -> X -> X
\end{lstlisting}

where first parameter $(X -> X)$ is a $succ$, the second parameter $X$ is $zero$,
and the result of encoding is landed in X. Even if we encode the parameter

\begin{lstlisting}[mathescape=true]
list (A: U) = (X:U) -> X -> (A -> X) -> X
\end{lstlisting}

and paremeter A let's say live in 42 universe and X live in 2 universe, then by
the signature of encoding the term will be landed in X, thus 2 universe. In other words
such dependency is called impredicative displaying that landed term is not a predicate over parameters.
This means that Church encoding is incompatible with predicative type checkers with predicative
of predicative-cumulative hierarchies.

In HoTT n-types is encoded as n-groupoids, thus we need to add a predicate in which n-type
we would like to land the encoding:

\begin{lstlisting}[mathescape=true]
NAT (A: U) = (X:U) -> isSet X -> X -> (A -> X) -> X
\end{lstlisting}

Here we added isSet predicate. With this motto we can implement propositional
truncation by landing term in isProp or even HIT by langing in isGroupoid:

\begin{lstlisting}[mathescape=true]
TRUN (A:U) type = (X: U) -> isProp X -> (A -> X) -> X
S1 = (X:U) -> isGroupoid X -> ((x:X) -> Path X x x) -> X
MONOPLE (A:U) = (X:U) -> isSet X -> (A -> X) -> X
NAT = (X:U) -> isSet X -> X -> (A -> X) -> X
\end{lstlisting}

The main publication on this topic could be found at \cite{Awodey17} and \cite{Speight17}.
Here we have the implementation of Unit impredicative encoding in HoTT.

\begin{lstlisting}[mathescape=true]
upPath     (X Y:U)(f:X->Y)(a:X->X): X -> Y = o X X Y f a
downPath   (X Y:U)(f:X->Y)(b:Y->Y): X -> Y = o X Y Y b f
naturality (X Y:U)(f:X->Y)(a:X->X)(b:Y->Y): U
  = Path (X->Y)(upPath X Y f a)(downPath X Y f b)

unitEnc': U = (X: U) -> isSet X -> X -> X
isUnitEnc (one: unitEnc'): U
  = (X Y:U)(x:isSet X)(y:isSet Y)(f:X->Y) ->
    naturality X Y f (one X x)(one Y y)

unitEnc: U = (x: unitEnc') * isUnitEnc x
unitEncStar: unitEnc = (\(X:U)(_:isSet X) ->
  idfun X,\(X Y: U)(_:isSet X)(_:isSet Y)->refl(X->Y))
unitEncRec  (C: U) (s: isSet C) (c: C): unitEnc -> C
  = \(z: unitEnc) -> z.1 C s c
unitEncBeta (C: U) (s: isSet C) (c: C)
  : Path C (unitEncRec C s c unitEncStar) c = refl C c
unitEncEta (z: unitEnc): Path unitEnc unitEncStar z = undefined
unitEncInd (P: unitEnc -> U) (a: unitEnc): P unitEncStar -> P a
  = subst unitEnc P unitEncStar a (unitEncEta a)
unitEncCondition (n: unitEnc'): isProp (isUnitEnc n)
  =  \(f g: isUnitEnc n) ->
     <h> \(x y: U) -> \(X: isSet x) -> \(Y: isSet y)
  -> \(F: x -> y) -> <i> \(R: x) -> Y (F (n x X R)) (n y Y (F R))
       (<j> f x y X Y F @ j R) (<j> g x y X Y F @ j R) @ h @ i
\end{lstlisting}

\section{Гомотопічна теорія типів}

Homotypy Type Theory takes its origins in 1996 from groupoid interpretation by
Hofmann and Streicher's, and later (in 10 years) was formalized by Awodey,
Warren and Voevodsky. Voevodsky constrtucted Kan simplicial sets interpretation
of type theory and discovered the property of this model, that was named univalence.
This property allows to identify isomorphic structures in terms of type theory.

Homotopy type theory to classical homotopy theory is like Euclidian
syntethic geometry (points, lines, axioms and deduction rules) to
analytical geometry with cartesian coordinates on $\mathbb{R}^n$ (geometric and algebraic)
\footnote{We will denote geometric, type theoretical and homotopy constants bold font $\textbf{R}$ while
analitical will be denoted with double lined letters $\mathbb{R}$.}

In the same way as inductive types extends MLTT for inductive programming,
the higher inductive types (HIT) extend homotopy type theory for geometry programming.
You can directly encode CW-complexes by using HIT. The definition of HIT syntax will
be given in the next \textbf{Issue IV: Higher Inductive Types}.

\subsection{Гомотопії}
The first higher equality we meet in homotopy theory is a notion of homotopy,
where we compare two functions or two path spaces (which is sort of dependent families).
The homotopy interval $\mathrm{I}=[0,1]$ is the perfect foundation for definition of homotopy.

\begin{definition} (Interval). Compact interval.
\begin{lstlisting}
data I = i0
       | i1
       | seg <i> [(i=0) -> i0,
                  (i=1) -> i1]
\end{lstlisting}
\end{definition}

You can think of $\textbf{I}$ as isomorphism of equality type,
disregarding carriers on the edges. By mapping $i0,i1:\textbf{I}$ to $x,y:A$ one can
obtain identity or equality type from classic type theory.

\begin{definition} (Interval Split).
The convertion function from $\mathrm{I}$ to a type of comparison
is a direct eliminator of interval. The interval is also known as one of
primitive higher inductive types which will be given in the next
\textbf{Issue IV: Higher Inductive Types}.
\begin{lstlisting}
pathToHtpy (A: U) (x y: A) (p: Path A x y): I -> A
   = split { i0 -> x; i1 -> y; seg @ i -> p @ i }
\end{lstlisting}
\end{definition}

\begin{definition} (Homotopy). The homotopy between two function $f,g: X \rightarrow Y$
is a continuous map of cylinder $H : X \times \textbf{I} \rightarrow Y$ such that
$$
\begin{cases}
H(x,0)=f(x), \\
H(x,1)=g(x).
\end{cases}
$$
\begin{lstlisting}
homotopy (X Y: U) (f g: X -> Y)
         (p: (x: X) -> Path Y (f x) (g x))
         (x: X): I -> Y = pathToHtpy Y (f x) (g x) (p x)
\end{lstlisting}
\end{definition}

\subsection{Групоїдна інтерпретація}
The first text about groupoid interpretation of type theory can be found in Francois Lamarche:
A proposal about Foundations\footnote{\url{http://www.cse.chalmers.se/~coquand/Proposal.pdf}}.
Then Martin Hofmann and Thomas Streicher wrote the initial
document on groupoid interpretation of type
theory\footnote{Martin Hofmann and Thomas Streicher. The Groupoid Interpretation of Type Theory. 1996.}.

\begin{table}
\begin{center}
\begin{tabular}{lccc}
\hline
\textbf{Equality} & {\textbf{Homotopy}} & \textbf{$\infty$-Groupoid} \\
\hline
reflexivity  & constant path & identity morphism \\
symmetry     & inversion of path & inverse morphism \\
transitivity & concatenation of paths & composition of mopphisms \\
\hline
\end{tabular}
\end{center}
\end{table}

There is a deep connection between higher-dimentinal groupoids in category theory and
spaces in homotopy theory, equipped with some topology. The category or groupoid could
be built where the objects are particular spaces or types, and morphisms are path types
between these types, composition operation is a path concatenation. We can write this
groupoid here recalling that it should be category with inverted morphisms.

\begin{lstlisting}
cat: U = (A: U) * (A -> A -> U)
groupoid: U = (X: cat) * isCatGroupoid X
PathCat (X: U): cat = (X,\(x y:X)->Path X x y)
\end{lstlisting}

\begin{lstlisting}
isCatGroupoid (C: cat): U
  = (id: (x: C.1) -> C.2 x x)
  * (c: (x y z:C.1) -> C.2 x y -> C.2 y z -> C.2 x z)
  * (inv: (x y: C.1) -> C.2 x y -> C.2 y x)
  * (inv_left:  (x y: C.1) (p: C.2 x y) ->
    Path (C.2 x x) (c x y x p (inv x y p)) (id x))
  * (inv_right: (x y: C.1) (p: C.2 x y) ->
    Path (C.2 y y) (c y x y (inv x y p) p) (id y))
  * (left: (x y: C.1) (f: C.2 x y) ->
    Path (C.2 x y) (c x x y (id x) f) f)
  * (right: (x y: C.1) (f: C.2 x y) ->
    Path (C.2 x y) (c x y y f (id y)) f)
  * ((x y z w:C.1)(f:C.2 x y)(g:C.2 y z)(h:C.2 z w)->
    Path (C.2 x w) (c x z w (c x y z f g) h)
                   (c x y w f (c y z w g h)))
\end{lstlisting}

\begin{lstlisting}
PathGrpd (X: U)
  : groupoid
  = ((Ob,Hom),id,c,sym X,compPathInv X,compInvPath X,L,R,Q) where
    Ob: U = X
    Hom (A B: Ob): U = Path X A B
    id (A: Ob): Path X A A = refl X A
    c (A B C: Ob) (f: Hom A B) (g: Hom B C): Hom A C
      = comp (<i> Path X A (g@i)) f []
\end{lstlisting}
From here should be clear what it meant to be groupoid interpretation
of path type in type theory. In the same way we can construct categories of $\prod$ and $\sum$ types.
In {\textbf{Issue VIII: Topos Theory}} such categories will be given.

\subsection{Функціональна екстенсіональність}

\begin{definition} (funExt-Formation)
\begin{lstlisting}
funext_form (A B: U) (f g: A -> B): U
  = Path (A -> B) f g
\end{lstlisting}
\end{definition}

\begin{definition} (funExt-Introduction)
\begin{lstlisting}
funext (A B: U) (f g: A -> B) (p: (x:A) -> Path B (f x) (g x))
  : funext_form A B f g
  = <i> \(a: A) -> p a @ i
\end{lstlisting}
\end{definition}

\begin{definition} (funExt-Elimination)
\begin{lstlisting}
happly (A B: U) (f g: A -> B) (p: funext_form A B f g) (x: A)
  : Path B (f x) (g x)
  = cong (A -> B) B (\(h: A -> B) -> apply A B h x) f g p
\end{lstlisting}
\end{definition}

\begin{definition} (funExt-Computation)
\begin{lstlisting}
funext_Beta (A B: U) (f g: A -> B) (p: (x:A) -> Path B (f x) (g x))
  : (x:A) -> Path B (f x) (g x)
  = \(x:A) -> happly A B f g (funext A B f g p) x
\end{lstlisting}
\end{definition}

\begin{definition} (funExt-Uniqueness)
\begin{lstlisting}
funext_Eta (A B: U) (f g: A -> B) (p: Path (A -> B) f g)
  : Path (Path (A -> B) f g) (funext A B f g (happly A B f g p)) p
  = refl (Path (A -> B) f g) p
\end{lstlisting}
\end{definition}

\subsection{Пулбеки}

\begin{definition} (Пулбек).
\begin{lstlisting}
pullback (A B C:U) (f: A -> C) (g: B -> C): U
  = (a: A)
  * (b: B)
  * Path C (f a) (g b)

pb1 (A B C: U) (f: A -> C) (g: B -> C)
  : pullback A B C f g -> A
  = \(x: pullback A B C f g) -> x.1

pb2 (A B C: U) (f: A -> C) (g: B -> C)
  : pullback A B C f g -> B
  = \(x: pullback A B C f g) -> x.2.1

pb3 (A B C: U) (f: A -> C) (g: B -> C)
  : (x: pullback A B C f g) -> Path C (f x.1) (g x.2.1)
  = \(x: pullback A B C f g) -> x.2.2
\end{lstlisting}
\end{definition}

\begin{definition} (Ядро).
\begin{lstlisting}
kernel  (A B: U) (f: A -> B): U
  = pullback A A B f f
\end{lstlisting}
\end{definition}

\begin{definition} (Гомотопічне розшарування).
\begin{lstlisting}
hofiber (A B: U) (f: A -> B) (y: B): U
  = pullback A unit B f (\(x: unit) -> y)
\end{lstlisting}
\end{definition}

\begin{definition} (Пулбек Квадрат).
\begin{lstlisting}
pullbackSq (Z A B C: U) (f: A -> C) (g: B -> C) (z1: Z -> A) (z2: Z -> B): U
         = (h: (z:Z) -> Path C ((o Z A C f z1) z) (((o Z B C g z2)) z))
         * isEquiv Z (pullback A B C f g) (induced Z A B C f g z1 z2 h)
\end{lstlisting}
\end{definition}

\begin{theorem} (Існування пулбеку).
\begin{lstlisting}
completePullback (A B C: U) (f: A -> C) (g: B -> C)
    : pullbackSq (pullback A B C f g) A B C f g (pb1 A B C f g) (pb2 A B C f g)
\end{lstlisting}
\end{theorem}

\subsection{Пушаути та фібрації}

\begin{definition} (Pushout). One of the notable examples is pushout as it's used
to define the cell attachment formally, as others cofibrant objects.
\begin{lstlisting}
data pushout (A B C: U) (f: C -> A) (g: C -> B)
   = po1 (_: A)
   | po2 (_: B)
   | po3 (c: C) <i> [ (i = 0) -> po1 (f c) ,
                      (i = 1) -> po2 (g c) ]
\end{lstlisting}
\end{definition}

\begin{definition} (Fibration-1) Dependent fiber bundle derived from Path contractability.
\begin{lstlisting}
isFBundle1 (B: U) (p: B -> U) (F: U): U
  = (_: (b: B) -> isContr (Path U (p b) F))
  * ((x: Sigma B p) -> B)
\end{lstlisting}
\end{definition}

\begin{definition} (Fibration-2). Dependent fiber bundle derived from surjective function.
\begin{lstlisting}
isFBundle2 (B: U) (p: B -> U) (F: U): U
  = (V: U)
  * (v: surjective V B)
  * ((x: V) -> Path U (p (v.1 x)) F)
\end{lstlisting}
\end{definition}

\begin{definition} (Fibration-3). Non-dependent fiber bundle derived from fiber truncation.
\begin{lstlisting}
im1 (A B: U) (f: A -> B): U = (b: B) * pTrunc ((a:A) * Path B (f a) b)
BAut (F: U): U = im1 unit U (\(x: unit) -> F)
unitIm1 (A B: U) (f: A -> B): im1 A B f -> B = \(x: im1 A B f) -> x.1
unitBAut (F: U): BAut F -> U = unitIm1 unit U (\(x: unit) -> F)

isFBundle3 (E B: U) (p: E -> B) (F: U): U
  = (X: B -> BAut F)
  * (classify B (BAut F) (\(b: B) -> fiber E B p b) (unitBAut F) X) where
  classify (A' A: U) (E': A' -> U) (E: A -> U) (f: A' -> A): U
    = (x: A') -> Path U (E'(x)) (E(f(x)))
\end{lstlisting}
\end{definition}

\begin{definition} (Fibration-4). Non-dependen fiber bundle derived as pullback square.
\begin{lstlisting}
isFBundle4 (E B: U) (p: E -> B) (F: U): U
  = (V: U)
  * (v: surjective V B)
  * (v': prod V F -> E)
  * pullbackSq (prod V F) E V B p v.1 v' (\(x: prod V F) -> x.1)
\end{lstlisting}
\end{definition}

\subsection{Еквівалентність, Ізоморфізм, Унівалентність}

\begin{definition} (Equivalence).
\begin{lstlisting}
fiber (A B: U) (f: A -> B) (y: B): U = (x: A) * Path B y (f x)
isSingleton (X:U): U = (c:X) * ((x:X) -> Path X c x)
isEquiv (A B: U) (f: A -> B): U = (y: B) -> isContr (fiber A B f y)
equiv (A B: U): U = (f: A -> B) * isEquiv A B f
\end{lstlisting}
\end{definition}

\begin{definition} (Surjective).
\begin{lstlisting}
isSurjective (A B: U) (f: A -> B): U
  = (b: B) * pTrunc (fiber A B f b)

surjective (A B: U): U
  = (f: A -> B)
  * isSurjective A B f
\end{lstlisting}
\end{definition}

\begin{definition} (Injective).
\begin{lstlisting}
isInjective' (A B: U) (f: A -> B): U
  = (b: B) -> isProp (fiber A B f b)

injective (A B: U): U
  = (f: A -> B)
  * isInjective A B f
\end{lstlisting}
\end{definition}

\begin{definition} (Embedding).
\begin{lstlisting}
isEmbedding (A B: U) (f: A -> B) : U
  = (x y: A) -> isEquiv (Path A x y) (Path B (f x) (f y)) (cong A B f x y)

embedding (A B: U): U
  = (f: A -> B)
  * isEmbedding A B f
\end{lstlisting}
\end{definition}

\begin{definition} (Half-adjoint Equivalence).
\begin{lstlisting}
isHae (A B: U) (f: A -> B): U
  = (g: B -> A)
  * (eta_: Path (id A) (o A B A g f) (idfun A))
  * (eps_: Path (id B) (o B A B f g) (idfun B))
  * ((x: A) -> Path B (f ((eta_ @ 0) x)) ((eps_ @ 0) (f x)))

hae (A B: U): U
  = (f: A -> B)
  * isHae A B f
\end{lstlisting}
\end{definition}

Ізоморфізм.

\begin{definition} (iso-Formation)
\begin{lstlisting}
iso_Form (A B: U): U = isIso A B -> Path U A B
\end{lstlisting}
\end{definition}

\begin{definition} (iso-Introduction)
\begin{lstlisting}
iso_Intro (A B: U): iso_Form A B
\end{lstlisting}
\end{definition}

\begin{definition} (iso-Elimination)
\begin{lstlisting}
iso_Elim (A B: U): Path U A B -> isIso A B
\end{lstlisting}
\end{definition}

\begin{definition} (iso-Computation)
\begin{lstlisting}
iso_Comp (A B : U) (p : Path U A B)
  : Path (Path U A B) (iso_Intro A B (iso_Elim A B p)) p
\end{lstlisting}
\end{definition}

\begin{definition} (iso-Uniqueness)
\begin{lstlisting}
iso_Uniq (A B : U) (p: isIso A B)
  : Path (isIso A B) (iso_Elim A B (iso_Intro A B p)) p
\end{lstlisting}
\end{definition}

Унівалентність.

\begin{definition} (uni-Formation)
\begin{lstlisting}
univ_Formation (A B: U): U = equiv A B -> Path U A B
\end{lstlisting}
\end{definition}

\begin{definition} (uni-Introduction)
\begin{lstlisting}
equivToPath (A B: U): univ_Formation A B
  = \(p: equiv A B) -> <i> Glue B [(i=0) -> (A,p),
    (i=1) -> (B, subst U (equiv B) B B (<_>B) (idEquiv B)) ]
\end{lstlisting}
\end{definition}

\begin{definition} (uni-Elimination)
\begin{lstlisting}
pathToEquiv (A B: U) (p: Path U A B) : equiv A B
  = subst U (equiv A) A B p (idEquiv A)
\end{lstlisting}
\end{definition}

\begin{definition} (uni-Computation)
\begin{lstlisting}
eqToEq (A B : U) (p : Path U A B)
  : Path (Path U A B) (equivToPath A B (pathToEquiv A B p)) p
  = <j i> let Ai: U = p@i in Glue B
    [ (i=0) -> (A,pathToEquiv A B p),
      (i=1) -> (B,pathToEquiv B B (<k> B)),
      (j=1) -> (p@i,pathToEquiv Ai B (<k> p @ (i \/ k))) ]

\end{lstlisting}
\end{definition}

\begin{definition} (uni-Uniqueness)
\begin{lstlisting}
transPathFun (A B : U) (w: equiv A B)
  : Path (A -> B) w.1 (pathToEquiv A B (equivToPath A B w)).1
\end{lstlisting}
\end{definition}

\section{Вищі індуктивні типи}

CW-complexes are central to HoTT and appear in cubical type checkers as HITs.
Unlike inductive types (recursive trees), HITs encode CW-complexes, capturing
points (0-cells) and higher paths (n-cells). The definition of an HIT specifies a CW-complex
through cubical composition, an initial algebra in the cubical model.

\newpage
\subsection{Suspension}
The suspension \(\Sigma A\) of a type \( A \) is a higher inductive type that
constructs a new type by adding two points, called poles, and paths connecting
each point of \( A \) to these poles. It is a fundamental construction in homotopy theory,
often used to shift homotopy groups, e.g., obtaining \( S^{n+1} \) from \( S^n \).

\begin{definition} (Formation).
For any type \( A : \mathcal{U} \), there exists a suspension type \( \Sigma A : \mathcal{U} \).
\end{definition}

\begin{definition} (Constructors).
For a type \( A : \mathcal{U} \), the suspension \( \Sigma A : \mathcal{U} \)
is generated by the following higher inductive compositional structure:
\[
\Sigma :=
\begin{cases}
\text{north} \\
\text{south} \\
\text{merid} : (a : A) \rightarrow \text{north} \equiv \text{south} \\
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\Sigma$ (A: U) : U
 := inductive { north
              | south
              | merid (a: A) : north $\equiv$ south
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a family of types \( B : \Sigma A \to \mathcal{U} \), points \( n : B(\text{north}) \), \( s : B(\text{south}) \), and a family
of dependent paths
\[
  m : \Pi (a : A), \text{PathOver}(B,\text{merid}(a),n,s),
\]
there exists a dependent map \( \text{Ind}_{\Sigma A} : (x : \Sigma A) \to B(x) \), such that:
\[
\begin{cases}
\text{Ind}_{\Sigma A}(\text{north}) = n \\
\text{Ind}_{\Sigma A}(\text{south}) = s \\
\text{Ind}_{\Sigma A}(\text{merid}(a,i)) = m(a,i)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def PathOver (B: $\Sigma$ A -> U) (a: A) (n: B north) (s: B south) : U
  := PathP ($\lambda$ i , B (merid a @ i)) n s

def Ind$_\Sigma A$ (A: U) (B: $\Sigma$ A -> U) (n: B north) (s: B south)
    (m: (a: A) -> PathOver B (merid a) n s) : (x: $\Sigma$ A) -> B x
 := split { north -> n | south -> s | merid a @ i -> m a @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation).
\[
    \text{Ind}_\Sigma A(\text{north}) = n \\
    \text{Ind}_\Sigma A(\text{south}) = s \\
    \text{Ind}_\Sigma A(\text{merid}(a,i)) = m(a,i)
\]
\begin{lstlisting}[mathescape=true]
def $\Sigma$-$\beta$ (A: U) (B: $\Sigma A$ -> U) (n: B north) (s: B south)
    (m: (a: A) -> PathOver B (merid a) n s) (x: $\Sigma$ A)
  : Path (B x) ($\Sigma$-I A B n s m x)
    split { north -> n | south -> s | merid a @ i -> m a @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Uniqueness).
Any two maps \( h_1, h_2 : (x : \Sigma A) \to B(x) \) are homotopic if they agree
on \( \text{north} \), \( \text{south} \), and \( \text{merid} \), i.e.,
if \( h_1(\text{north}) = h_2(\text{north}) \), \( h_1(\text{south}) = h_2(\text{south}) \),
and \( h_1(\text{merid } a) = h_2(\text{merid } a) \) for all \( a : A \).
\end{theorem}

\subsection{Pushout}
The pushout (amalgamation) is a higher inductive type that constructs a type by
gluing two types \( A \) and \( B \) along a common type \( C \) via maps \( f : C \to A \)
and \( g : C \to B \). It is a fundamental construction in homotopy theory,
used to model cell attachment and cofibrant objects, generalizing
the topological notion of a pushout.

\begin{definition} (Formation).
For types \( A, B, C : \mathcal{U} \) and maps \( f : C \to A \), \( g : C \to B \),
there exists a pushout \( \sqcup(A,B,C,f,g) : \mathcal{U} \).
\end{definition}

\begin{definition} (Constructors).
The pushout is generated by the following higher inductive compositional structure:
\[
\sqcup :=
\begin{cases}
\text{po$_1$} : A \to \sqcup(A,B,C,f,g) \\
\text{po$_2$} : B \to \sqcup(A,B,C,f,g) \\
\text{po$_3$} : (c : C) \to \text{po$_1$}(f(c)) \equiv \text{po$_2$}(g(c))
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\sqcup$ (A B C: U) (f: C -> A) (g: C -> B) : U
 := inductive { po$_1$ (a: A)
              | po$_2$ (b: B)
              | po$_3$ (c: C) : po$_1$(f(c)) $\equiv$ po$_2$(g(c))
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a type \( D : \mathcal{U} \), maps \( u : A \to D \), \( v : B \to D \),
and a family of paths \( p : (c : C) \to u(f(c)) \equiv v(g(c)) \),
there exists a map \( \text{Ind}_\sqcup : \sqcup(A,B,C,f,g) \to D \), such that:
\[
\begin{cases}
\text{Ind}_\sqcup(\text{po$_1$}(a)) = u(a) \\
\text{Ind}_\sqcup(\text{po$_2$}(b)) = v(b) \\
\text{Ind}_\sqcup(\text{po$_3$}(c,i)) = p(c,i)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def PathOver (A B C : U) (f : C $\rightarrow$ A) (g : C $\rightarrow$ B)
    (D : $\sqcup$ A B C f g $\rightarrow$ U)
    (c : C) (u : D (po$_1$ (f c))) (v : D (po$_2$ (g c))) : U
 := PathP ($\lambda$ i, D (po$_3$ c i)) u v

def Ind$_\sqcup$ : (A B C : U) (f : C $\rightarrow$ A) (g : C $\rightarrow$ B)
    (D : $\sqcup$ A B C f g $\rightarrow$ U)
    (u : (a : A) $\rightarrow$ D (po$_1$ a))
    (v : (b : B) $\rightarrow$ D (po$_2$ b))
    (p : (c : C) $\rightarrow$ PathOver D c (u (f c)) (v (g c)))
  : (x : $\sqcup$ A B C f g) $\rightarrow$ D x
 := split { po$_1$ a $\rightarrow$ u a | po$_2$ b $\rightarrow$ v b | po$_3$ c @ i $\rightarrow$ p c @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation).
For \( x : \sqcup(A,B,C,f,g) \),
\[
\begin{cases}
\text{Ind$_\sqcup$}(\text{po$_1$}(a)) \equiv u(a) \\
\text{Ind$_\sqcup$}(\text{po$_2$}(b)) \equiv v(b) \\
\text{Ind$_\sqcup$}(\text{po$_3$}(c,i)) \equiv p(c,i)
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness).
Any two maps \( u, v : \sqcup(A,B,C,f,g) \to D \) are homotopic
if they agree on \( \text{po}_1 \), \( \text{po}_2 \), and \( \text{po}_3 \), i.e.,
if \( u(\text{po}_1(a)) = v(\text{po}_1(a)) \) for all \( a : A \), \( u(\text{po}_2(b)) = v(\text{po}_2(b)) \)
for all \( b : B \), and \( u(\text{po}_3(c)) = v(\text{po}_3(c)) \) for all \( c : C \).
\end{theorem}

\begin{example} (Cell Attachment)
The pushout models the attachment of an \( n \)-cell to a space \( X \).
Given \( f : S^{n-1} \to X \) and inclusion \( g : S^{n-1} \to D^n \),
the pushout \( \sqcup(X,D^n,S^{n-1},f,g) \) is
the space \( X \cup_f D^n \), attaching an \( n \)-disk to \( X \) along \( f \).
\[
\shorthandoff{"}
\begin{tikzcd}
S^{n-1} \arrow[r, "f"] \arrow[d, "g"] & X \arrow[d] \\
D^n \arrow[r] & X \cup_f D^n
\end{tikzcd}
\]
\end{example}

\subsection{Spheres}
Spheres are higher inductive types with higher-dimensional paths,
representing fundamental topological spaces.

\begin{definition} (Pointed n-Spheres)
The \( n \)-sphere \( S^n \) is defined recursively as a type in
the universe \( \mathcal{U} \) using general recursion over dimensions:
\[
\mathbb{S}^n :=
\begin{cases}
\text{point} : \mathbb{S}^n, \\
\text{surface} :\ <i_1,...i_n> [\ (i_1=0) \rightarrow \text{point}, (i_1=1) \rightarrow \text{point},\ ... \\
\hspace{3.47cm} (i_n=0) \rightarrow \text{point}, (i_n=1) \rightarrow \text{point}\ ]
\end{cases}
\]
\end{definition}

\begin{definition} (n-Spheres via Suspension)
The \( n \)-sphere \( S^n \) is defined recursively as a type in
the universe \( \mathcal{U} \) using general recursion over natural
numbers \( \mathbb{N} \). For each \( n \in \mathbb{N} \),
the type \( S^n : \mathcal{U} \) is defined as:
\[
\mathbb{S}^n :=
\begin{cases}
S^0 = \mathbf{2}, \\
S^{n+1} = \Sigma(S^n).
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def sphere : $\mathbb{N}$ $\to$ U := $\mathbb{N}\text{-iter}$ U $\mathbf{2}$ $\Sigma$
\end{lstlisting}
This iterative definition applies the suspension functor \( \Sigma \)
to the base type \( \mathbf{2} \) (0-sphere) \( n \) times to obtain \( S^n \).
\end{definition}

\begin{example} (Sphere as CW-Complex)
The \( n \)-sphere \( S^n \) can be constructed as a CW-complex with
one 0-cell and one \( n \)-cell:
\[
\begin{cases}
X_0 = \{ \text{base} \}, \text{ one point} \\
X_k = X_0 \text{ for } 0 < k < n, \text{ no additional cells} \\
X_n: \text{Attachment of an } n\text{-cell to } X_{n-1} = \{ \text{base} \} \text{ along } f : S^{n-1} \to \{ \text{base} \}
\end{cases}
\]
The constructor \( \text{cell} \) attaches the boundary of the \( n \)-cell
to the base point, yielding the type \( S^n \).
\end{example}

\newpage
\subsection{Hub and Spokes}
The hub and spokes construction \( \odot \) defines an \( n \)-truncation,
ensuring that the type has no non-trivial homotopy groups above
dimension \( n \). It models the type as a CW-complex with
a hub (central point) and spokes (paths to points).

\begin{definition} (Formation).
For types \( S, A : \mathcal{U} \), there exists a hub and spokes type \( \odot\ (S,A) : \mathcal{U} \).
\end{definition}

\begin{definition} (Constructors).
The hub and spokes type is freely generated by the following higher inductive compositional structure:
\[
\odot :=
\begin{cases}
\text{base} : A \to \odot\ (S,A) \\
\text{hub} : (S \to \odot\ (S,A)) \to \odot\ (S,A) \\
\text{spoke} : (f : S \to \odot\ (S,A)) \to (s : S) \to \text{hub}(f) \equiv f(s)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\odot$ (S A: U) : U
 := inductive { base (x: A)
              | hub (f: S -> $\odot$ S A)
              | spoke (f: S -> $\odot$ S A) (s:S) : hub f $\equiv$ f s
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a family of types \( P : \text{HubSpokes} \, S \, A \to \mathcal{U} \),
maps \( \text{pbase} : (x : A) \to P(\text{base} \, x) \),
\( \text{phub} : (f : S \to \text{HubSpokes} \, S \, A) \to P(\text{hub} \, f) \),
and a family of paths
\( \text{pspoke} : (f : S \to \text{HubSpokes} \, S \, A) \to (s : S) \to \text{PathP} \, (<i> P(\text{spoke} \, f \, s \, @ \, i)) \, (\text{phub} \, f) \, (P(f \, s)) \),
there exists a map \( \text{hubSpokesInd} : (z : \text{HubSpokes} \, S \, A) \to P(z) \), such that:
\[
\begin{cases}
\text{Ind}_\odot \, (\text{base} \, x) = \text{pbase} \, x \\
\text{Ind}_\odot \, (\text{hub} \, f) = \text{phub} \, f \\
\text{Ind}_\odot \, (\text{spoke} \, f \, s \, @ \, i) = \text{pspoke} \, f \, s \, @ \, i \\
\end{cases}
\]
\end{theorem}

\newpage
\subsection{Truncation}
\subsubsection*{Set Truncation}
\begin{definition} (Formation).
Set truncation (0-truncation), denoted \( \| A \|_0 \),
ensures that the type is a set, with homotopy groups vanishing above dimension 0.
\end{definition}

\begin{definition} (Constructors).
For \( A : \mathcal{U} \), \( \| A \|_0 : \mathcal{U} \) is defined by the following higher
inductive compositional structure:
\[
\| \_ \|_0 :=
\begin{cases}
\text{inc} : A \to \| A \|_0 \\
\text{squash} : (a, b : \| A \|_0) \to (p, q : a \equiv b) \to p \equiv q
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\|$_$\|_0$ (A: U) : U
 := inductive { inc (a: A)
              | squash (a b: $\|$A$\|_0$) (p q: Path ($\|$A$\|_0$) a b)
                <i j> [ (i = 0) -> p @ j, (i = 1) -> q @ j,
                        (j = 0) -> a,     (j = 1) -> b ]
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination \( \| A \|_0 \))
For a set \( B : \mathcal{U} \) (i.e., \( \text{isSet}(B) \)), and a map \( f : A \to B \),
there exists \( \text{setTruncRec} : \| A \|_0 \to B \), such that \( \text{Ind}_{\|A\|_0}(\text{inc}(a)) = f(a) \).
\end{theorem}

\subsubsection*{Groupoid Truncation}
\begin{definition} (Formation).
Groupoid truncation (1-truncation), denoted \( \| A \|_1 \), ensures that
the type is a 1-groupoid, with homotopy groups vanishing above dimension 1.
\end{definition}

\begin{definition} (Constructors).
For \( A : \mathcal{U} \), \( \| A \|_1 : \mathcal{U} \) is defined by the following higher
inductive compositional structure:
\[
\| \_ \|_1 :=
\begin{cases}
\text{inc} : A \to \| A \|_1 \\
\text{squash} : (a, b : \| A \|_1) \to (p, q : a \equiv b) \to (r, s : p \equiv q) \to r \equiv s
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\|$_$\|_1$ (A: U) : U
 := inductive { inc (a: A)
              | squash (a b: $\|$A$\|_1$) (p q: Path ($\|$A$\|_1$) a b)
                (r s: Path (Path ($\|$A$\|_1$) a b) p q) <i j k>
                [ (i = 0) -> r @ j @ k, (i = 1) -> s @ j @ k,
                  (j = 0) -> p @ k,     (j = 1) -> q @ k,
                  (k = 0) -> a,         (k = 1) -> b ]
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination \( \| A \|_1 \))
For a 1-groupoid \( B : \mathcal{U} \) (i.e., \( \text{isGroupoid}(B) \)),
and a map \( f : A \to B \), there exists \( \text{Ind}_{\|A\|_1} : \|A\|_1 \to B \),
such that \( \text{Ind}_{\|A\|_1}(\text{inc}(a)) = f(a) \).
\end{theorem}

\newpage
\subsection{Quotients}
\subsubsection*{Set Quotient Spaces}
Quotient spaces are a powerful computational tool in type theory, embedded
in the core of Lean.
\begin{definition} (Formation).
Set quotient spaces construct a type \( A \), quotiented by
a relation \( R : A \to A \to \mathcal{U} \), ensuring that the result is a set.
\end{definition}

\begin{definition} (Constructors).
For a type \( A : \mathcal{U} \) and a relation \( R : A \to A \to \mathcal{U} \),
the set quotient space \( A / R : \mathcal{U} \) is freely generated by the following
higher inductive compositional structure:
\[
A / R :=
\begin{cases}
\text{quot} : A \to A / R \\
\text{ident} : (a, b : A) \to R(a,b) \to \text{quot}(a) \equiv \text{quot}(b) \\
\text{trunc} : (a, b : A / R) \to (p, q : a \equiv b) \to p \equiv q
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def / (A: U) (R: A -> A -> U) : U
  := inductive { quot (a: A)
               | ident (a b: A) (r: R a b) : quot(a) $\equiv$ quot(b)
               | trunc (a b : / A R) (p q : Path (/ A R) a b)
                 <i j> [ (i = 0) -> p @ j , (i = 1) -> q @ j ,
                         (j = 0) -> a ,     (j = 1) -> b ]
               }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a family of types \( B : A/R \to \mathcal{U} \) with \( \text{isSet}(B x) \),
and maps \( f : (x : A) \to B(\text{quot}(x)) \),
\( g : (a, b : A) \to (r : R(a,b)) \to \text{PathP} (<i> B(\text{ident}(a,b,r)\ @\ i)) (f(a)) (f(b)) \),
there exists \( \text{Ind}_{A/R} : \Pi (x: A/R), B(x) \), such that \( \text{Ind}_{A/R}(\text{quot}(a)) = f(a) \).
\end{theorem}

\subsubsection*{Groupoid Quotient Spaces}
\begin{definition} (Formation).
Groupoid quotient spaces extend set quotient spaces to produce a 1-groupoid,
including constructors for higher paths. Groupoid quotient spaces
construct a type \( A \), quotiented by a relation \( R : A \to A \to \mathcal{U} \),
ensuring that the result is a groupoid.
\end{definition}

\begin{definition} (Constructors).
For a type \( A : \mathcal{U} \) and a relation \( R : A \to A \to \mathcal{U} \),
the groupoid quotient space \( A // R : \mathcal{U} \) includes
constructors for points, paths, and higher paths, ensuring a 1-groupoid structure.
\end{definition}

\newpage
\subsection{Wedge}
The wedge of two pointed types \( A \) and \( B \), denoted \( A \vee B \),
is a higher inductive type representing the union of \( A \)
and \( B \) with identified base points. Topologically,
it corresponds to \( A \times \{ y_0 \} \cup \{ x_0 \} \times B \),
where \( x_0 \) and \( y_0 \) are the base points of \( A \) and \( B \), respectively.

\begin{definition} (Formation).
For pointed types \( A, B : \text{pointed} \), the wedge \( A \vee B : \mathcal{U} \).
\end{definition}

\begin{definition} (Constructors).
The wedge is generated by the following higher inductive compositional structure:
\[
\vee :=
\begin{cases}
\text{winl} : A.1 \to A \vee B \\
\text{winr} : B.1 \to A \vee B \\
\text{wglue} : \text{winl} (A.2) \equiv \text{winr}(B.2)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\vee$ (A : pointed) (B : pointed) : U
 := inductive { winl (a : A.1)
              | winr (b : B.1)
              | wglue : winl(A.2) $\equiv$ winr(B.2)
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a type \( P : A \vee B \mathcal{U} \), maps \( f : A.1 \to C \),
\( g : B.1 \to C \), and a path \( p : \text{PathOverlue}(P,f(A.2),g (B.2)) \),
there exists a map \( \text{Ind}_\vee : A \vee B \to C \), such that:
\[
\begin{cases}
\text{Ind}(\text{winl}(a)) = f(a) \\
\text{Ind}(\text{winr}(b)) = g(b) \\
\text{Ind}(\text{wglue}(x)) = p(x)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def PathOverGlue : (P : A $\vee$ B → U)
    (p : P (inl (A.2))) (q : P (inr (B.2))) : U
 := PathP (λ i → P (wglue i)) p q

def Ind$_\vee$ (A B : pointed) (C : U) (f : A.1 -> C) (g : B.1 -> C)
    (p : Path C (f A.2) (g B.2))
  : A $\vee$ B -> C
 := split { winl a -> f a | winr b -> g b | wglue @ x -> p @ x }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation).
For \( z : \text{Wedge } A B \),
\[
\begin{cases}
\text{Ind}_\vee(\text{winl } a) \equiv f(a) \\
\text{Ind}_\vee(\text{winr } b) \equiv g(b) \\
\text{Ind}_\vee(\text{wglue } @ \, x) \equiv p \, @ \, x
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness).
Any two maps \( h_1, h_2 : \text{Wedge } A B \to C \) are homotopic if
they agree on \( \text{winl} \), \( \text{winr} \), and \( \text{wglue} \),
i.e., if \( h_1(\text{winl } a) = h_2(\text{winl } a) \) for
all \( a : A.1 \), \( h_1(\text{winr } b) = h_2(\text{winr } b) \) for
all \( b : B.1 \), and \( h_1(\text{wglue}) = h_2(\text{wglue}) \).
\end{theorem}

\newpage
\subsection{Smash Product}
The smash product of two pointed types \( A \) and \( B \), denoted \( A \wedge B \),
is a higher inductive type that quotients the product \( A \times B \) by
the pushout \( A \sqcup B \). It represents the space \( A \times B / (A \times \{ y_0 \} \cup \{ x_0 \} \times B) \),
collapsing the wedge to a single point.

\begin{definition} (Formation).
For pointed types \( A, B : \text{pointed} \), the smash product \( A \wedge B : \mathcal{U} \).
\end{definition}

\begin{definition} (Constructors).
The smash product is generated by the following higher inductive compositional structure:
\[
A \wedge B :=
\begin{cases}
\text{basel} : A \wedge B \\
\text{baser} : A \wedge B \\
\text{proj} (x: A.1) (y: B.1) : A \wedge B \\
\text{gluel} (a: A.2) : \text{proj}(a,B.2) \equiv \text{basel} \\
\text{gluer} (b: B.2) : \text{proj}(A.2,b) \equiv \text{baser} \\
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\wedge$ (A : pointed) (B : pointed) : U
 := inductive { basel
              | baser
              | proj (a : A.1) (b : B.1)
              | gluel (a : A.2) : proj(a,B.2) $\equiv$ basel
              | gluer (a : B.2) : proj(A.2,b) $\equiv$ baser
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a family of types \( P : \text{Smash } A \, B \to \mathcal{U} \),
points \( \text{pbasel} : P(\text{basel}) \),
         \( \text{pbaser} : P(\text{baser}) \), maps
\( \text{pproj} : (x : A.1) \to (y : B.1) \to P \, (\text{proj} \, x \, y) \),
and a family of paths
\( \text{pgluel} : (a : A.1) \to \text{pproj}(a,B.2) \equiv \text{pbasel} \),
\( \text{pgluer} : (b : B.1) \to \text{pproj}(A.2,b) \equiv \text{pbaser} \),
there exists a map \( \text{Ind}_\wedge : (z : A \wedge B) \to P(z) \), such that:
\[
\begin{cases}
\text{Ind}_\wedge \, (\text{basel}) = \text{pbasel} \\
\text{Ind}_\wedge \, (\text{baser}) = \text{pbaser} \\
\text{Ind}_\wedge \, (\text{proj} \, x \, y) = \text{pproj} \, x \, y \\
\text{Ind}_\wedge \, (\text{gluel} \, a \, @ \, i) = \text{pgluel} \, a \, @ \, i \\
\text{Ind}_\wedge \, (\text{gluer} \, b \, @ \, i) = \text{pgluer} \, b \, @ \, i \\
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def Ind$_\wedge$ (A B : pointed) (P : A $\wedge$ B -> U)
    (pbasel : P basel) (pbaser : P baser)
    (pproj : (x : A.1) -> (y : B.1) -> P (proj x y))
    (pgluel : (a : A.1) -> PathP (<i> P (gluel a @ i)) (pproj a B.2) pbasel)
    (pgluer : (b : B.1) -> PathP (<i> P (gluer b @ i)) (pproj A.2 b) pbaser)
  : (z : A $\wedge$ B) -> P z
 := split { basel -> pbasel | baser -> pbaser | proj x y -> pproj x y
          | gluel a @ i -> pgluel a @ i | gluer b @ i -> pgluer b @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation).
For a family of types \( P : A \wedge B \to \mathcal{U} \),
points \( \text{pbasel} : P(\text{basel}) \),
\( \text{pbaser} : P(\text{baser}) \),
map \( \text{pproj} : (x : A.1) \to (y : B.1) \to P(\text{proj} \, x \, y) \),
and families of paths
\( \text{pgluel} : (a : A.1) \to \text{PathP} \, (<i> P(\text{gluel} \, a \, @ \, i)) \, (\text{pproj} \, a \, B.2) \, \text{pbasel} \),
\( \text{pgluer} : (b : B.1) \to \text{PathP} \, (<i> P(\text{gluer} \, b \, @ \, i)) \, (\text{pproj} \, A.2 \, b) \, \text{pbaser} \),
the map \( \text{Ind}_\wedge : (z : A \wedge B) \to P(z) \) satisfies all equations for all variants
of the predicate \( P \):
\[
\begin{cases}
\text{Ind}_\wedge \, (\text{basel}) \equiv \text{pbasel} \\
\text{Ind}_\wedge \, (\text{baser}) \equiv \text{pbaser} \\
\text{Ind}_\wedge \, (\text{proj} \, x \, y) \equiv \text{pproj} \, x \, y \\
\text{Ind}_\wedge \, (\text{gluel} \, a \, @ \, i) \equiv \text{pgluel} \, a \, @ \, i \\
\text{Ind}_\wedge \, (\text{gluer} \, b \, @ \, i) \equiv \text{pgluer} \, b \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness).
For a family of types \( P : A \wedge B \to \mathcal{U} \),
and maps \( h_1, h_2 : (z : A \wedge B) \to P(z) \),
if there exist paths
\( e_{\text{basel}} : h_1(\text{basel}) \equiv h_2(\text{basel}) \),
\( e_{\text{baser}} : h_1(\text{baser}) \equiv h_2(\text{baser}) \),
\( e_{\text{proj}} : (x : A.1) \to (y : B.1) \to h_1(\text{proj} \, x \, y) \equiv h_2(\text{proj} \, x \, y) \),
\( e_{\text{gluel}} : (a : A.1) \to \text{PathP} \, (<i> h_1(\text{gluel} \, a \, @ \, i) \equiv h_2(\text{gluel} \, a \, @ \, i)) \, (e_{\text{proj}} \, a \, B.2) \, e_{\text{basel}} \),
\( e_{\text{gluer}} : (b : B.1) \to \text{PathP} \, (<i> h_1(\text{gluer} \, b \, @ \, i) \equiv h_2(\text{gluer} \, b \, @ \, i)) \, (e_{\text{proj}} \, A.2 \, b) \, e_{\text{baser}} \),
then \( h_1 \equiv h_2 \), i.e., there exists a path \( (z : A \wedge B) \to h_1(z) \equiv h_2(z) \).
\end{theorem}

\newpage
\subsection{Join}
The join of two types \( A \) and \( B \), denoted \( A \Join B \),
is a higher inductive type that constructs a type by
joining each point of \( A \) to each point of \( B \) via a path.
Topologically, it corresponds to the join of spaces, forming
a space that interpolates between \( A \) and \( B \).

\begin{definition} (Formation).
For types \( A, B : \mathcal{U} \), the join \( A * B : \mathcal{U} \).
\end{definition}

\begin{definition} (Constructors).
The join is generated by the following higher inductive compositional structure:
\[
A \Join B :=
\begin{cases}
\text{joinl} : A \to A \Join B \\
\text{joinr} : B \to A \Join B \\
\text{join} (a : A) (b : B) : \text{joinl}(a) \equiv \text{joinr}(b)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\Join$ (A : U) (B : U) : U
 := inductive { joinl (a: A)
              | joinr (b: B)
              | join (a: A) (b: B) : joinl(a) $\equiv$ joinr(b)
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a type \( C : \mathcal{U} \), maps \( f : A \to C \), \( g : B \to C \),
and a family of paths \( h : (a : A) \to (b : B) \to f(a) \equiv g(b) \),
there exists a map \( \text{Ind}_\Join : A \Join B \to C \), such that:
\[
\begin{cases}
\text{Ind}_\Join(\text{joinl}(a)) = f(a) \\
\text{Ind}_\Join(\text{joinr}(b)) = g(b) \\
\text{Ind}_\Join(\text{join}(a,b,i)) = h(a,b,i) \\
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def Ind$_\Join$ (A B C : U) (f : A -> C) (g : B -> C)
    (h : (a : A) -> (b : B) -> Path C (f a) (g b))
  : A $\Join$ B -> C
 := split { joinl a -> f a
          | joinr b -> g b
          | join a b @ i -> h a b @ i
          }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation).
For all \( z : A \Join B \), and predicate \( P \), the rules of \( \text{Ind}_\Join \) hold for all parameters of the predicate \( P \).
\end{theorem}

\begin{theorem} (Uniqueness).
Any two maps \( h_1, h_2 : A \Join B \to C \) are homotopic
if they agree on \( \text{joinl} \), \( \text{joinr} \), and \( \text{join} \).
\end{theorem}

\newpage
\subsection{Colimit}
Colimits construct the limit of a sequence of types, connected by maps,
e.g., propositional truncations.

\begin{definition} (Colimit)
For a sequence of types \( A : \text{nat} \to \mathcal{U} \) and
maps \( f : (n : \mathbb{N}) \to A n \to A(\text{succ}(n)) \),
the colimit type \( \text{colimit}(A,f) : \mathcal{U} \).
\[
\text{colim} :=
\begin{cases}
\text{ix} : (n : \text{nat}) \to A n \to \text{colimit}(A,f) \\
\text{gx} : (n : \text{nat}) \to (a : A(n)) \to \text{ix} (\text{succ}(n),f(n,a)) \equiv \text{ix}(n,a)
\end{cases}
\]
\begin{lstlisting}
def colimit (A : nat -> U) (f : (n : nat) -> A n -> A (succ n)) : U
 := inductive { ix (n : nat) (x: A n)
              | gx (n : nat) (a: A n)
                <i> [ (i=0) -> ix (succ n) (f n a),
                      (i=1) -> ix n a ]
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination \( \text{colimit} \))
For a type \( P : \text{colimit } A f \to \mathcal{U} \),
with \( p : (n : \text{nat}) \to (x : A n) \to P(\text{ix}(n, x)) \)
and \( q : (n : \text{nat}) \to (a : A n) \to \text{PathP} (\langle i \rangle P(\text{gx}(n, a) @ i)) (p (\text{succ } n) (f n a)) (p n a) \),
there exists \( i : \Pi_{x:\text{colimit } A f} P(x) \), such that \( i(\text{ix}(n, x)) = p n x \).
\end{theorem}

\newpage
\subsection{Coequalizers}
\subsubsection*{Coequalizer}
The coequalizer of two maps \( f, g : A \to B \) is a higher inductive
type (HIT) that constructs a type consisting of elements in \( B \),
where \( f \) and \( g \) agree, along with paths ensuring this equality.
It is a fundamental construction in homotopy theory,
capturing the subspace of \( B \) where \( f(a) = g(a) \) for \( a : A \).

\begin{definition} (Formation).
For types \( A, B : \mathcal{U} \) and maps \( f, g : A \to B \),
the coequalizer \( \text{coeq } A B f g : \mathcal{U} \).
\end{definition}

\begin{definition} (Constructors).
The coequalizer is generated by the following higher inductive compositional structure:
\[
\text{Coeq} :=
\begin{cases}
\text{inC} : B \to \text{Coeq}(A,B,f,g) \\
\text{glueC} : (a : A) \to \text{inC}(f(a)) \equiv \text{inC}(g(a))
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def Coeq (A B: U) (f g: A -> B) : U
 := inductive { inC (b: B)
              | glueC (a: A) : inC (f a) $\equiv$ inC (g a)
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a type \( C : \mathcal{U} \), map \( h : B \to C \), and a family of paths \( y : (x : A) \to \text{Path}_C (h (f x), h (g x)) \), there exists a map \( \text{coequRec} : \text{coeq } A B f g \to C \), such that:
\[
\begin{cases}
\text{coequRec}(\text{inC}(x)) = h(x) \\
\text{coequRec}(\text{glueC}(x,i)) = y(x,i)
\end{cases}
\]
\begin{lstlisting}
def coequRec (A B C : U) (f g : A -> B) (h: B -> C)
    (y: (x : A) -> Path C (h (f x)) (h (g x)))
  : (z : coeq A B f g) -> C
 := split { inC x -> h x | glueC x @ i -> y x @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation).
For \( z : \text{coeq } A B f g \),
\[
\begin{cases}
\text{coequRec}(\text{inC } x) \equiv h(x) \\
\text{coequRec}(\text{glueC } x \, @ \, i) \equiv y(x) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness).
Any two maps \( h_1, h_2 : \text{coeq } A B f g \to C \) are homotopic
if they agree on \( \text{inC} \) and \( \text{glueC} \), i.e.,
if \( h_1(\text{inC } x) = h_2(\text{inC } x) \) for
all \( x : B \) and \( h_1(\text{glueC } a) = h_2(\text{glueC } a) \) for all \( a : A \).
\end{theorem}

\begin{example} (Coequalizer as Subspace)
The coequalizer \( \text{coeq } A B f g \) represents the subspace
of \( B \), where \( f(a) = g(a) \). For example, if \( A = B = \mathbb{R} \)
and \( f(x) = x^2 \), \( g(x) = x \), the coequalizer captures the points
where \( x^2 = x \), i.e., \( \{0, 1\} \).
\end{example}

\newpage
\subsubsection*{Path Coequalizer}
The path coequalizer is a higher inductive type that generalizes
the coequalizer to handle pairs of paths in \( B \). Given
a map \( p : A \to (b_1, b_2 : B) \times (\text{Path}_B (b_1, b_2)) \times (\text{Path}_B (b_1, b_2)) \),
it constructs a type where elements of \( A \) generate pairs
of paths between points in \( B \), with paths connecting
the endpoints of these paths.

\begin{definition} (Formation).
For types \( A, B : \mathcal{U} \) and a map \( p : A \to (b_1, b_2 : B) \times (b_1 \equiv b_2) \times (b_1 \equiv b_2) \),
there exists a path coequalizer \( \text{Coeq}_\equiv(A,B,p) : \mathcal{U} \).
\end{definition}

\begin{definition} (Constructors).
The path coequalizer is generated by the following higher inductive compositional structure:
\[
\text{Coequ}_\equiv :=
\begin{cases}
\text{inP} : B \to \text{Coeq}_\equiv(A,B,p) \\
\text{glueP} : (a : A) \to \text{inP}(p(a).2.2.1 @ 0) \equiv \text{inP}(p(a).2.2.2 @ 1)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
data Coeq-$\equiv$ (A B: U) (p : A -> $\Sigma$ (b1 b2: B), b1 $\equiv$ b2 $\times$ b1 $\equiv$ b2)
   = inP (b: B)
   | glueP (a:A) <i> [(i=0) -> inP ((p a).2.2.1 @ 0),
                      (i=1) -> inP ((p a).2.2.2 @ 1) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination).
For a type \( C : \mathcal{U} \), map \( h : B \to C \),
and a family of paths \( y : (a : A) \to h(p(a).2.2.1  @ 0) \equiv h(p(a).2.2.2 @ 1) \),
there exists a map \( \text{Ind-Coequ}_\equiv : \text{Coeq}_\equiv(A,B,p) \to C \), such that:
\[
\begin{cases}
\text{coequPRec}(\text{inP}(b)) = h(b) \\
\text{coequPRec}(\text{glueP}(a,i)) = y(a,i)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def Ind-Coequ$_\equiv$ (A B C : U)
    (p : A -> $\Sigma$ (b1 b2: B) (x: Path B b1 b2), Path B b1 b2)
    (h: B -> C) (y: (a : A) -> Path C (h (((p a).2.2.1) @ 0)) (h (((p a).2.2.2) @ 1)))
  : (z : coeqP A B p) -> C
 := split { inP b -> h b | glueP a @ i -> y a @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation).
For \( z : \text{coeqP } A B p \),
\[
\begin{cases}
\text{coequPRec}(\text{inP } b) \equiv h(b) \\
\text{coequPRec}(\text{glueP } a \, @ \, i) \equiv y(a) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness).
Any two maps \( h_1, h_2 : \text{coeqP } A B p \to C \) are homotopic
if they agree on \( \text{inP} \) and \( \text{glueP} \), i.e.,
if \( h_1(\text{inP } b) = h_2(\text{inP } b) \) for all \( b : B \)
and \( h_1(\text{glueP } a) = h_2(\text{glueP } a) \) for all \( a : A \).
\end{theorem}

\newpage
\subsection{K(G,n)}
Eilenberg-MacLane spaces \( K(G,n) \) have a single non-trivial
homotopy group \( \pi_n(K(G,n)) = G \). They are defined using truncations and suspensions.

\begin{definition} (K(G,n))
For an abelian group \( G : \text{abgroup} \), the type \( KGn(G) : \text{nat} \to \mathcal{U} \).
\[
K(G,n) :=
\begin{cases}
n = 0 \leadsto \text{discreteTopology}(G) \\
n \geq 1 \leadsto \|\Sigma^{n-1}(K1'(G.1,G.2.1))\|_{n}
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def KGn (G: abgroup) : $\mathbf{N}$ -> U
 := split { zero -> discreteTopology G
          | succ n -> nTrunc ($\Sigma$ (K1' (G.1,G.2.1)) n) (succ n)
          }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination \( KGn \))
For \( n \geq 1 \), a type \( B : \mathcal{U} \) with \( \text{isNGroupoid}(B, \text{succ } n) \),
and a map \( f : \text{suspension}(K1' G) \to B \), there exists
\( \text{rec}_{KGn} : KGn G (\text{succ } n) \to B \),
defined via \( \text{nTruncRec} \).
\end{theorem}

\newpage
\subsection{Localization}
Localization constructs an \( F \)-local type from a type \( X \),
with respect to a family of maps \( F_A : S(a) \to T(a) \).

\begin{definition} (Localization Modality)
For a family of maps \( F_A : S(a) \to T(a) \),
the \( F \)-localization \( L^{AST}_F(X) : \mathcal{U} \).
\[
L^A_F(X) :=
\begin{cases}
\text{center} : X \to L_{F_A}(X) \\
\text{ext} (a : A) \to (S(a) \to L_{F_A}(X)) : T(a) \to L_{F_A}(X) \\
\text{isExt} (a : A) (f : S(a) \to L_{F_A}(X)) \to (s : S(a)) : \text{ext}(a,f,F(a,s)) \equiv f(s) \\
\text{extEq} (a : A) (g, h : T(a) \to L_{F_A}(X)) \\
\indent (p : (s : S(a)) \to g(F(a,s)) \equiv h(F(a,s))) \\
\indent (t : T(a)) : g(t) \equiv h(t) \\
\text{isExtEq} : (a : A) (g, h : T(a) \to L_{F_A}(X)) \\
\indent  (p : (s : S(a)) \to g(F(a,s)) \equiv h(F(a,s))) \\
\indent (s : S(a)) : \text{extEq}(a,g,h,p,F(a,s) \equiv p(s)
\end{cases}
\]
\begin{lstlisting}
data Localize (A X: U) (S T: A -> U) (F : (x:A) -> S x -> T x)
   = center (x: X)
   | ext (a: A) (f: S a -> Localize A X S T F) (t: T a)
   | isExt (a: A) (f: S a -> Localize A X S T F) (s: S a) <i>
     [ (i=0) -> ext a f (F a s) , (i=1) -> f s ]
   | extEq (a: A) (g h: T a -> Localize A X S T F)
     (p: (s : S a) -> Path (Localize A X S T F) (g (F a s)) (h (F a s)))
     (t : T a) <i> [ (i=0) -> g t , (i=1) -> h t ]
   | isExtEq (a: A) (g h : T a -> Localize A X S T F)
     (p: (s : S a) -> Path (T a -> Localize A X S T F) (g (F a s)) (h (F a s)))
     (s : S a) <i> [ (i=0) -> extEq a g h p (F a s) , (i=1) -> p s ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Localization Induction)
For any \( P : \Pi_{X:U} L_{F_A}(X) \to U \) with \( \{n, r, s\} \), satisfying coherence conditions,
there exists \( i : \Pi_{x:L_{F_A}(X)} P(x) \), such that \( i \cdot \text{center}_X = n \).
\end{theorem}

\subsection*{Conclusion}
HITs directly encode CW-complexes in HoTT, bridging topology and type theory.
They enable the analysis and manipulation of homotopical types.

\section{Висновки}

