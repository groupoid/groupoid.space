\chapter{Огляд засобів формальної верифікації}
\epigraph{Присвячується вчителям нідерландської школи}{Ніколасу де Брейну, \\ Хенку Барендрегту \\ та Барту Якобсу}

Перший розділ закладає теоретичний фундамент, оглядаючи сучасний
стан формальної верифікації та визначаючи місце пропонованої
уніфікованої системи формальних мов у цій галузі.

Розглядаються ключові концепції верифікації та валідації, формальні
специфікації, методи верифікації, а також середовища виконання,
зосереджуючись на їхньому зв’язку з нашою метою: інтеграцією програмування,
доведення теорем і формальної філософії. Розділ завершується аналізом
мовних елементів, кластеризованих за теорією типів Мартіна-Льофа,
що слугують основою для подальших розробок.

\section*{Вступне слово}
Формальна верифікація як дисципліна бере початок із робіт Ніколаса де Брейна,
чия система AUTOMATH (1967) стала першим механізмом комп’ютеризованого
доведення теорем у фіброваній моделі. Хенк Барендрегт розвинув цю ідею,
створивши лямбда-куб — класифікацію типових систем, де найвища
вершина (Calculus of Constructions, CoC) уможливила вищі формальні мови.

У дисертації ми використовуємо CoC як базис для теоретичного ядра, доповнюючи його
вищими мовами для поглинання машинною верифікацією усієї доступної математики.
Система окрім вищих мов містить обчислювальне середовище, яке побудовано на
інтерпретаторах нетипізованого лямбда числення і числення процесів, а також
на мовах системи Жирара для програмування цього середовища.

\section{Формальна верифікація та валідація}
Для унеможливлення помилок на виробництві застосовуються різні
методи формальної верифікації. Формальна верифікація — доказ, або заперечення
відповідності системи у відношенні до певної формальної специфікації або характеристики,
із використанням формальних методів математики.

Дамо основні визначення згідно з міжнародними нормами (IEEE, ANSI)\footnote{IEEE Std 1012-2016  --- V\&V Software verification and validation} та у відповідності до вимог
Європейського Аерокосмічного Агенства\footnote{ESA PSS-05-10 1-1 1995 -- Guide to software verification and validation}.
У відповідності до промислового процессу розробки, верифікація та валідація програмного
забезпечення є частиною цього процесу. Програмне забезпечення перевіряється на
відповідність функціональних властивостей згідно вимог.

Процес валідації включає в себе перегляд (code review),
тестування (модульне, інтеграційне, властивостей), перевірка моделей, аудит,
увесь комплекс необхідний для доведення, що продукт відповідає вимогам
висунутим при розробці. Такі вимоги формуються на початковому етапі,
результатом якого є формальна специфікація.

\section{Формальна специфікація}
Для спрощення процесу верифікації та валідації
застосовується математична техніка формалізації постановки задачі --- формальна специфікація.
Формальна специфікація --- це математична модель, створена для опису систем,
визначення їх основних властивостей, та інструментарій для перевірки
властивостй (формальної верифікаціїї) цих систем, побудованих на основі формальної специфікації.

Існують два фундаментальні підходи до формальних специфікацій:
1) Аглебраїчний підхід, де система описується в термінах операцій, та відношень між ними (або аналітичний метод);
2) Модельно-орієнтований підхід, де модель створена конструктивними побудовами,
   як то на базі теорії множин, чи інкаше, а системні операції визначаються тим,
   як вони змінюють стан системи (конструктивний, або синтетичний метод).

\subsection{Програмне забезпечення}
Найбільш стандартизована та прийнята в області формальної верификації --- це нотація
Z\footnote{ISO/IEC 13568:2002 --- Z formal specification notation} (Spivey, 1992), приклад
модельно-орієнтованої мови. Назавана мова на честь Ернеста Цермело, роботи якого мали вплив на
фундамент математики та аксіоматику теорії множин. Саме теорія множин, та логіка предикатів
першого порядку є теорією мови Z. Тут також заслуговують уваги сесійні типи
Кохея Хонди\footnote{\url{ http://mrg.doc.ic.ac.uk/kohei/}}, які дозволяють
формалізувати протоколи на рівні вбудованої теорії типів.

Інша відома мова формальної специфікації як стандарт
для моделювання розподілених систем, таких як телефонні мережі та протоколи, це
LOTOS\footnote{ISO 8807:1989 --- LOTOS --- A formal description technique based
on the temporal ordering of observational behaviour} (Bolognesi, Brinksma, 1987),
як приклад алгебраїчного підходу.
Ця мова побудована на темпоральних логіках та поведінках залежниих від спостережень.
Інші темпоральні мови специфікацій, які можна відзначити тут --- це TLA+\footnote{The
TLA+ Language and Tools for Hardware and Software Engineers}, CSP (Hoare, 1985),
CCS\footnote{J.C.M. Baeten. A Brief History of Process Algebra.} (Milner, 1971), Actor Model, BPMN, etc.

\subsection{Математичні компоненти}
Перші системи комп'ютерної алгебри були розроблені ще під PDP-6 та PDP-10,
такі як MATHLAB (МІТ), інші ранні системи:
MACSYMA (Джоел Мозес),
SCRATCHPAD (Ричард Дженкс, IBM),
REDUCE (Тони Хирн),
SAC-I, пізніше SACLIB (Джорж Коллінз),
MUMATH для микропроцессоров (Девід Стоутмаєр) та пізніше DERIVE.
Сучасні системи комп'ютерної алгебри:
AXIOM послідовних SCRATCHPAD (NAG),
MAGMA (Джон Кеннон, Сіднейський університет),
MUPAD (Бенно Фуксштейнер, університет міста Падерборн).
GAP (Joachim Neubüser, RWTH Aachen, Kaiserslautern).

\section{Формальні методи верифікації}
Можна виділити три підходи до верифікації:
1) спеціалізовані верифікатори моделей, або системи моделювання;
2) алгебраїчні мови для синтетичних моделей і глибокого вбудовування;
3) системи автоматичного доведення теорем і синтезу програм (теорем).

\subsection{Спеціалізовані системи моделювання}
Перший застосовується де вже є певна програма написана на конкретній мові
програмування і потрібно довести ізоморфність цієї програми до доведеної моделі.
Ця задача вирішується у побудові теоретичної моделі для певної мови програмування,
потім програма на цій мові переводиться у цю теоретичну модель і доводить
ізоморфізм цієї програми у побудованій моделі до доведеної моделі.

Приклади таких систем та підходів:
1) VST (CompCert, сертифікація C програм);
2) NuPRL (Cornell University, розподілені системи, залежні типи);
3) TLA+ (Microsoft Research, Леслі Лампорт);
4) Twelf (для верифікації мов програмування);
5) SystemVerilog (для програмного та апаратного забезпечення).

\subsection{Мови з залежними типами та індукцією}
Другий підхід можна назвати підходом вбудованих мов.
Компілятор основої мови перевіряє модель закодовану у ній же. Можливо моделювання
логік вищого порядку, лінійних логік, модальних логік, категорних та гомотопічних логік.
Процес специфікації та верифікації відбувається в основній мові, а сертифіковані програми
автоматично екстрагуються в довільні мови.

Приклади таких систем:
1) Coq побудована на мові OCaml від науково-дослідного інституту Франції INRIA;
2) Agda побудовані на мові Haskell від шведського інституту технологій Чалмерс;
3) Lean побудована на мові C++ від Microsoft Research та Універсистету Каргені-Мелона;
4) F* -- окремий проект Microsoft Research.

Зараз другий підхід доповнився гомотопічними мовами, де верифікація відбувається
з використанням гомотопічної логіки.

Приклади гомотопічних систем:
1) cubicaltt --- \footnote{Cyril Cohen, Thierry Coquand, Simon Huber, Anders M{\"{o}}rtberg. Cubical Type Theory: a constructive interpretation of the univalence axiom. 2015. \url{https://5ht.co/ctt.pdf}}{CCHM} імплементація авторства Андерса Мортберга кубічної теорії типів Сімона Губера;
2) yacctt --- ще одна декартова кубічна теорія \footnote{Carlo Angiuli, Brunerie, Coquand, Kuen-Bang Hou (Favonia), Robert Harper, Dan Licata. Cartesian Cubical Type Theory. 2017. \url{https://5ht.co/cctt.pdf}}{ABCFHL};
3) Agda --cubical --- вбудований кубічний тайпчекер в Агду;
4) Lean --- Lean також має вбудований кубічний тайпчекер;
5) RedPRL --- кубічна імплементація декартової кубічної теорії ABCFHL;
6) Anders --- кубічне розширення MLTT-80 з двома видами всесвітів та Im модальністю.

\subsection{Системи автоматичного доведення теорем}
Третій підхід полягає в синтезі конструктивного доведення
для формальної специфікації. Це може бути зроблено за
допомогою асистентів доведення теорем, таких як HOL/Isabell, Coq, ACL2,
або систем розв'язку задач виконуваності формул в теоріях (Satisfiability
Modulo Theories, SMT).

Перші спроби пошуку формального фундаменту для теорії обчислень були покладені
Алонзо Черчем та Хаскелем Каррі у 30-х роках 20-го століття. Було запропоноване
лямбда числення як апарат який може замінити класичну теорію множин та її аксіоматику,
пропонуючи при цьому обчислювальну семантику. Пізніше в 1958, ця мова була втілена
у вигляді LISP лауреатом премії Тюрінга Джоном МакКарті, який працював в Прінстоні.
Ця мова була побудована на конструктивних примітивах, які пізніше виявилися компонентами
індуктивних конструкцій та були формалізовані за допомогою
теорії категорій Вільяма Лавіра. Окрім LISP, нетипізоване лямбда числення
маніфестується у такі мови як Erlang, JavaScript, Python.
До цих пір нетипізоване лямбда числення є одною з мов у яку робиться
конвертація доведених программ (екстракція).

Історіографія фібраційних математичних пруверів бере свій початок з Нідерландів.
Перший математичний прувер AUTOMATH (і його модифікації AUT-68 та AUT-QE),
який був написаний для комп'ютерів розроблявся під керівництвом де Брейна у 1967 році.
У цьому прувері був квантор загальності та лямбда функція, таким чином, це був перший прувер,
побудований на засадах ізоморфізма Каррі-Говарда-Ламбека. В рамках проєкту AXIO/1
була розроблена мова $\textcolor{magenta}{Henk}$ на мовах Erlang та OCaml.

ML/LCF або метамова і логіка обчислювальних функцій були наступним кроком до
осягнення фундаментальної мови простору, тут вперше з'явилися алгебраїчні типи даних
у вигляді індуктивних типів, поліноміальних функторів або термінованих (well-founded) дерев.
Роберт Мілнер, асистований Морісом та Н'юві розробив Метамову (ML), як
інструмент для побудови прувера LCF. LCF був основоположником у родині пруверів
HOL88, HOL90, HOL98 та останньої версії на даний час HOL/Isabell.
Пізніше були побувані категорні моделі Татсоя Хагіно (CPL\footnote{\url{https://web.sfc.keio.ac.jp/~hagino/thesis.pdf}}, Японія)
та Робіна Кокета (Charity\footnote{\url{https://github.com/devaspot/charity}}, Канада).

У 80-90 роках були створені інші системи автоматичного доведення теорем,
такі як Mizar (Трибулєк, 1989). PVS (Оур, Рушбі, Шанкар, 1995),
ACL2 на базі Common Lisp (Боєр, Кауфман, Мур, 1996), Otter (МакКюн, 1996).

\section{Формальні мови та середовища виконання}
Усі середовища виконання можна умовно розділити на два класи:
1) інтерпретатори нетипізованого або просто
   типізованого (рідше з більш потужними системами типів),
   лямбда числення з можливими JIT оптимізаціями;
2) безпосередня генерація інструкцій процессора і лінкування цієї програми з
   середовищем виконання що забезпечує планування ресурсів (в цій області
   переважно використовується System F типізація).

До першого класу можна віднести такі віртуалні машини та інтерпретатори як
Erlang (BEAM), JavaScript (V8), Java (HotSpot), K (Kx), PHP (HHVM), Python (PyPy), LuaJIT
та багато інших інтерпретаторів.

До другого класу можна віднести такі мови програмування: ML, OCaml, Rust,
Haskell, Pony. Часто використовується LLVM як спосіб генерації програмного коду.
Rust використовує проміжну мову MIR над LLVM рівнем. Побудова верифікованого компілятора
для такого класу систем виходить за межі цього дослідження. Нас тут буде цікавити
лише вибір найкращого кандидата для середовижа виконання.

Нійбільш цікаві цільові платформи для виконання программ
які побудовані на основі формальних доведень для нас є OCaml (тому,
що це основна мова екстракту для промислової системи доведення теорем Coq),
Rust (тому, що рантайм може бути написаний без використання сміттєзбірника),
Erlang (тому, що підтримує неблоковану семантику $\pi$-числення)
та Pony (тому, що семантика його $\pi$-числення побудована на
імутабельних чергах та CAS-курсорах).

\subsection{Формальні інтерпретатори та ОС}
Перший прототип, рантайм $O_{CPS}$ -- лінивий
векторизований інтерпретатор (підтримка SSE/AVX інструкцій) та система
управління ресурсами з планувальником лінивих програм
та системою черг і CAS курсорів у якості моделі $\pi$-числення. Розглядалося також
використання ядра L4 на мові С, верифікованого за допомогою HOL/Isabell,
у якості базової операційної системи. В рамках проєкту AXIO/1
назва цієї мови --- $\textcolor{magenta}{Bob}$.

Наступна версія $O_{CPS}$ або подальші дослідження верифікованих інтерпретаторів
будуть базуватися на результатах таких досліджень як
CoqASM\footnote{\url{http://nickbenton.name/coqasm.pdf}} та
Verified LISP Interpreter\footnote{\url{https://www.cl.cam.ac.uk/~mom22/tphols09-lisp.pdf}}.
В рамках проєкту AXIO/1
назва цієї мови --- $\textcolor{magenta}{Joe}$.

\subsection{Формальний ввід-вивід}
Другий прототип побудований на базі coq.io, що дозволяє
використовувати бібліотеки OCaml для промислового програмування в Coq.
У цій роботі ми формально показали і продемонстрували коіндуктивний шел
та вічно працюючу тотальну програму на Coq. Ця робота проводилася
в рамках дослідження системи ефектів для результуючої мови програмування.

\subsection{Чисті системи типів}
Третій прототип -- побудова тайпчекера та ектрактора у мову Erlang та CPS.
Ця робота представлена у вигляді PTS тайпчекера Henk, який вистує у ролі
проміжної мови для повної нормалізації лямбда термів. В роботі використане
нерекурсивне кодування індуктивних типів та продемонстрована теж бескінечна
тотальна программа у якості способу лінкування з підсистемою вводу-виводу
віртуальної машини Erlang. В доповнення до існуючих імплементацій CoC
на Haskell (Morte).

\subsection{Гомотопічні системи типів}
Четвертий прототип --- імплементація першого кубічного верифікатора на
мові Erlang в доповнення до існуючих ССHM (Erlang, Haskell),
ABCFHL (Haskell,OCaml).

\section{Висновки}
Як результат цього розділу, було досліджено:
1) усі системи доведення теорем;
2) формальні мови програмування;
3) системи верифікації;
4) формальні середовища виконання.

Та встановлено, що усі такі системи є носіями
мовних елементів які згідно теорії типів Мартіна-Льофа можна
кластеризувати по наступним мовам, кожна з яких репрезентує правила типу:
5) $O_\lambda$ --- нетипизоване $\lambda$-числення Чорча;
6) $O_\pi$ --- числення процесів, CCS, CSP або $\pi$-числення Мілнера;
7) $O_\mu$ --- тензорне числення та векторизація (MatLab, Julia, kx, J);
8) $O_\Pi$ --- числення конструкцій (функціональна повнота);
9) $O_\Sigma$ --- числення контекстів (контекстуальна повнота);
10) $O_=$ --- теорія типів Мартіна-Льофа (логіка);
11) $O_W$ --- числення індуктивних конструкцій (матіндукція);
12) $O_I$ --- гомотопічна система типів (формальна математика).
