\documentclass{article}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{url}
\usepackage{tikz-cd}
\usepackage[utf8]{inputenc}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newcommand*{\incmap}{\hookrightarrow}
\newcommand*{\thead}[1]{\multicolumn{1}{c}{\bfseries #1}}

\lstset{
  basicstyle=\footnotesize,
  inputencoding=utf8,
  identifierstyle=,
  literate=
{ğŸ}{{\ensuremath{\mathbf{0}}}}1
{ğŸ}{{\ensuremath{\mathbf{1}}}}1
{â‰”}{{\ensuremath{\mathrm{:=}}}}1
{Î±}{{\ensuremath{\mathrm{\alpha}}}}1
{áµ‚}{{\ensuremath{^W}}}1
{Î²}{{\ensuremath{\mathrm{\beta}}}}1
{Î³}{{\ensuremath{\mathrm{\gamma}}}}1
{Î´}{{\ensuremath{\mathrm{\delta}}}}1
{Îµ}{{\ensuremath{\mathrm{\varepsilon}}}}1
{Î¶}{{\ensuremath{\mathrm{\zeta}}}}1
{Î·}{{\ensuremath{\mathrm{\eta}}}}1
{Î¸}{{\ensuremath{\mathrm{\theta}}}}1
{Î¹}{{\ensuremath{\mathrm{\iota}}}}1
{Îº}{{\ensuremath{\mathrm{\kappa}}}}1
{Î»}{{\ensuremath{\mathrm{\lambda}}}}1
{Î¼}{{\ensuremath{\mathrm{\mu}}}}1
{Î½}{{\ensuremath{\mathrm{\nu}}}}1
{Î¾}{{\ensuremath{\mathrm{\xi}}}}1
{Ï€}{{\ensuremath{\mathrm{\mathnormal{\pi}}}}}1
{Ï}{{\ensuremath{\mathrm{\rho}}}}1
{Ïƒ}{{\ensuremath{\mathrm{\sigma}}}}1
{Ï„}{{\ensuremath{\mathrm{\tau}}}}1
{Ï†}{{\ensuremath{\mathrm{\varphi}}}}1
{Ï‡}{{\ensuremath{\mathrm{\chi}}}}1
{Ïˆ}{{\ensuremath{\mathrm{\psi}}}}1
{Ï‰}{{\ensuremath{\mathrm{\omega}}}}1
{Î }{{\ensuremath{\mathrm{\Pi}}}}1
{Î“}{{\ensuremath{\mathrm{\Gamma}}}}1
{Î”}{{\ensuremath{\mathrm{\Delta}}}}1
{Î˜}{{\ensuremath{\mathrm{\Theta}}}}1
{Î›}{{\ensuremath{\mathrm{\Lambda}}}}1
{Î£}{{\ensuremath{\mathrm{\Sigma}}}}1
{Î¦}{{\ensuremath{\mathrm{\Phi}}}}1
{Î}{{\ensuremath{\mathrm{\Xi}}}}1
{Î¨}{{\ensuremath{\mathrm{\Psi}}}}1
{Î©}{{\ensuremath{\mathrm{\Omega}}}}1
{â„µ}{{\ensuremath{\aleph}}}1
{â‰¤}{{\ensuremath{\leq}}}1
{â‰¥}{{\ensuremath{\geq}}}1
{â‰ }{{\ensuremath{\neq}}}1
{â‰ˆ}{{\ensuremath{\approx}}}1
{â‰¡}{{\ensuremath{\equiv}}}1
{â‰ƒ}{{\ensuremath{\simeq}}}1
{â‰¤}{{\ensuremath{\leq}}}1
{â‰¥}{{\ensuremath{\geq}}}1
{âˆ‚}{{\ensuremath{\partial}}}1
{âˆ†}{{\ensuremath{\triangle}}}1 % or \laplace?
{âˆ«}{{\ensuremath{\int}}}1
{âˆ‘}{{\ensuremath{\mathrm{\Sigma}}}}1
{â†’}{{\ensuremath{\rightarrow}}}1
{âŠ¥}{{\ensuremath{\perp}}}1
{âˆ}{{\ensuremath{\infty}}}1
{âˆ‚}{{\ensuremath{\partial}}}1
{âˆ“}{{\ensuremath{\mp}}}1
{Â±}{{\ensuremath{\pm}}}1
{Ã—}{{\ensuremath{\times}}}1
{âŠ•}{{\ensuremath{\oplus}}}1
{âŠ—}{{\ensuremath{\otimes}}}1
{âŠ}{{\ensuremath{\boxplus}}}1
{âˆ‡}{{\ensuremath{\nabla}}}1
{âˆš}{{\ensuremath{\sqrt}}}1
{â¬}{{\ensuremath{\cdot}}}1
{â€¢}{{\ensuremath{\cdot}}}1
{âˆ˜}{{\ensuremath{\circ}}}1
{â»}{{\ensuremath{^{-}}}}1
{â–¸}{{\ensuremath{\blacktriangleright}}}1
{â˜…}{{\ensuremath{\star}}}1
{âˆ§}{{\ensuremath{\wedge}}}1
{âˆ¨}{{\ensuremath{\vee}}}1
{Â¬}{{\ensuremath{\neg}}}1
{âŠ¢}{{\ensuremath{\vdash}}}1
{âŸ¨}{{\ensuremath{\langle}}}1
{âŸ©}{{\ensuremath{\rangle}}}1
{â†¦}{{\ensuremath{\mapsto}}}1
{â†’}{{\ensuremath{\rightarrow}}}1
{â†”}{{\ensuremath{\leftrightarrow}}}1
{â‡’}{{\ensuremath{\Rightarrow}}}1
{âŸ¹}{{\ensuremath{\Longrightarrow}}}1
{â‡}{{\ensuremath{\Leftarrow}}}1
{âŸ¸}{{\ensuremath{\Longleftarrow}}}1
{âˆ©}{{\ensuremath{\cap}}}1
{âˆª}{{\ensuremath{\cup}}}1
{âŠ‚}{{\ensuremath{\subseteq}}}1
{âŠ†}{{\ensuremath{\subseteq}}}1
{âŠ„}{{\ensuremath{\nsubseteq}}}1
{âŠˆ}{{\ensuremath{\nsubseteq}}}1
{âŠƒ}{{\ensuremath{\supseteq}}}1
{âŠ‡}{{\ensuremath{\supseteq}}}1
{âŠ…}{{\ensuremath{\nsupseteq}}}1
{âŠ‰}{{\ensuremath{\nsupseteq}}}1
{âˆˆ}{{\ensuremath{\in}}}1
{âˆ‰}{{\ensuremath{\notin}}}1
{âˆ‹}{{\ensuremath{\ni}}}1
{âˆŒ}{{\ensuremath{\notni}}}1
{âˆ…}{{\ensuremath{\emptyset}}}1
{âˆ–}{{\ensuremath{\setminus}}}1
{â€ }{{\ensuremath{\dag}}}1
{â„•}{{\ensuremath{\mathbb{N}}}}1
{â„¤}{{\ensuremath{\mathbb{Z}}}}1
{â„}{{\ensuremath{\mathbb{R}}}}1
{â„š}{{\ensuremath{\mathbb{Q}}}}1
{â„‚}{{\ensuremath{\mathbb{C}}}}1
{âŒ}{{\ensuremath{\llcorner}}}1
{âŒŸ}{{\ensuremath{\lrcorner}}}1
{â¦ƒ}{{\ensuremath{ \{\!| }}}1
{â¦„}{{\ensuremath{ |\!\} }}}1
{â‚}{{\ensuremath{_1}}}1
{â‚‚}{{\ensuremath{_2}}}1
{â‚ƒ}{{\ensuremath{_3}}}1
{â‚„}{{\ensuremath{_4}}}1
{â‚…}{{\ensuremath{_5}}}1
{â‚†}{{\ensuremath{_6}}}1
{â‚‡}{{\ensuremath{_7}}}1
{â‚ˆ}{{\ensuremath{_8}}}1
{â‚‰}{{\ensuremath{_9}}}1
{â‚€}{{\ensuremath{_0}}}1
{Â¹}{{\ensuremath{^1}}}1
{â‚™}{{\ensuremath{_n}}}1
{â‚˜}{{\ensuremath{_m}}}1
{â†‘}{{\ensuremath{\uparrow}}}1
{â†“}{{\ensuremath{\downarrow}}}1
{â–¸}{{\ensuremath{\triangleright}}}1
{âˆ€}{{\ensuremath{\forall}}}1
{âˆƒ}{{\ensuremath{\exists}}}1
{Î»}{{\ensuremath{\mathrm{\lambda}}}}1
{=}{{\ensuremath{=}}}1
{<}{{\ensuremath{\textless}}}1
{>}{{\ensuremath{\textgreater}}}1
{(}{(}1
{(}{(}1
{â€–}{â€–}1
{+}{{+}}1
{*}{{*}}1,
}

\begin{document}

\title{Issue III: Homotopy Type Theory}
\author{Maksym Sokhatskyi $^1$}
\date{ $^1$ National Technical University of Ukraine \\
       \small Igor Sikorsky Kyiv Polytechnical Institute \\
       \today }

\maketitle

\begin{abstract}
Here is presented destinctive points of Homotopy Type Theory
as an extension of Martin-LÃ¶f Type Theory but without higher inductive types
which will be given in the next issue. The study of identity system is given.
Groupoid (categorical) interpretation is presented as categories of spaces and paths between them as invertible morphisms.
At last constructive proof $\Omega(S^1)=\mathbb{Z}$ is given through helix.
\\
\\
{\bf Keywords}: Homotopy Theory, Type Theory
\end{abstract}

\newpage
\tableofcontents

\newpage
\section{Introduction}
\subsection{Introduction: Type Theory}
Type theory is a universal programming language for pure mathematics,
designed for theorem proving. It supports an arbitrary number of consistent
axioms, structured as pseudo-isomorphisms consisting of \textit{encode}
functions (methods for constructing type elements), \textit{decode}
functions (dependent eliminators of the universal induction principle),
and their equations---beta and eta rules governing computability and
uniqueness. As a programming language, type theory includes basic
primitives (axioms as built-in types) and accompanying documentation,
such as lecture notes or textbooks, explaining their applications, including:

\begin{itemize}
\item \text{Functions} ($\mathbf{\Pi}$)
\item \text{Contexts} ($\mathbf{\Sigma}$)
\item \text{Identifications} ($\mathbf{=}$)
\item \text{Polynomials} ($\mathbf{W}$)
\item \text{Paths} ($\Xi$)
\item \text{Gluings} ($\mathbf{Glue}$)
\item \text{Infinitesimals} ($\Im$)
\item \text{Complexes} ($\mathbf{HIT}$)
\end{itemize}

Students (10) are tasked with applying type theory to prove an initial
but non-trivial result addressing an open problem in one of the following
areas offered by the Department of Pure Mathematics (KM-111):

\[
\text{Mathematics} :=
\begin{cases}
\text{Homotopy Theory} \\
\text{Homological Algebra} \\
\text{Category Theory} \\
\text{Functional Analysis} \\
\text{Differential Geometry}
\end{cases} .
\]


\newpage
\subsection{Motivation: Homotopy Type Theory}
The primary motivation of homotopy type theory is to provide computational
semantics for homotopic types and CW-complexes. The central idea, as
described in, is to combine function spaces (\(\Pi\)),
context spaces (\(\Sigma\)), and path spaces (\(\Xi\)) to form a fiber bundle, proven within HoTT to coincide with the $\Pi$ type itself.

Key definitions include:

\begin{lstlisting}
def contr (A: U) : U := Î£ (x: A), Î  (y: A), Î A x y
def fiber (A B: U) (f: A â†’ B) (y: B): U := Î£ (x: A), Path B y (f x)
def isEquiv (A B: U) (f: A â†’ B): U := Î  (y: B), contr(fiber A B f y)
def equiv (X Y: U): U := Î£ (f: X â†’ Y), isEquiv X Y f
def ua (A B : U) (p : Î U A B) : equiv A B
 := transp (<i> equiv A (p @ i)) 0 (idEquiv A)
\end{lstlisting}

The absence of an eta-rule for equality implies that not all proofs of the
same path space are equal, resulting in a multidimensional \(\infty\)-groupoid
structure for path spaces. Further definitions include:

\begin{lstlisting}
def isProp (A : U) : U
 := Î  (a b : A), Î A a b

def isSet (A : U) : U
 := Î  (a b : A) (x y : Î A a b), Î (Î A a b) x y

def isGroupoid (A : U) : U
 := Î  (a b : A) (x y : Î A a b) (i j : Î (Î A a b) x y),
    Î (Î (Î A a b) x y) i j
\end{lstlisting}

The groupoid interpretation raises questions about the existence of a language for
mechanically proving all properties of the categorical definition of a groupoid:

\begin{lstlisting}
def CatGroupoid (X : U) (G : isGroupoid X)
  : isCatGroupoid (PathCat X)
 := ( idp X,
      comp-Path X,
      G,
      sym X,
      comp-inv-Pathâ»Â¹ X,
      comp-inv-Path X,
      comp-Path-left X,
      comp-Path-right X,
      comp-Path-assoc X,
      â˜…
    )
\end{lstlisting}

\newpage
\subsection{Metatheory: Adjunction Triples}
The course is divided into four parts, each exploring type-axioms and their meta-theoretical adjunctions.

\subsubsection{Fibrational Proofs}
\[
\Sigma \dashv f_\star \dashv \Pi
\]
Fibrational proofs are modeled by primitive axioms, which are type-theoretic
representations of categorical meta-theoretical models of adjunctions of three
Cockett-Reit functors, giving rise to function spaces (\(\Pi\)) and pair
spaces (\(\Sigma\)). These proof methods enable direct analysis of fibrations.

\subsubsection{Equality Proofs}
\[
\mathrm{Q} \dashv \Xi \dashv \mathrm{C}
\]
In intensional type theory, the equality type is embedded as type-theoretic
primitives of categorical meta-theoretical models of adjunctions of three
Jacobs-Lambek functors: quotient space (\(\mathrm{Q}\)), identification
system (\(\Xi\)), and contractible space (\(\mathrm{C}\)). These methods allow
direct manipulation of identification systems, strict for set theory and
homotopic for homotopy theory.

\subsubsection{Inductive Proofs}
$$
\mathrm{W} \dashv \odot \dashv \mathrm{M}
$$

Inductive types in type theory can be embedded as polynomial
functors ($\mathrm{W}$, $\mathrm{M}$) or general inductive type
schemes (Calculus of Inductive Constructions), with properties including:
1) Verification of program finiteness;
2) Verification of strict positivity of parameters;
3) Verification of mutual recursion.

In this course, induction and coinduction are introduced as type-theoretic
primitives of categorical meta-theoretical models of adjunctions of
polynomial functors (Lambek-Bohm), enabling manipulation of initial
and terminal algebras, algebraic recursive data types, and infinite
processes. Higher inductive proofs, where constructors include path
spaces, are modeled by polynomial functors using monad-algebras and
comonad-coalgebras (Lumsdaine-Shulman).

\subsubsection{Geometric Proofs}
$$
\Re \dashv \Im \dashv \&
$$
For differential geometry, type theory incorporates primitive axioms of
categorical meta-theoretical models of three Schreiber-Shulman functors:
infinitesimal neighborhood (\(\Im\)), reduced modality (\(\Re\)), and
infinitesimal discrete neighborhood (\(\&\)).

\newpage
One additional part recently was dropped.

\subsubsection{Linear Proofs}

$$
\otimes \dashv x \dashv \multimap
$$

For engineering applications (e.g., Milner's $\pi$-calculus, quantum computing)
and linear type theory, type theory embeds linear proofs based on the adjunction
of the tensor and linear function spaces: $(A \otimes B) \multimap A \simeq A \multimap (B \multimap C)$,
represented in a symmetric monoidal category $\mathbf{D}$ for a functor $[A,B]$ as:
$\mathbf{D}(A \otimes B, C) \simeq \mathbf{D}(A, [B,C])$.

\subsection{Historical Notes}
Homotypy Type Theory takes its origins in 1996 from groupoid interpretation by
Hofmann and Streicher's, and later (in 10 years) was formalized by Awodey,
Warren and Voevodsky. Voevodsky constrtucted Kan simplicial sets interpretation
of type theory and discovered the property of this model, that was named univalence.
This property allows to identify isomorphic structures in terms of type theory.

Homotopy type theory to classical homotopy theory is like Euclidian
syntethic geometry (points, lines, axioms and deduction rules) to
analytical geometry with cartesian coordinates on $\mathbb{R}^n$ (geometric and algebraic)

\footnote{We will denote geometric, type theoretical and homotopy constants
bold font $\mathbf{R}$ while analitical will be denoted with double lined letters $\mathbb{R}$.}

In the same way as inductive types extends MLTT for inductive programming,
the higher inductive types (HIT) extend homotopy type theory for geometry programming.
You can directly encode CW-complexes by using HIT. The definition of HIT syntax will
be given in the next {\bf Issue IV: Higher Inductive Types}.

\newpage
\section{Homotopy Type Theory}
\subsection{Homotopies}
The first higher equality we meet in homotopy theory is a notion of homotopy,
where we compare two functions or two path spaces (which is sort of dependent families).
The homotopy interval $\mathrm{I}=[0,1]$ is the perfect foundation for definition of homotopy.

\begin{definition} (Interval). Compact interval.
\begin{lstlisting}[mathescape=true]
def I : U := inductive { i0 | i1 | seg : i0 $\equiv$ i1 }
\end{lstlisting}
\end{definition}

You can think of ${\bf I}$ as isomorphism of equality type,
disregarding carriers on the edges. By mapping $i0,i1:{\bf I}$ to $x,y:A$ one can
obtain identity or equality type from classic type theory.

\begin{definition} (Interval Split).
The convertion function from $\mathrm{I}$ to a type of comparison
is a direct eliminator of interval. The interval is also known as one of
primitive higher inductive types which will be given in the next
{\bf Issue IV: Higher Inductive Types}.
\begin{lstlisting}[mathescape=true]
def pathToHtpy (A: U) (x y: A) (p: Path A x y) : I $\rightarrow$ A
 := split { i0 $\rightarrow$ x | i1 $\rightarrow$ y | seg @ i $\rightarrow$ p @ i }
\end{lstlisting}
\end{definition}

\begin{definition} (Homotopy). The homotopy between two function $f,g: X \rightarrow Y$
is a continuous map of cylinder $H : X \times {\bf I} \rightarrow Y$ such that
$$
\begin{cases}
H(x,0)=f(x), \\
H(x,1)=g(x).
\end{cases}
$$
\begin{lstlisting}
homotopy (X Y: U) (f g: X -> Y)
         (p: (x: X) -> Path Y (f x) (g x))
         (x: X): I -> Y = pathToHtpy Y (f x) (g x) (p x)
\end{lstlisting}
\end{definition}

\newpage
\subsection{Groupoid Interpretation}
The first text about groupoid interpretation of type theory can be found in Francois Lamarche:
A proposal about Foundations\footnote{\url{http://www.cse.chalmers.se/~coquand/Proposal.pdf}}.
Then Martin Hofmann and Thomas Streicher wrote the initial
document on groupoid interpretation of type
theory\footnote{Martin Hofmann and Thomas Streicher. The Groupoid Interpretation of Type Theory. 1996.}.

\begin{table}[H]
\begin{center}
\begin{tabular}{lccc}
\hline
{\bf Equality} & {\bf Homotopy} & {\bf $\infty$-Groupoid} \\
\hline
reflexivity  & constant path & identity morphism \\
symmetry     & inversion of path & inverse morphism \\
transitivity & concatenation of paths & composition of mopphisms \\
\hline
\end{tabular}
\end{center}
\end{table}

There is a deep connection between higher-dimentinal groupoids in category theory and
spaces in homotopy theory, equipped with some topology. The category or groupoid could
be built where the objects are particular spaces or types, and morphisms are path types
between these types, composition operation is a path concatenation. We can write this
groupoid here recalling that it should be category with inverted morphisms.

\begin{lstlisting}
cat: U = (A: U) * (A -> A -> U)
groupoid: U = (X: cat) * isCatGroupoid X
PathCat (X: U): cat = (X,\(x y:X)->Path X x y)
\end{lstlisting}

\begin{lstlisting}
def isCatGroupoid (C: cat): U := Î£
    (id:        Î  (x: C.ob), C.hom x x)
    (c:         Î  (x y z:C.ob), C.hom x y -> C.hom y z -> C.hom x z)
    (HomSet:    Î  (x y: C.ob), isSet (C.hom x y))
    (inv:       Î  (x y: C.ob), C.hom x y -> C.hom y x)
    (inv-left:  Î  (x y: C.ob) (p: C.hom x y),
                Î (C.hom x x) (c x y x p (inv x y p)) (id x))
    (inv-right: Î  (x y: C.ob) (p: C.hom x y),
                Î (C.hom y y) (c y x y (inv x y p) p) (id y))
    (left:      Î  (x y: C.ob) (f: C.hom x y),
                Î (C.hom x y) f (c x x y (id x) f))
    (right:     Î  (x y: C.ob) (f: C.hom x y),
                Î (C.hom x y) f (c x y y f (id y)))
    (assoc:     Î  (x y z w: C.ob) (f: C.hom x y)
                  (g: C.hom y z) (h: C.hom z w),
                Î (C.hom x w) (c x z w (c x y z f g) h)
                              (c x y w f (c y z w g h))), â˜…
\end{lstlisting}

\newpage
\begin{lstlisting}
def isProp (A : U) : U
 := Î  (a b : A), Path A a b

def isSet (A : U) : U
 := Î  (a b : A) (a0 b0 : Path A a b),
    Path (Path A a b) a0 b0

def isGroupoid (A : U) : U
 := Î  (a b : A) (x y : Path A a b)
    (i j : Path (Path A a b) x y),
    Path (Path (Path A a b) x y) i j
\end{lstlisting}

\begin{lstlisting}
def CatGroupoid (X : U) (G : isGroupoid X)
  : isCatGroupoid (PathCat X)
 := ( idp X,
      comp-Path X,
      G,
      sym X,
      comp-inv-Pathâ»Â¹ X,
      comp-inv-Path X,
      comp-Path-left X,
      comp-Path-right X,
      comp-Path-assoc X,
      â˜…
    )
\end{lstlisting}

\newpage
\subsection{Identity Systems}
\begin{definition} (Identity System).
An identity system over type $A$ in universe $X_i$ is a
family $R : A \rightarrow A \rightarrow X_i$ with a function
$r_0: \Pi_{a:A}R(a,a)$ such that any type family
$D : \Pi_{a,b:A}R(a,b) \rightarrow X_i$ and
$d: \Pi_{a:A}D(a,a,r_0(a))$, there exists a function
$f: \Pi_{a,b:A}\Pi_{r:R(a,b)}D(a,b,r)$ such that
$f(a,a,r_0(a))=d(a)$ for all $a:A$.
\begin{lstlisting}
def IdentitySystem (A : U) : U
 := Î£ (=-form : A â†’ A â†’ U)
      (=-ctor : Î  (a : A), =-form a a)
      (=-elim : Î  (a : A) (C: Î  (x y : A)
                  (p : =-form x y), U)
                  (d : C a a (=-ctor a)) (y : A)
                  (p : =-form a y), C a y p)
      (=-comp : Î  (a : A) (C: Î  (x y : A)
                  (p : =-form x y), U)
                  (d : C a a (=-ctor a)),
                  Path (C a a (=-ctor a)) d
                       (=-elim a C d a (=-ctor a))), ğŸ
\end{lstlisting}
\end{definition}

\begin{example}
There are number of equality signs used in this tutorial,
all of them listed in the following table of identity systems:
$$
\begin{array}{ll} \mathrm{Sign} & \mathrm{Meaning} \\
                         \hline
                        =_{def} & \mathrm{Definition} \\
                              = & \mathrm{Id} \\
                         \equiv & \mathrm{Path} \\
                         \simeq & \mathrm{Equivalence} \\
                          \cong & \mathrm{Isomorphism} \\
                           \sim & \mathrm{Homotopy} \\
                        \approx & \mathrm{Bisimulation} \\
                      \end{array}
$$
\end{example}

\begin{theorem} (Fundamental Theorem of Identity System).
\end{theorem}

\begin{definition} (Strict Identity System).
An identity system over type $A$ and universe
of pretypes $V_i$ is called strict identity system ($=$), which respects UIP.
\end{definition}

\begin{definition} (Homotopy Identity System).
An identity system over type $A$ and universe of homotopy
types $U_i$ is called homotopy identity system ($\equiv$),
which models discrete infinity groupoid.
\end{definition}

\newpage
\subsection{Functional Extensionality}

\begin{definition} (funExt-Formation)
\begin{lstlisting}
funext_form (A B: U) (f g: A -> B): U
  = Path (A -> B) f g
\end{lstlisting}
\end{definition}

\begin{definition} (funExt-Introduction)
\begin{lstlisting}
funext (A B: U) (f g: A -> B) (p: (x:A) -> Path B (f x) (g x))
  : funext_form A B f g
  = <i> \(a: A) -> p a @ i
\end{lstlisting}
\end{definition}

\begin{definition} (funExt-Elimination)
\begin{lstlisting}
happly (A B: U) (f g: A -> B) (p: funext_form A B f g) (x: A)
  : Path B (f x) (g x)
  = cong (A -> B) B (\(h: A -> B) -> apply A B h x) f g p
\end{lstlisting}
\end{definition}

\begin{definition} (funExt-Computation)
\begin{lstlisting}
funext_Beta (A B: U) (f g: A -> B) (p: (x:A) -> Path B (f x) (g x))
  : (x:A) -> Path B (f x) (g x)
  = \(x:A) -> happly A B f g (funext A B f g p) x
\end{lstlisting}
\end{definition}

\begin{definition} (funExt-Uniqueness)
\begin{lstlisting}
funext_Eta (A B: U) (f g: A -> B) (p: Path (A -> B) f g)
  : Path (Path (A -> B) f g) (funext A B f g (happly A B f g p)) p
  = refl (Path (A -> B) f g) p
\end{lstlisting}
\end{definition}

\newpage
\subsection{Fibrations}

\begin{definition} (Fibration-1) Dependent fiber bundle derived from Path contractability.
\begin{lstlisting}
isFBundle1 (B: U) (p: B -> U) (F: U): U
  = (_: (b: B) -> isContr (Path U (p b) F))
  * ((x: Sigma B p) -> B)
\end{lstlisting}
\end{definition}

\begin{definition} (Fibration-2). Dependent fiber bundle derived from surjective function.
\begin{lstlisting}
isFBundle2 (B: U) (p: B -> U) (F: U): U
  = (V: U)
  * (v: surjective V B)
  * ((x: V) -> Path U (p (v.1 x)) F)
\end{lstlisting}
\end{definition}

\begin{definition} (Fibration-3). Non-dependent fiber bundle derived from fiber truncation.
\begin{lstlisting}
im1 (A B: U) (f: A -> B): U = (b: B) * pTrunc ((a:A) * Path B (f a) b)
BAut (F: U): U = im1 unit U (\(x: unit) -> F)
unitIm1 (A B: U) (f: A -> B): im1 A B f -> B = \(x: im1 A B f) -> x.1
unitBAut (F: U): BAut F -> U = unitIm1 unit U (\(x: unit) -> F)

isFBundle3 (E B: U) (p: E -> B) (F: U): U
  = (X: B -> BAut F)
  * (classify B (BAut F) (\(b: B) -> fiber E B p b) (unitBAut F) X) where
  classify (A' A: U) (E': A' -> U) (E: A -> U) (f: A' -> A): U
    = (x: A') -> Path U (E'(x)) (E(f(x)))
\end{lstlisting}
\end{definition}

\begin{definition} (Fibration-4). Non-dependen fiber bundle derived as pullback square.
\begin{lstlisting}
isFBundle4 (E B: U) (p: E -> B) (F: U): U
  = (V: U)
  * (v: surjective V B)
  * (v': prod V F -> E)
  * pullbackSq (prod V F) E V B p v.1 v' (\(x: prod V F) -> x.1)
\end{lstlisting}
\end{definition}

\newpage
\subsection{Equivalence}

\begin{definition} (Equivalence).
\begin{lstlisting}
fiber (A B: U) (f: A -> B) (y: B): U = (x: A) * Path B y (f x)
isSingleton (X:U): U = (c:X) * ((x:X) -> Path X c x)
isEquiv (A B: U) (f: A -> B): U = (y: B) -> isContr (fiber A B f y)
equiv (A B: U): U = (f: A -> B) * isEquiv A B f
\end{lstlisting}
\end{definition}

\begin{definition} (Surjective).
\begin{lstlisting}
isSurjective (A B: U) (f: A -> B): U
  = (b: B) * pTrunc (fiber A B f b)

surjective (A B: U): U
  = (f: A -> B)
  * isSurjective A B f
\end{lstlisting}
\end{definition}

\begin{definition} (Injective).
\begin{lstlisting}
isInjective' (A B: U) (f: A -> B): U
  = (b: B) -> isProp (fiber A B f b)

injective (A B: U): U
  = (f: A -> B)
  * isInjective A B f
\end{lstlisting}
\end{definition}

\begin{definition} (Embedding).
\begin{lstlisting}
isEmbedding (A B: U) (f: A -> B) : U
  = (x y: A) -> isEquiv (Path A x y) (Path B (f x) (f y)) (cong A B f x y)

embedding (A B: U): U
  = (f: A -> B)
  * isEmbedding A B f
\end{lstlisting}
\end{definition}

\begin{definition} (Half-adjoint Equivalence).
\begin{lstlisting}
isHae (A B: U) (f: A -> B): U
  = (g: B -> A)
  * (eta_: Path (id A) (o A B A g f) (idfun A))
  * (eps_: Path (id B) (o B A B f g) (idfun B))
  * ((x: A) -> Path B (f ((eta_ @ 0) x)) ((eps_ @ 0) (f x)))

hae (A B: U): U
  = (f: A -> B)
  * isHae A B f
\end{lstlisting}
\end{definition}

\newpage
\subsection{Isomorphism}

\begin{definition} (iso-Formation)
\begin{lstlisting}
iso_Form (A B: U): U = isIso A B -> Path U A B
\end{lstlisting}
\end{definition}

\begin{definition} (iso-Introduction)
\begin{lstlisting}
iso_Intro (A B: U): iso_Form A B
\end{lstlisting}
\end{definition}

\begin{definition} (iso-Elimination)
\begin{lstlisting}
iso_Elim (A B: U): Path U A B -> isIso A B
\end{lstlisting}
\end{definition}

\begin{definition} (iso-Computation)
\begin{lstlisting}
iso_Comp (A B : U) (p : Path U A B)
  : Path (Path U A B) (iso_Intro A B (iso_Elim A B p)) p
\end{lstlisting}
\end{definition}

\begin{definition} (iso-Uniqueness)
\begin{lstlisting}
iso_Uniq (A B : U) (p: isIso A B)
  : Path (isIso A B) (iso_Elim A B (iso_Intro A B p)) p
\end{lstlisting}
\end{definition}

\newpage
\subsection{Univalence}

\begin{definition} (uni-Formation)
\begin{lstlisting}
univ_Formation (A B: U): U = equiv A B -> Path U A B
\end{lstlisting}
\end{definition}

\begin{definition} (uni-Introduction)
\begin{lstlisting}
equivToPath (A B: U): univ_Formation A B
  = \(p: equiv A B) -> <i> Glue B [(i=0) -> (A,p),
    (i=1) -> (B, subst U (equiv B) B B (<_>B) (idEquiv B)) ]
\end{lstlisting}
\end{definition}

\begin{definition} (uni-Elimination)
\begin{lstlisting}
pathToEquiv (A B: U) (p: Path U A B) : equiv A B
  = subst U (equiv A) A B p (idEquiv A)
\end{lstlisting}
\end{definition}

\begin{definition} (uni-Computation)
\begin{lstlisting}
eqToEq (A B : U) (p : Path U A B)
  : Path (Path U A B) (equivToPath A B (pathToEquiv A B p)) p
  = <j i> let Ai: U = p@i in Glue B
    [ (i=0) -> (A,pathToEquiv A B p),
      (i=1) -> (B,pathToEquiv B B (<k> B)),
      (j=1) -> (p@i,pathToEquiv Ai B (<k> p @ (i \/ k))) ]

\end{lstlisting}
\end{definition}

\begin{definition} (uni-Uniqueness)
\begin{lstlisting}
transPathFun (A B : U) (w: equiv A B)
  : Path (A -> B) w.1 (pathToEquiv A B (equivToPath A B w)).1
\end{lstlisting}
\end{definition}

\newpage
\subsection{Loop Spaces}

\begin{definition} (Pointed Space). A pointed type $(A,a)$ is a type $A:U$
together with a point $a:A$, called its basepoint.
\begin{lstlisting}
pointed: U = (A: U) * A
point (A: pointed): A.1 = A.2
space (A: pointed): U = A.1
\end{lstlisting}
\end{definition}

\begin{definition} (Loop Space).
$$\Omega(A,a) =_{def} ((a =_A a), refl_A(a)).$$
\begin{lstlisting}
omega1 (A: pointed) : pointed
  = (Path (space A) (point A) (point A), refl A.1 (point A))
\end{lstlisting}
\end{definition}

\begin{definition} (n-Loop Space).
$$
\begin{cases}
\Omega^0(A, a) =_{def} (A, a)\\
\Omega^{n+1}(A,a) =_{def} \Omega^{n}(\Omega(A,a))\\
\end{cases}
$$
\begin{lstlisting}
omega : nat -> pointed -> pointed = split
  zero -> idfun pointed
  succ n -> \(A: pointed) -> omega n (omega1 A)
\end{lstlisting}
\end{definition}

\newpage
\subsection{Homotopy Groups}

\begin{definition} (n-th Homotopy Group of m-Sphere).
$$\pi_{n}S^{m} = ||\Omega^{n}(S^{m})||_0.$$
\begin{lstlisting}
piS (n: nat): (m: nat) -> U = split
   zero   -> sTrunc (space (omega n (bool,false)))
   succ x -> sTrunc (space (omega n (Sn (succ x),north)))
\end{lstlisting}
\end{definition}

\begin{theorem} ($\Omega(S^1)=\mathbb{Z}$).
\begin{lstlisting}
data S1 = base
        | loop <i> [ (i=0) -> base ,
                     (i=1) -> base ]

loopS1 : U = Path S1 base base

encode (x:S1) (p:Path S1 base x)
  : helix x
  = subst S1 helix base x p zeroZ

decode : (x:S1) -> helix x -> Path S1 base x = split
  base -> loopIt
  loop @ i -> rem @ i where
    p : Path U (Z -> loopS1) (Z -> loopS1)
      = <j> helix (loop1@j) -> Path S1 base (loop1@j)
    rem : PathP p loopIt loopIt
      = corFib1 S1 helix (\(x:S1)->Path S1 base x) base
        loopIt loopIt loop1 (\(n:Z) ->
        comp (<i> Path loopS1 (oneTurn (loopIt n))
             (loopIt (testIsoPath Z Z sucZ predZ
                      sucpredZ predsucZ n @ i)))
             (<i>(lem1It n)@-i) [])

loopS1eqZ : Path U Z loopS1
  = isoPath Z loopS1 (decode base) (encode base)
    sectionZ retractZ
\end{lstlisting}
\end{theorem}

\bibliographystyle{plain}
\bibliography{hott}

\end{document}

