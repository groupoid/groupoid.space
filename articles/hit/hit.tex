\documentclass{article}
\usepackage[english,ukrainian]{babel}
\usepackage{hyphenat}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{url}
\usepackage{tikz-cd}
\usepackage[utf8]{inputenc}

\theoremstyle{definition}
\newtheorem{theorem}{Теорема}
\newtheorem{definition}{Означення}
\newtheorem{example}{Приклад}
\newcommand*{\incmap}{\hookrightarrow}
\newcommand*{\thead}[1]{\multicolumn{1}{c}{\bfseries #1}}
\lstset{basicstyle=\footnotesize,inputencoding=utf8}

\begin{document}

\title{Випуск IV: Вищі індуктивні типи}
\author{Максим Сохацький $^1$}
\date{ $^1$ Національний технічний університет України \\
       \small Київський політехнічний інститут імені Ігоря Сікорського \\
       4 травня 2019 }
\maketitle

\begin{abstract}
CW-комплекси є ключовими як в теорії гомотопій так і в теорії гомотопічних типів (HoTT) і кодуються
в кубічних системах доведення теоремяк вищі індуктивні типи (HIT). Подібно до
рекурсивних дерев для (ко)індуктивних типів, HIT представляють CW-комплекси.
Ми досліджуємо мотивацію HIT, їхню топологічну роль та реалізацію в Agda Cubical,
зосереджуючись на базових примітивах гомотопічної теорії. \\
\indent {\bf Ключові слова}: Клітинна топологія, Кубічна теорія типів, Вищі індуктивні типи
\end{abstract}

\tableofcontents

\section{CW-комплекси}
CW-комплекси — це простори, побудовані шляхом приєднання клітин зростаючої
розмірності. У HoTT вони кодуються як HITs, де клітини є конструкторами для точок і шляхів.
\begin{definition} (Приєднання клітини).
Приєднання $n$-клітини до простору \( X \) вздовж \( f : S^{n-1} \to X \) є розшарованою сумою:
\[
\shorthandoff{"}
\begin{tikzcd}
S^{n-1} \arrow[r, "f"] \arrow[d, "\iota"] & X \arrow[d, "j"] \\
D^n \arrow[r, "g"]                        & X \cup_f D^n \\
\end{tikzcd}
\]
Тут \( \iota : S^{n-1} \incmap D^n \) — включення межі,
а \( X \cup_f D^n \) — розшарована сума, що приклеює \( n \)-клітину до \( X \) через \( f \). Результат залежить від
гомотопічного класу \( f \).
\end{definition}

\begin{definition} (CW-комплекс).
CW-комплекс — це простір \( X \), побудований індуктивно шляхом приєднання клітин, із скелетною фільтрацією:
\begin{itemize}
    \item \((-1)\)-скелет: \( X_{-1} = \varnothing \).
    \item Для \( n \geq 0 \), \( n \)-скелет \( X_n \) отримується приєднанням \( n \)-клітин до \( X_{n-1} \). Для
      індексів \( J_n \) та відображень \( \{ f_j : S^{n-1} \to X_{n-1}
      \}_{j \in J_n} \), \( X_n \) є розшарованою сумою:
    \[
    \shorthandoff{"}
    \begin{tikzcd}
    \coprod_{j \in J_n} S^{n-1} \arrow[r, "\coprod f_j"] \arrow[d, "\coprod \iota_j"] & X_{n-1} \arrow[d, "i_n"] \\
    \coprod_{j \in J_n} D^n \arrow[r, "\coprod g_j"] & X_n
    \end{tikzcd}
    \]
    де \( \coprod_{j \in J_n} S^{n-1} \), \( \coprod_{j \in
    J_n} D^n \) — диз’юнктні об’єднання, а \( i_n : X_{n-1}
    \incmap X_n \) — включення.
    \item \( X \) — коліміта:
    \[
    \varnothing = X_{-1} \incmap X_0 \incmap X_1 \incmap \dots
    \incmap X,
    \]
    де \( X_n \) — \( n \)-скелет, а \( X = \text{colim}_{n
    \to \infty} X_n \). Послідовність є скелетною фільтрацією.
\end{itemize}
У HoTT CW-комплекси є HITs із конструкторами для клітин і
шляхів для приклеювання.
\end{definition}

\begin{example} (Сфера як CW-комплекс).
\( n \)-сфера \( S^n \) — це CW-комплекс з однією 0-клітиною та однією \( n \)-клітиною:
\begin{itemize}
    \item \( X_0 = \{ \text{base} \} \), точка.
    \item \( X_k = X_0 \) для \( 0 < k < n \), без додаткових клітин.
    \item \( X_n \): Приєднання \( n \)-клітини до \( X_{n-1} =
      \{ \text{base} \} \) вздовж \( f : S^{n-1} \to
      \{ \text{base} \} \):
    Конструктор \(\text{cell}\) приклеює межі до
    \( \text{base} \), отримуючи \( S^n \).
\end{itemize}
\end{example}

\subsection{Мотивація вищих індуктивних типів}
HITs у HoTT дозволяють безпосередньо кодувати топологічні простори, такі як
CW-комплекси. У теорії гомотопій простори будуються шляхом приклеювання
клітин через відображення приєднання. HoTT розглядає типи як простори, елементи
як точки, а рівності як шляхи, що робить HITs природним вибором.
Стандартні індуктивні типи не можуть захопити вищі гомотопії, але
HITs дозволяють конструктори для точок і шляхів. Наприклад, коло \( S^1 \) (Означення 2) має базову точку і петлю, кодуючи його
фундаментальну групу \( \mathbb{Z} \). HITs уникають використання множинних
фактор-просторів, зберігаючи синтетичну природу HoTT. У кубічній теорії типів шляхи є
інтервалами (наприклад, \( <i> \)) з обчислювальним змістом, на відміну від
пропозиційних рівностей, що забезпечує ефективну перевірку типів у таких
інструментах, як Agda Cubical.

\subsection{HITs з конструкторами нескінченності}
Деякі HITs потребують нескінченних конструкторів для просторів, таких як простори Ейленберга-МакЛейна або нескінченна сфера \( S^\infty \).
\begin{lstlisting}[mathescape=true]
def S$^\infty$ : U
 := inductive { base
              | loop (n: Nat) <i> [ (i=0) -> base, (i=1) -> base ]
              }
\end{lstlisting}
Виклики включають перевірку типів, обчислення та виразність.

Agda Cubical використовує кубічні примітиви для роботи з HITs, підтримуючи
нескінченні конструктори через індексовані HITs.

\begin{lstlisting}[mathescape=true]
def HIT-$\infty$ (A: U) : U
 := inductive { point : HIT-$\infty$ A
              | path : (n: Nat) -> PathP ($\lambda$ i, HIT-$\infty$ A) point point
              }
\end{lstlisting}

\section{Вищі індуктивні типи}
CW-комплекси є центральними в HoTT і з’являються в кубічних перевіряльниках типів як HITs.
На відміну від індуктивних типів (рекурсивних дерев), HITs кодують CW-комплекси, захоплюючи
точки (0-клітини) та вищі шляхи (n-клітини). Означення HIT визначає CW-комплекс
через кубічну композицію, початкову алгебру в кубічній моделі.

\subsection{Суспензія}
Суспензія \(\Sigma A\) типу \( A \) — це вищий індуктивний тип, який
конструює новий тип, додаючи дві точки, звані полюсами, і шляхи, що з’єднують
кожну точку \( A \) з цими полюсами. Це фундаментальна конструкція в теорії гомотопій,
яка часто використовується для зсуву гомотопічних груп, наприклад, для отримання \( S^{n+1} \) з \( S^n \).

\begin{definition} (Формування)
Для типу \( A : \mathcal{U} \), суспензія \( \Sigma A : \mathcal{U} \).
\end{definition}

\begin{definition} (Введення)
Суспензія генерується такою вищою індуктивною композиційною структурою:
\( \text{north}, \text{south} : \Sigma A \) та \( \text{merid} : (a : A) \to \text{north} \equiv \text{south} \).
\begin{lstlisting}[mathescape=true]
def $\Sigma$ (A: U) : U
 := inductive { north
              | south
              | merid (a: A) : Path ($\Sigma A$) north south
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація)
Для сімейства типів \( B : \Sigma A \to \mathcal{U} \), точок \( n : B(\text{north}) \), \( s : B(\text{south}) \), і сімейства
залежних шляхів
\[
  m : (a : A) \to \text{PathOver}(B,\text{merid}(a),n,s),
\]
існує залежне відображення \( \text{Ind}_{\Sigma A} : (x : \Sigma A) \to B(x) \), таке що:
\[
\begin{cases}
\text{Ind}_{\Sigma A}(\text{north}) = n \\
\text{Ind}_{\Sigma A}(\text{south}) = s \\
\text{Ind}_{\Sigma A}(\text{merid}(a,i)) = m(a,i)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def PathOver (B: $\Sigma$ A -> U) (a: A) (n: B north) (s: B south) : U
  := PathP ($\lambda$ i , B (merid a @ i)) n s

def Ind$_\Sigma A$ (A: U) (B: $\Sigma$ A -> U) (n: B north) (s: B south)
    (m: (a: A) -> PathOver B (merid a) n s) : (x: $\Sigma$ A) -> B x
 := split { north -> n | south -> s | merid a @ i -> m a @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Обчислення)
\begin{lstlisting}[mathescape=true]
def $\Sigma$-$\beta$ (A: U) (B: $\Sigma A$ -> U) (n: B north) (s: B south)
    (m: (a: A) -> PathOver B (merid a) n s) (x: $\Sigma$ A)
  : Path (B x) ($\Sigma$-I A B n s m x)
    split { north -> n | south -> s | merid a @ i -> m a @ i } x
  = idp (B x) (Ind$_{\Sigma A}$ A B n s m x)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Унікальність)
Будь-які два відображення \( h_1, h_2 : (x : \Sigma A) \to B(x) \) є гомотопними, якщо вони збігаються
на \( \text{north} \), \( \text{south} \) і \( \text{merid} \), тобто,
якщо \( h_1(\text{north}) = h_2(\text{north}) \), \( h_1(\text{south}) = h_2(\text{south}) \),
і \( h_1(\text{merid } a) = h_2(\text{merid } a) \) для всіх \( a : A \).
\end{theorem}

\subsection{Розшарована сума}
Розшарована сума (амальгама) — це вищий індуктивний тип, що конструює тип шляхом
склеювання двох типів \( A \) і \( B \) вздовж спільного типу \( C \) через відображення \( f : C \to A \)
і \( g : C \to B \). Це фундаментальна конструкція в теорії гомотопій,
використовується для моделювання приєднання клітин і кофібрантних об’єктів, узагальнюючи
топологічне поняття розшарованої суми.

\begin{definition} (Формування)
Для типів \( A, B, C : \mathcal{U} \) і відображень \( f : C \to A \), \( g : C \to B \),
існує розшарована суса \( \sqcup(A,B,C,f,g) : \mathcal{U} \).
\end{definition}

\begin{definition} (Введення)
Розшарована сума генерується такою вищою індуктивною композиційною структурою:
\[
\begin{cases}
\text{po$_1$} : A \to \sqcup(A,B,C,f,g) \\
\text{po$_2$} : B \to \sqcup(A,B,C,f,g) \\
\text{po$_3$} : (c : C) \to \text{po$_1$}(f(c)) \equiv \text{po$_2$}(g(c))
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\sqcup$ (A B C: U) (f: C -> A) (g: C -> B) : U
 := inductive { po$_1$ (_: A)
              | po$_2$ (_: B)
              | po$_3$ (c: C) : po$_1$(f(c)) $\equiv$ po$_2$(g(c))
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація)
Для типу \( D : \mathcal{U} \), відображень \( u : A \to D \), \( v : B \to D \),
і сімейства шляхів \( p : (c : C) \to u(f(c)) \equiv v(g(c)) \),
існує відображення \( \text{Ind}_\sqcup : \sqcup(A,B,C,f,g) \to D \), таке що:
\[
\begin{cases}
\text{Ind}_\sqcup(\text{po$_1$}(a)) = u(a) \\
\text{Ind}_\sqcup(\text{po$_2$}(b)) = v(b) \\
\text{Ind}_\sqcup(\text{po$_3$}(c,i)) = p(c,i)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def PathOver (A B C : U) (f : C $\rightarrow$ A) (g : C $\rightarrow$ B)
    (D : $\sqcup$ A B C f g $\rightarrow$ U)
    (c : C) (u : D (po$_1$ (f c))) (v : D (po$_2$ (g c))) : U
 := PathP ($\lambda$ i, D (po$_3$ c i)) u v

def Ind$_\sqcup$ : (A B C : U) (f : C $\rightarrow$ A) (g : C $\rightarrow$ B)
    (D : $\sqcup$ A B C f g $\rightarrow$ U)
    (u : (a : A) $\rightarrow$ D (po$_1$ a))
    (v : (b : B) $\rightarrow$ D (po$_2$ b))
    (p : (c : C) $\rightarrow$ PathOver D c (u (f c)) (v (g c)))
  : (x : $\sqcup$ A B C f g) $\rightarrow$ D x
 := split { po$_1$ a $\rightarrow$ u a | po$_2$ b $\rightarrow$ v b | po$_3$ c @ i $\rightarrow$ p c @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Обчислення)
Для \( x : \sqcup(A,B,C,f,g) \),
\[
\begin{cases}
\text{Ind$_\sqcup$}(\text{po$_1$}(a)) \equiv u(a) \\
\text{Ind$_\sqcup$}(\text{po$_2$}(b)) \equiv v(b) \\
\text{Ind$_\sqcup$}(\text{po$_3$}(c,i)) \equiv p(c,i)
\end{cases}
\]
\end{theorem}

\begin{theorem} (Унікальність)
Будь-які два відображення \( u, v : \sqcup(A,B,C,f,g) \to D \) є гомотопними,
якщо вони збігаються на \( \text{po}_1 \), \( \text{po}_2 \) і \( \text{po}_3 \), тобто,
якщо \( u(\text{po}_1(a)) = v(\text{po}_1(a)) \) для всіх \( a : A \), \( u(\text{po}_2(b)) = v(\text{po}_2(b)) \)
для всіх \( b : B \), і \( u(\text{po}_3(c)) = v(\text{po}_3(c)) \) для всіх \( c : C \).
\end{theorem}

\begin{example} (Приєднання клітини)
Розшарована сума моделює приєднання \( n \)-клітини до простору \( X \).
Дано \( f : S^{n-1} \to X \) і включення \( g : S^{n-1} \to D^n \),
розшарована сума \( \sqcup(X,D^n,S^{n-1},f,g) \) є
простором \( X \cup_f D^n \), що приклеює \( n \)-диск до \( X \) вздовж \( f \).
\[
\shorthandoff{"}
\begin{tikzcd}
S^{n-1} \arrow[r, "f"] \arrow[d, "g"] & X \arrow[d] \\
D^n \arrow[r] & X \cup_f D^n
\end{tikzcd}
\]
\end{example}

\subsection{Сфери}
Сфери — це вищі індуктивні типи (HITs) із шляхами вищої розмірності,
що представляють фундаментальні топологічні простори.

\begin{definition} (Точкові n-сфери)
\( n \)-сфера \( S^n \) визначається рекурсивно як тип у
всесвіті \( \mathcal{U} \) за допомогою загальної рекурсії за розмірностями:
\[
\mathbb{S}^n :=
\begin{cases}
\text{point} : \mathbb{S}^n, \\
\text{surface} :\ <i_1,...i_n> [\ (i_1=0) \rightarrow point, (i_1=1) \rightarrow point,\ ... \\
\hspace{3.47cm} (i_n=0) \rightarrow point, (i_n=1) \rightarrow point\ ]
\end{cases}
\]
\end{definition}

\begin{definition} (Суспендовані n-сфери)
\( n \)-сфера \( S^n \) визначається рекурсивно як тип у
всесвіті \( \mathcal{U} \) за допомогою загальної рекурсії над натуральними
числами \( \mathbb{N} \). Для кожного \( n \in \mathbb{N} \),
тип \( S^n : \mathcal{U} \) визначається так:
\[
\mathbb{S}^n :=
\begin{cases}
S^0 = \mathbf{2}, \\
S^{n+1} = \Sigma(S^n).
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def sphere : $\mathbb{N}$ $\to$ U := $\mathbb{N}\text{-iter}$ U $\mathbf{2}$ $\Sigma$
\end{lstlisting}
Ця ітеративна означення застосовує функтор суспензії \( \Sigma \)
до базового типу \( \mathbf{2} \) (0-сфера) \( n \) разів, щоб отримати \( S^n \).
\end{definition}

\begin{example} (Сфера як CW-комплекс)
\( n \)-сфера \( S^n \) може бути побудована як CW-комплекс з
однією 0-клітиною та однією \( n \)-клітиною:

\[
\begin{cases}
X_0 = \{ \text{base} \}, \text{ одна точка} \\
X_k = X_0 \text{ для } 0 < k < n, \text{ без додаткових клітин} \\
X_n: \text{Приєднання } n\text{-клітини до } X_{n-1} = \{ \text{base} \} \text{ вздовж } f : S^{n-1} \to \{ \text{base} \}
\end{cases}
\]

Конструктор \( \text{cell} \) приклеює межу \( n \)-клітини
до базової точки, отримуючи тип \( S^n \).
\end{example}

\subsection{Хаб і спиці}
Конструкція хаб і спиці \( \odot \) визначає \( n \)-відсікання,
гарантуючи, що тип не має нетривіальних гомотопічних груп вище
розмірності \( n \). Вона моделює тип як CW-комплекс із
хабом (центральною точкою) і спицями (шляхами до точок).

\begin{definition} (Хаб і спиці)
Для типів \( S, A : \mathcal{U} \), тип хаб і спиці \( \odot(S,A) : \mathcal{U} \).
\[
\begin{cases}
\text{base} : A \to \odot(S,A) \\
\text{hub} : (S \to \odot(S,A)) \to \odot(S,A) \\
\text{spoke} : (f : S \to \odot(S,A)) \to (s : S) \to \text{hub}(f) \equiv f(s) \\
\text{hubEq} : (x, y : A) \to (p : S \to x \equiv y) \to \text{base}(x) \equiv \text{base}(y) \\
\text{spokeEq} : (x, y : A) \to (p : S \to x \equiv y) \to (s : S) \to \text{hubEq}(x,y,p) \equiv \text{base}(p(s))
\end{cases}
\]
\begin{lstlisting}
data hubSpokes (S A: U)
   = base (x: A)
   | hub (f: S -> hubSpokes S A)
   | spoke (f: S -> hubSpokes S A) (s:S)
     <i> [ (i=0) -> hub f , (i=1) -> f s ]
   | hubEq (x y: A) (p: S -> Path A x y)
     <i> [ (i=0) -> base x , (i=1) -> base y ]
   | spokeEq (x y: A) (p: S -> Path A x y) (s: S)
     <i> [ (i=0) -> hubEq x y p , (i=1) -> base (p s) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація \( \text{hubSpokes} \))
Для типу \( B : \mathcal{U} \), відображення \( g : A \to B \),
точки \( h : (S \to \text{hubSpokes } S A) \to B \),
і відображень шляхів, що забезпечують когерентність, існує
\( \text{rec}_{\text{hubSpokes}} : \text{hubSpokes } S A \to B \),
таке що \( \text{rec}_{\text{hubSpokes}}(\text{base } x) = g(x) \)
і \( \text{rec}_{\text{hubSpokes}}(\text{hub } f) = h(f) \).
\end{theorem}

\subsection{Відсікання множин}
Відсікання множин (0-відсікання), позначене \( \| A \|_0 \),
гарантує, що тип є множиною, з гомотопічними групами, що зникають вище розмірності 0.

\begin{definition} (Відсікання множин)
Для \( A : \mathcal{U} \), \( \| A \|_0 : \mathcal{U} \).
\[
\begin{cases}
\text{inc} : A \to \| A \|_0 \\
\text{squash} : (a, b : \| A \|_0) \to (p, q : a \equiv b) \to p \equiv q
\end{cases}
\]
\begin{lstlisting}
data setTrunc (A: U)
   = inc (a: A)
   | squash (a b: setTrunc A) (p q: Path (setTrunc A) a b)
     <i j> [ (i = 0) -> p @ j, (i = 1) -> q @ j,
             (j = 0) -> a,     (j = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація \( \| A \|_0 \))
Для множини \( B : \mathcal{U} \) (тобто \( \text{isSet}(B) \)), відображення \( f : A \to B \),
існує \( \text{setTruncRec} : \| A \|_0 \to B \), таке що \( \text{setTruncRec}(\text{inc}(a)) = f(a) \).
\end{theorem}

\subsection{Відсікання групоїдів}
Відсікання групоїдів (1-відсікання), позначене \( \| A \|_1 \), гарантує, що
тип є 1-групоїдом, з гомотопічними групами, що зникають вище розмірності 1.

\begin{definition} (Відсікання групоїдів)
Для \( A : \mathcal{U} \), \( \| A \|_1 : \mathcal{U} \).
\[
\begin{cases}
\text{inc} : A \to \| A \|_1 \\
\text{squash} : (a, b : \| A \|_1) \to (p, q : a \equiv b) \to (r, s : p \equiv q) \to r \equiv s
\end{cases}
\]
\begin{lstlisting}
data grpdTrunc (A: U)
   = inc (a: A)
   | squash (a b: grpdTrunc A)
            (p q: Path (grpdTrunc A) a b)
            (r s: Path (Path (grpdTrunc A) a b) p q)
     <i j k> [ (i = 0) -> r @ j @ k, (i = 1) -> s @ j @ k,
               (j = 0) -> p @ k,     (j = 1) -> q @ k,
               (k = 0) -> a,         (k = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація \( \| A \|_1 \))
Для 1-групоїда \( B : \mathcal{U} \) (тобто \( \text{isGroupoid}(B) \)),
відображення \( f : A \to B \), існує \( \text{grpdTruncRec} : \| A \|_1 \to B \),
таке що \( \text{grpdTruncRec}(\text{inc}(a)) = f(a) \).
\end{theorem}

\subsection{Фактор-простори множин}
Фактор-простори множин конструюють тип \( A \), факторизований за
відношенням \( R : A \to A \to \mathcal{U} \), гарантуючи, що результат є множиною.

\begin{definition} (Квоцієнт множин)
Для типу \( A : \mathcal{U} \) і відношення \( R : A \to A \to \mathcal{U} \),
факстор-простір множин \( \text{setQuot } A R : \mathcal{U} \) визначається конструкторами:
\[
\begin{cases}
\text{quotient} : A \to \text{setQuot}(A,R) \\
\text{identification} : (a, b : A) \to R a b \to \text{quotient}(a) \equiv \text{quotient}(b) \\
\text{trunc} : (a, b : \text{setQuot}(A,R)) \to (p, q : a \equiv b \to p \equiv q
\end{cases}
\]
\begin{lstlisting}
data setQuot (A: U) (R: A -> A -> U)
   = quotient (a: A)
   | identification (a b: A) (r: R a b)
     <i> [ (i=0) -> quotient a, (i=1) -> quotient b ]
   | trunc (a b : setQuot A R) (p q : Path (setQuot A R) a b)
     <i j> [ (i = 0) -> p @ j , (i = 1) -> q @ j ,
             (j = 0) -> a ,     (j = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація \( \text{setQuot} \))
Для сімейства типів \( B : \text{setQuot } A R \to \mathcal{U} \) з \( \text{isSet}(B x) \),
і відображень \( f : (x : A) \to B(\text{quotient } x) \),
\( g : (a, b : A) \to (r : R a b) \to \text{PathP} (<i> B(\text{idq } a b r @ i)) (f a) (f b) \),
існує \( \text{setQuotElim} : \Pi_{x:\text{setQuot } A R} B(x) \), таке що \( \text{setQuotElim}(\text{quotient } a) = f a \).
\end{theorem}

\subsection{Фактор-простори групоїдів}
Фактор-простори групоїдів розширюють фактор-простори множин для створення 1-групоїда,
включаючи конструктори вищих шляхів.

\begin{definition} (Фактор-простір групоїдів)
Для типу \( A : \mathcal{U} \) і відношення \( R : A \to A \to \mathcal{U} \), квоцієнт групоїдів \( \text{grpdQuot } A R : \mathcal{U} \) включає конструктори для точок, шляхів і вищих шляхів, що забезпечують структуру 1-групоїда. (Примітка: Повне означення потребує додаткової структури, частково опущено для стислості.)
\end{definition}

\subsection{Букет}
Букет двох точкових типів \( A \) і \( B \), позначена \( A \vee B \),
є вищим індуктивним типом (HIT), який представляє об’єднання \( A \)
і \( B \) з ідентифікованими базовими точками. Топологічно
вона відповідає \( A \times \{ y_0 \} \cup \{ x_0 \} \times B \),
де \( x_0 \) і \( y_0 \) — базові точки \( A \) і \( B \), відповідно.

\begin{definition} (Формування)
Для точкових типів \( A, B : \text{pointed} \), Букет \( \text{Wedge } A B : \mathcal{U} \).
\end{definition}

\begin{definition} (Введення)
Букет генерується такою вищою індуктивною композиційною структурою:
\[
\begin{cases}
\text{winl} : A.1 \to \text{Wedge } A B \\
\text{winr} : B.1 \to \text{Wedge } A B \\
\text{wglue} : \text{Path}_{\text{Wedge } A B} (\text{winl } A.2, \text{winr } B.2)
\end{cases}
\]
\begin{lstlisting}
data Wedge (A : pointed) (B : pointed)
   = winl (a : A.1)
   | winr (b : B.1)
   | wglue <x> [ (x = 0) -> winl A.2 , (x = 1) -> winr B.2 ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація)
Для типу \( C : \mathcal{U} \), відображень \( f : A.1 \to C \), \( g : B.1 \to C \), і шляху \( p : \text{Path}_C (f (A.2), g (B.2)) \), існує відображення \( \text{WedgeRec} : \text{Wedge } A B \to C \), таке що:
\[
\begin{cases}
\text{WedgeRec}(\text{winl } a) = f(a) \\
\text{WedgeRec}(\text{winr } b) = g(b) \\
\text{WedgeRec}(\text{wglue } @ \, x) = p \, @ \, x
\end{cases}
\]
\begin{lstlisting}
WedgeRec (A B : pointed) (C : U) (f : A.1 -> C) (g : B.1 -> C)
         (p : Path C (f A.2) (g B.2))
   : Wedge A B -> C
   = split
     winl a -> f a
     winr b -> g b
     wglue @ x -> p @ x
\end{lstlisting}
\end{theorem}

\begin{theorem} (Обчислення)
Для \( z : \text{Wedge } A B \),
\[
\begin{cases}
\text{WedgeRec}(\text{winl } a) \equiv f(a) \\
\text{WedgeRec}(\text{winr } b) \equiv g(b) \\
\text{WedgeRec}(\text{wglue } @ \, x) \equiv p \, @ \, x
\end{cases}
\]
\end{theorem}

\begin{theorem} (Унікальність)
Будь-які два відображення \( h_1, h_2 : \text{Wedge } A B \to C \) є гомотопними, якщо
вони збігаються на \( \text{winl} \), \( \text{winr} \) і \( \text{wglue} \),
тобто, якщо \( h_1(\text{winl } a) = h_2(\text{winl } a) \) для
всіх \( a : A.1 \), \( h_1(\text{winr } b) = h_2(\text{winr } b) \) для
всіх \( b : B.1 \), і \( h_1(\text{wglue}) = h_2(\text{wglue}) \).
\end{theorem}

\subsection{Смеш-добуток}
Смеш-добуток двох точкових типів \( A \) і \( B \), позначений \( A \wedge B \),
є вищим індуктивним типом, який квоцієнтує продукт \( A \times B \) за
клинною сумою \( A \vee B \). Він представляє простір \( A \times B / (A \times \{ y_0 \} \cup \{ x_0 \} \times B) \),
зводячи букет до однієї точки.

\begin{definition} (Формування)
Для точкових типів \( A, B : \text{pointed} \), Смеш-добуток \( \text{Smash } A B : \mathcal{U} \).
\end{definition}

\begin{definition} (Введення)
Смеш-добуток генерується такою вищою індуктивною композиційною структурою:
\[
\begin{cases}
\text{spair} : A.1 \to B.1 \to \text{Smash } A B \\
\text{smash} : (a : A.1) \to (b : B.1) \to \text{Path}_{\text{Smash } A B} (\text{spair } a \, B.2, \text{spair } A.2 \, b) \\
\text{smashpt} : \text{Path}_{\text{Smash } A B} (\text{smash } A.2 \, B.2, \text{spair } A.2 \, B.2)
\end{cases}
\]
\begin{lstlisting}
data Smash (A : pointed) (B : pointed)
   = spair (a : A.1) (b : B.1)
   | smash (a : A.1) (b : B.1) <x> [(x=0) -> spair a B.2, (x=1) -> spair A.2 b]
   | smashpt <x y> [(x=0) -> smash A.2 B.2 @ y,
                    (x=1) -> spair A.2 B.2,
                    (y=0) -> spair A.2 B.2,
                    (y=1) -> spair A.2 B.2]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація)
Для типу \( C : \mathcal{U} \), відображення \( f : A.1 \to B.1 \to C \),
шляхів \( g : (a : A.1) \to (b : B.1) \to \text{Path}_C (f a \, B.2, f A.2 \, b) \),
і 2-шляху \( h : \text{Path}_{\text{Path}_{\text{Smash } A B} (f A.2 \, B.2, f A.2 \, B.2)} (g A.2 \, B.2, \text{idp } (f A.2 \, B.2)) \),
існує відображення \( \text{SmashRec} : \text{Smash } A B \to C \), таке що:
\[
\begin{cases}
\text{SmashRec}(\text{spair } a \, b) = f(a, b) \\
\text{SmashRec}(\text{smash } a \, b \, @ \, x) = g(a, b) \, @ \, x \\
\text{SmashRec}(\text{smashpt } @ \, x \, @ \, y) = h \, @ \, x \, @ \, y
\end{cases}
\]
\end{theorem}

\begin{theorem} (Обчислення)
Для \( z : \text{Smash } A B \),
\[
\begin{cases}
\text{SmashRec}(\text{spair } a \, b) \equiv f(a, b) \\
\text{SmashRec}(\text{smash } a \, b \, @ \, x) \equiv g(a, b) \, @ \, x \\
\text{SmashRec}(\text{smashpt } @ \, x \, @ \, y) \equiv h \, @ \, x \, @ \, y
\end{cases}
\]
\end{theorem}

\begin{theorem} (Унікальність)
Будь-які два відображення \( h_1, h_2 : \text{Smash } A B \to C \) є гомотопними,
якщо вони збігаються на \( \text{spair} \), \( \text{smash} \) і \( \text{smashpt} \).
\end{theorem}

\begin{example} (Смеш-добуток сфер)
Смеш-добуток \( S^1 \wedge S^1 \) є гомотопічно еквівалентним \( S^2 \),
оскільки він квоцієнтує тор \( S^1 \times S^1 \) за клин \( S^1 \vee S^1 \),
зводячи базові точки та їхні волокна.
\end{example}

\subsection{З’єднання}
З’єднання двох типів \( A \) і \( B \), позначене \( A * B \),
є вищим індуктивним типом, який конструює тип шляхом
з’єднання кожної точки \( A \) з кожною точкою \( B \) через шлях.
Топологічно воно відповідає з’єднанню просторів, формуючи
простір, що інтерполює між \( A \) і \( B \).

\begin{definition} (Формування)
Для типів \( A, B : \mathcal{U} \), з’єднання \( \text{Join } A B : \mathcal{U} \).
\end{definition}

\begin{definition} (Введення)
З’єднання генерується такою вищою індуктивною композиційною структурою:
\[
\begin{cases}
\text{joinl} : A \to \text{Join } A B \\
\text{joinr} : B \to \text{Join } A B \\
\text{join} : (a : A) \to (b : B) \to \text{Path}_{\text{Join } A B} (\text{joinl } a, \text{joinr } b)
\end{cases}
\]
\begin{lstlisting}
data Join (A : U) (B : U)
   = joinl (a : A)
   | joinr (b : B)
   | join (a:A) (b:B) <i> [(i=0) -> joinl a, (i=1) -> joinr b]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація)
Для типу \( C : \mathcal{U} \), відображень \( f : A \to C \), \( g : B \to C \),
і сімейства шляхів \( h : (a : A) \to (b : B) \to \text{Path}_C (f a, g b) \),
існує відображення \( \text{JoinRec} : \text{Join } A B \to C \), таке що:
\[
\begin{cases}
\text{JoinRec}(\text{joinl } a) = f(a) \\
\text{JoinRec}(\text{joinr } b) = g(b) \\
\text{JoinRec}(\text{join } a \, b \, @ \, i) = h(a, b) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
JoinRec (A B C : U) (f : A -> C) (g : B -> C)
        (h : (a : A) -> (b : B) -> Path C (f a) (g b))
   : Join A B -> C
   = split
     joinl a -> f a
     joinr b -> g b
     join a b @ i -> h a b @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Обчислення)
Для \( z : \text{Join } A B \),
\[
\begin{cases}
\text{JoinRec}(\text{joinl } a) \equiv f(a) \\
\text{JoinRec}(\text{joinr } b) \equiv g(b) \\
\text{JoinRec}(\text{join } a \, b \, @ \, i) \equiv h(a, b) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Унікальність)
Будь-які два відображення \( h_1, h_2 : \text{Join } A B \to C \) є гомотопними,
якщо вони збігаються на \( \text{joinl} \), \( \text{joinr} \) і \( \text{join} \).
\end{theorem}

\begin{example} (З’єднання сфер)
З’єднання \( S^0 * S^0 \) є гомотопічно еквівалентним \( S^1 \), оскільки воно з’єднує
дві точки (з кожної \( S^0 \)) шляхами, формуючи структуру, подібну до кола.
\end{example}

\subsection{Коліміти}
Коліміти конструюють границю послідовності типів, з’єднаних відображеннями,
наприклад, пропозіційні відсікання.

\begin{definition} (Коліміта)
Для послідовності типів \( A : \text{nat} \to \mathcal{U} \) і
відображень \( f : (n : \mathbb{N}) \to A n \to A(\text{succ}(n)) \),
тип коліміти \( \text{colimit}(A,f) : \mathcal{U} \).
\[
\begin{cases}
\text{ix} : (n : \text{nat}) \to A n \to \text{colimit}(A,f) \\
\text{gx} : (n : \text{nat}) \to (a : A(n)) \to \text{ix} (\text{succ}(n),f(n,a)) \equiv \text{ix}(n,a)
\end{cases}
\]
\begin{lstlisting}
def colimit (A : nat -> U) (f : (n : nat) -> A n -> A (succ n)) : U
 := inductive { ix (n : nat) (x: A n)
              | gx (n : nat) (a: A n)
                <i> [ (i=0) -> ix (succ n) (f n a),
                      (i=1) -> ix n a ]
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація \( \text{colimit} \))
Для типу \( P : \text{colimit } A f \to \mathcal{U} \),
з \( p : (n : \text{nat}) \to (x : A n) \to P(\text{ix}(n, x)) \)
і \( q : (n : \text{nat}) \to (a : A n) \to \text{PathP} (\langle i \rangle P(\text{gx}(n, a) @ i)) (p (\text{succ } n) (f n a)) (p n a) \),
існує \( i : \Pi_{x:\text{colimit } A f} P(x) \), таке що \( i(\text{ix}(n, x)) = p n x \).
\end{theorem}

\subsection{Еквалайзер}
Еквалайзер двох відображень \( f, g : A \to B \) — це вищий індуктивний
тип (HIT), який конструює тип, що складається з елементів у \( B \),
де \( f \) і \( g \) збігаються, разом із шляхами, що забезпечують цю рівність.
Це фундаментальна конструкція в теорії гомотопій,
яка захоплює підпростір \( B \), де \( f(a) = g(a) \) для \( a : A \).

\begin{definition} (Формування)
Для типів \( A, B : \mathcal{U} \) і відображень \( f, g : A \to B \),
еквалайзер \( \text{coeq } A B f g : \mathcal{U} \).
\end{definition}

\begin{definition} (Введення)
Еквалайзер генерується такою вищою
індуктивною композиційною структурою:
\[
\begin{cases}
\text{inC} : B \to \text{coeq } A B f g \\
\text{glueC} : (a : A) \to \text{Path}_{\text{coeq } A B f g} (\text{inC } (f a), \text{inC } (g a))
\end{cases}
\]
\begin{lstlisting}
data coeq (A B: U) (f g: A -> B)
   = inC (_: B)
   | glueC (a: A) <i> [(i=0) -> inC (f a), (i=1) -> inC (g a) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація)
Для типу \( C : \mathcal{U} \), відображення \( h : B \to C \), і сімейства шляхів \( y : (x : A) \to \text{Path}_C (h (f x), h (g x)) \), існує відображення \( \text{coequRec} : \text{coeq } A B f g \to C \), таке що:
\[
\begin{cases}
\text{coequRec}(\text{inC } x) = h(x) \\
\text{coequRec}(\text{glueC } x \, @ \, i) = y(x) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
coequRec (A B C : U) (f g : A -> B) (h: B -> C) (y: (x : A) -> Path C (h (f x)) (h (g x)))
   : (z : coeq A B f g) -> C
   = split
     inC x -> h x
     glueC x @ i -> y x @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Обчислення)
Для \( z : \text{coeq } A B f g \),
\[
\begin{cases}
\text{coequRec}(\text{inC } x) \equiv h(x) \\
\text{coequRec}(\text{glueC } x \, @ \, i) \equiv y(x) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Унікальність)
Будь-які два відображення \( h_1, h_2 : \text{coeq } A B f g \to C \) є гомотопними,
якщо вони збігаються на \( \text{inC} \) і \( \text{glueC} \), тобто,
якщо \( h_1(\text{inC } x) = h_2(\text{inC } x) \) для
всіх \( x : B \) і \( h_1(\text{glueC } a) = h_2(\text{glueC } a) \) для всіх \( a : A \).
\end{theorem}

\begin{example} (Еквалайзер як підпростір)
Еквалайзер \( \text{coeq } A B f g \) представляє підпростір
\( B \), де \( f(a) = g(a) \). Наприклад, якщо \( A = B = \mathbb{R} \)
і \( f(x) = x^2 \), \( g(x) = x \), еквалайзер захоплює точки,
де \( x^2 = x \), тобто \( \{0, 1\} \).
\end{example}

\subsection{Еквалайзер шляхів}
Еквалайзер шляхів — це вищий індуктивний тип, який узагальнює
еквалайзер для роботи з парами шляхів у \( B \). Дано
відображення \( p : A \to (b_1, b_2 : B) \times (\text{Path}_B (b_1, b_2)) \times (\text{Path}_B (b_1, b_2)) \),
він конструює тип, де елементи \( A \) породжують пари
шляхів між точками в \( B \), із шляхами, що з’єднують
кінцеві точки цих шляхів.

\begin{definition} (Формування)
Для типів \( A, B : \mathcal{U} \) і відображення \( p : A \to (b_1, b_2 : B) \times (\text{Path}_B (b_1, b_2)) \times (\text{Path}_B (b_1, b_2)) \), шляховий еквалайзер \( \text{coeqP } A B p : \mathcal{U} \).
\end{definition}

\begin{definition} (Введення)
Еквалайзер шляхів генерується такою вищою індуктивною композиційною структурою:
\[
\begin{cases}
\text{inP} : B \to \text{coeqP } A B p \\
\text{glueP} : (a : A) \to \text{Path}_{\text{coeqP } A B p} (\text{inP } (((p \, a).2.2.1) \, @ \, 0), \text{inP } (((p \, a).2.2.2) \, @ \, 1))
\end{cases}
\]
\begin{lstlisting}
data coeqP (A B: U) (p : A -> (b1 b2: B) * (_: Path B b1 b2) * (Path B b1 b2))
   = inP (b: B)
   | glueP (a:A) <i> [(i=0) -> inP (((p a).2.2.1) @ 0), (i=1) -> inP (((p a).2.2.2) @ 1) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація)
Для типу \( C : \mathcal{U} \), відображення \( h : B \to C \), і сімейства шляхів \( y : (a : A) \to \text{Path}_C (h (((p \, a).2.2.1) \, @ \, 0), h (((p \, a).2.2.2) \, @ \, 1)) \), існує відображення \( \text{coequPRec} : \text{coeqP } A B p \to C \), таке що:
\[
\begin{cases}
\text{coequPRec}(\text{inP } b) = h(b) \\
\text{coequPRec}(\text{glueP } a \, @ \, i) = y(a) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
coequPRec (A B C : U) (p : A -> (b1 b2: B) * (_: Path B b1 b2) * (Path B b1 b2))
          (h: B -> C) (y: (a : A) -> Path C (h (((p a).2.2.1) @ 0)) (h (((p a).2.2.2) @ 1)))
   : (z : coeqP A B p) -> C
   = split
     inP b -> h b
     glueP a @ i -> y a @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Обчислення)
Для \( z : \text{coeqP } A B p \),
\[
\begin{cases}
\text{coequPRec}(\text{inP } b) \equiv h(b) \\
\text{coequPRec}(\text{glueP } a \, @ \, i) \equiv y(a) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Унікальність)
Будь-які два відображення \( h_1, h_2 : \text{coeqP } A B p \to C \) є гомотопними,
якщо вони збігаються на \( \text{inP} \) і \( \text{glueP} \), тобто,
якщо \( h_1(\text{inP } b) = h_2(\text{inP } b) \) для всіх \( b : B \)
і \( h_1(\text{glueP } a) = h_2(\text{glueP } a) \) для всіх \( a : A \).
\end{theorem}

\begin{example} (Шляховий еквалайзер для гомотопії)
Шляховий еквалайзер може моделювати простори, де елементи \( A \) задають
пари шляхів між точками в \( B \). Наприклад, якщо \( p(a) \) надає
два шляхи від \( b_1 \) до \( b_2 \) у \( B \), \( \text{coeqP} \) конструює тип,
що з’єднує початкові та кінцеві точки цих шляхів,
корисний для вивчення гомотопічних класів.
\end{example}

\subsection{K(G,n)}
Простори Ейленберга-МакЛейна \( K(G,n) \) мають єдину нетривіальну
гомотопічну групу \( \pi_n(K(G,n)) = G \). Вони визначаються за допомогою відсікань і суспензій.

\begin{definition} (K(G,n))
Для абелевої групи \( G : \text{abgroup} \), тип \( KGn G : \text{nat} \to \mathcal{U} \).
\[
\begin{cases}
n = 0: \text{discreteTopology}(G) \\
n \geq 1: \text{succ}(n) = \text{nTrunc}(\text{suspension}(K1' (G.1, G.2.1)) n) (\text{succ} n)
\end{cases}
\]
\begin{lstlisting}
KGn (G: abgroup)
  : nat -> U
  = split
    zero -> discreteTopology G
    succ n -> nTrunc (suspension (K1' (G.1,G.2.1)) n) (succ n)
\end{lstlisting}
\end{definition}

\begin{theorem} (Елімінація \( KGn \))
Для \( n \geq 1 \), типу \( B : \mathcal{U} \) з \( \text{isNGroupoid}(B, \text{succ } n) \),
і відображення \( f : \text{suspension}(K1' G) \to B \), існує
\( \text{rec}_{KGn} : KGn G (\text{succ } n) \to B \),
визначене через \( \text{nTruncRec} \).
\end{theorem}

\subsection{Локалізація}
Локалізація конструює \( F \)-локальний тип із типу \( X \),
щодо сімейства відображень \( F_A : S(a) \to T(a) \).

\begin{definition} (Модальність локалізації)
Для сімейства відображень \( F_A : S(a) \to T(a) \),
\( F \)-локалізація \( L^{AST}_F(X) : \mathcal{U} \).
\[
\begin{cases}
\text{center} : X \to L_{F_A}(X) \\
\text{ext} : (a : A) \to (S(a) \to L_{F_A}(X)) \to T(a) \to L_{F_A}(X) \\
\text{isExt} : (a : A) \to (f : S(a) \to L_{F_A}(X)) \to (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (\text{ext } a f (F a s), f s) \\
\text{extEq} : (a : A) \to (g, h : T(a) \to L_{F_A}(X)) \to (p : (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (g (F a s), h (F a s))) \to (t : T(a)) \to \text{Path}_{L_{F_A}(X)} (g t, h t) \\
\text{isExtEq} : (a : A) \to (g, h : T(a) \to L_{F_A}(X)) \to (p : (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (g (F a s), h (F a s))) \to (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (\text{extEq } a g h p (F a s), p s)
\end{cases}
\]
\begin{lstlisting}
data Localize (A X: U) (S T: A -> U) (F : (x:A) -> S x -> T x)
   = center (x: X)
   | ext (a: A) (f: S a -> Localize A X S T F) (t: T a)
   | isExt (a: A) (f: S a -> Localize A X S T F) (s: S a) <i>
     [ (i=0) -> ext a f (F a s) , (i=1) -> f s ]
   | extEq (a: A) (g h: T a -> Localize A X S T F)
     (p: (s : S a) -> Path (Localize A X S T F) (g (F a s)) (h (F a s)))
     (t : T a) <i> [ (i=0) -> g t , (i=1) -> h t ]
   | isExtEq (a: A) (g h : T a -> Localize A X S T F)
     (p: (s : S a) -> Path (T a -> Localize A X S T F) (g (F a s)) (h (F a s)))
     (s : S a) <i> [ (i=0) -> extEq a g h p (F a s) , (i=1) -> p s ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Індукція локалізації)
Для будь-якого \( P : \Pi_{X:U} L_{F_A}(X) \to U \) з \( \{n, r, s\} \), що задовольняють умови когерентності,
існує \( i : \Pi_{x:L_{F_A}(X)} P(x) \), таке що \( i \cdot \text{center}_X = n \).
\end{theorem}

\section{Висновок}
HITs кодують CW-комплекси в HoTT, поєднуючи топологію і теорію типів.
Вони захоплюють приєднання клітин, з прикладами, такими як сфери, тори та відсікання.
Конструктори нескінченності розширюють HITs до нескінченних просторів, оброблювані кубічними примітивами Agda Cubical та індексованими HITs.

\bibliographystyle{plain}
\begin{thebibliography}{9}
\bibitem{univalent}
The Univalent Foundations Program, \emph{Homotopy Type Theory: Univalent Foundations of Mathematics}, IAS, 2013.
\bibitem{cubicaltt}
C. Cohen, T. Coquand, S. Huber, A. Mörtberg, \emph{Cubical Type Theory}, Journal of Automated Reasoning, 2018.
\bibitem{agda-cubical}
A. Mörtberg et al., \emph{Agda Cubical Library}, \url{https://github.com/agda/cubical}, 2023.
\bibitem{hott-book}
M. Shulman, \emph{Higher Inductive Types in HoTT}, \url{https://arxiv.org/abs/1705.07088}, 2017.
\bibitem{localization}
J. D. Christensen, M. Opie, E. Rijke, L. Scoccola, \emph{Localization in Homotopy Type Theory}, \url{https://arxiv.org/pdf/1807.04155.pdf}, 2018.
\bibitem{modalities}
E. Rijke, M. Shulman, B. Spitters, \emph{Modalities in Homotopy Type Theory}, \url{https://arxiv.org/pdf/1706.07526v6.pdf}, 2017.
\bibitem{synthetic-spectra}
M. Riley, E. Finster, D. R. Licata, \emph{Synthetic Spectra via a Monadic and Comonadic Modality}, \url{https://arxiv.org/pdf/2102.04099.pdf}, 2021.
\end{thebibliography}

\end{document}