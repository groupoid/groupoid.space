\documentclass{article}
\usepackage[english]{babel}
\usepackage{hyphenat}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{url}
\usepackage{tikz-cd}
\usepackage[utf8]{inputenc}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newcommand*{\incmap}{\hookrightarrow}
\newcommand*{\thead}[1]{\multicolumn{1}{c}{\bfseries #1}}
\lstset{basicstyle=\footnotesize,inputencoding=utf8}

\begin{document}

\title{Issue IV: Higher Inductive Types}
\author{Maxim Sokhatsky $^1$}
\date{ $^1$ National Technical University of Ukraine \\
       \small Igor Sikorsky Kyiv Polytechnical Institute \\
       May 4, 2019 }
\maketitle

\begin{abstract}
CW-complexes are key in homotopy type theory (HoTT) and are encoded
in cubical type checkers as higher inductive types (HITs). Like
recursive trees for (co)inductive types, HITs represent CW-complexes.
An HIT defines a CW-complex using cubical composition as an initial
algebra element in a cubical model. We explore HIT motivation, their
topological role, and implementation in Agda Cubical, focusing on infinity constructors. \\
{\bf Keywords}: Cellular Topology, Cubical Type Theory, HITs
\end{abstract}

\tableofcontents

\section{CW-Complexes}
CW-complexes are spaces built by attaching cells of increasing
dimension. In HoTT, they are encoded as HITs, with cells as
constructors for points and paths.\begin{definition} (Cell Attachment).
Attaching an \( n \)-cell to a space \( X \) along \( f : S^{n-1} \to X \) is a pushout:
\[
\begin{tikzcd}
S^{n-1} \arrow[r, "f"] \arrow[d, "\iota"] & X \arrow[d, "j"] \\
D^n \arrow[r, "g"] & X \cup_f D^n
\end{tikzcd}
\]
Here, \( \iota : S^{n-1} \incmap D^n \) is the boundary
inclusion, and \( X \cup_f D^n \) is the pushout, gluing an
\( n \)-cell to \( X \) via \( f \). The result depends on the
homotopy class of \( f \).
\end{definition}\begin{definition} (CW-Complex). A CW-complex is a space \( X \)
built inductively by attaching cells, with a skeletal
filtration:
\begin{itemize}
    \item The \((-1)\)-skeleton is \( X_{-1} = \varnothing \).
    \item For \( n \geq 0 \), the \( n \)-skeleton \( X_n \) is
      obtained by attaching \( n \)-cells to \( X_{n-1} \). For
      indices \( J_n \) and maps \( \{ f_j : S^{n-1} \to X_{n-1}
      \}_{j \in J_n} \), \( X_n \) is the pushout:
    \[
    \begin{tikzcd}
    \coprod_{j \in J_n} S^{n-1} \arrow[r, "\coprod f_j"] \arrow[d, "\coprod \iota_j"] & X_{n-1} \arrow[d, "i_n"] \\
    \coprod_{j \in J_n} D^n \arrow[r, "\coprod g_j"] & X_n
    \end{tikzcd}
    \]
    where \( \coprod_{j \in J_n} S^{n-1} \), \( \coprod_{j \in
    J_n} D^n \) are disjoint unions, and \( i_n : X_{n-1}
    \incmap X_n \) is the inclusion.
    \item \( X \) is the colimit of:
    \[
    \varnothing = X_{-1} \incmap X_0 \incmap X_1 \incmap \dots
    \incmap X,
    \]
    with \( X_n \) the \( n \)-skeleton, and \( X = \text{colim}_{n
    \to \infty} X_n \). The sequence is the skeletal filtration.
\end{itemize}
In HoTT, CW-complexes are HITs, with constructors for cells and
path constructors for gluing.
\end{definition}\begin{example} (Sphere as a CW-Complex). The \( n \)-sphere
\( S^n \) is a CW-complex with one 0-cell and one \( n \)-cell:
\begin{itemize}
    \item \( X_0 = \{ \text{base} \} \), a point.
    \item \( X_k = X_0 \) for \( 0 < k < n \), no cells added.
    \item \( X_n \): Attach an \( n \)-cell to \( X_{n-1} =
      \{ \text{base} \} \) along \( f : S^{n-1} \to
      \{ \text{base} \} \):
    The \( \text{cell} \) constructor glues boundaries to
    \( \text{base} \), yielding \( S^n \).
\end{itemize}
\end{example}

\subsection{Motivation for Higher Inductive Types}
HITs in HoTT enable direct encoding of topological spaces like
CW-complexes. In homotopy theory, spaces are built by gluing
cells via attaching maps. HoTT views types as spaces, elements
as points, and equalities as paths, making HITs a natural fit.
Standard inductive types cannot capture higher homotopies, but
HITs allow constructors for points and paths.For example, the circle \( S^1 \) (Definition 2) has a base
point and a loop, encoding its fundamental group
\( \mathbb{Z} \). HITs avoid set-level quotients, preserving
HoTTâ€™s synthetic nature. In cubical type theory, paths are
intervals (e.g., \( <i> \)) with computational content, unlike
propositional equalities, enabling efficient type checking in
tools like Agda Cubical.

\subsection{HITs with Infinity Constructors}
Some HITs require infinite constructors for spaces like Eilenberg-MacLane spaces or the infinite sphere $S^\infty$.
\begin{lstlisting}[mathescape=true]
def S$^\infty$ : U
 := inductive { base
              | loop (n: Nat) <i> [ (i=0) -> base, (i=1) -> base ]
              }
\end{lstlisting}
Challenges include type checking, computation, and expressivity.

Agda Cubical uses cubical primitives to handle HITs, supporting
infinite constructors via indexed HITs.

\begin{lstlisting}[mathescape=true]
def HIT-$\infty$ (A: U) : U
 := inductive { point : HIT-$\infty$ A
              | path : (n: Nat) -> PathP ($\lambda$ i, HIT-$\infty$ A) point point
              }
\end{lstlisting}

\section{Higher Inductive Types}
CW-complexes are central in HoTT and appear in cubical type checkers as HITs.
Unlike inductive types (recursive trees), HITs encode CW-complexes, capturing
points (0-cells) and higher paths (n-cells). Defining an HIT specifies a CW-complex
via cubical composition, an initial algebra in a cubical model.

\subsection{Suspension}
The suspension $\Sigma A$ of a type $A$ is a higher inductive type that
constructs a new type by adding two points, called poles, and paths connecting
each point of $A$ to these poles. It is a fundamental construction in homotopy
type theory, often used to shift homotopy groups, e.g., producing $S^{n+1}$ from $S^n$.

\begin{definition} (Formation)
For a type $A : \mathcal{U}$, the suspension $\Sigma A : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The suspension is generated by the following higher inductive composition structure:
$\text{north},\text{south} : \Sigma A$ and $\text{merid} : (a : A) \to \text{north} \equiv \text{south}$.
\[
\begin{cases}
\text{north} \\
\text{south} \\
\text{merid} : (a : A) \rightarrow north \equiv south \\
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\Sigma$ (A: U) : U
 := inductive { north
              | south
              | merid (a: A) : Path ($\Sigma A$) north south
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type family $B : \Sigma A \to \mathcal{U}$, points $n : B(\text{north})$, $s : B(\text{south})$, and a family of
dependent paths
$$
  m : (a : A) \to \text{PathOver}(B,\text{merid}(a),n,s),
$$
there exists a dependent map $\text{Ind}_{\Sigma A} : (x : \Sigma A) \to B(x)$ such that:
\[
\begin{cases}
\text{Ind}_{\Sigma A}(\text{north}) = n \\
\text{Ind}_{\Sigma A}(\text{south}) = s \\
\text{Ind}_{\Sigma A}(\text{merid}(a,i)) = m(a,i)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def PathOver (B: $\Sigma$ A -> U) (a: A) (n: B north) (s: B south) : U
  := PathP ($\lambda$ i , B (merid a @ i)) n s

def Ind$_{\Sigma A}$ (A: U) (B: $\Sigma$ A -> U) (n: B north) (s: B south)
    (m: (a: A) -> PathOver B (merid a) n s) : (x: $\Sigma$ A) -> B x
 := split { north -> n | south -> s | merid a @ i -> m a @ i }
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
\begin{lstlisting}[mathescape=true]
def $\Sigma$-$\beta$ (A: U) (B: $\Sigma$ A -> U) (n: B north) (s: B south)
    (m: (a: A) -> PathOver B (merid a) n s) (x: $\Sigma$ A)
  : Path (B x) ($\Sigma$-I A B n s m x)
    split { north -> n | south -> s | merid a @ i -> m a @ i } x
  = idp (B x) (Ind$_{\Sigma A}$ A B n s m x)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : (x : \Sigma A) \to B(x)$ are homotopic if they agree
on $\text{north}$, $\text{south}$, and $\text{merid}$, i.e.,
if $h_1(\text{north}) = h_2(\text{north})$, $h_1(\text{south}) = h_2(\text{south})$,
and $h_1(\text{merid } a) = h_2(\text{merid } a)$ for all $a : A$.
\end{theorem}

\newpage
\subsection{Spheres}
Spheres are higher inductive types (HITs) with higher-dimensional
paths, representing fundamental topological spaces.

\begin{definition} (Pointed n-Spheres)
The $n$-sphere $S^n$ is defined recursively as a type in the
universe $\mathcal{U}$ using general recursion over the dimensions:
\[
\mathbb{S}^n :=
\begin{cases}
\text{point} : \mathbb{S}^n, \\
\text{surface} :\ <i_1,...i_n> [\ (i_1=0) \rightarrow point, (i_1=1) \rightarrow point,\ ... \\
\hspace{3.47cm} (i_n=0) \rightarrow point, (i_n=1) \rightarrow point\ ]
\end{cases}
\]
\end{definition}

\begin{definition} (Suspended n-Spheres)
The $n$-sphere $S^n$ is defined recursively as a type in the
universe $\mathcal{U}$ using general recursion over the natural
numbers $\mathbb{N}$. For each $n \in \mathbb{N}$,
the type $S^n : \mathcal{U}$ is defined as follows:
\[
\mathbb{S}^n :=
\begin{cases}
S^0 = \mathbf{2}, \\
S^{n+1} = \Sigma(S^n).
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def sphere : $\mathbb{N}$ $\to$ U := $\mathbb{N}\text{-iter}$ U $\mathbf{2}$ $\Sigma$
\end{lstlisting}
This iterative definition applies the suspension functor $\Sigma$
to the base type $\mathbf{2}$ (the 0-sphere) $n$ times to obtain $S^n$.
\end{definition}

\begin{example} (Sphere as a CW-Complex)
The $n$-sphere $S^n$ can be constructed as a CW-complex with
one 0-cell and one $n$-cell:

\[
\begin{cases}
X_0 = \{ \text{base} \}, \text{ a single point} \\
X_k = X_0 \text{ for } 0 < k < n, \text{ no additional cells} \\
X_n: \text{Attach an } n\text{-cell to } X_{n-1} = \{ \text{base} \} \text{ along the map } f : S^{n-1} \to \{ \text{base} \}
\end{cases}
\]

The $\text{cell}$ constructor glues the boundary of the $n$-cell
to the base point, resulting in the type $S^n$.
\end{example}

\newpage
\subsection{Pushout}
The pushout is a higher inductive $\sqcup$ type that constructs a type by
gluing two types $A$ and $B$ along a common type $C$ via maps $f : C \to A$
and $g : C \to B$. It is a fundamental construction in homotopy type theory,
used to model cell attachments and cofibrant objects, generalizing the
topological notion of pushouts.

\begin{definition} (Formation)
For types $A, B, C : \mathcal{U}$ and maps $f : C \to A$, $g : C \to B$,
the pushout $\sqcup(A,B,C,f,g) : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The pushout is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{po$_1$} : A \to \sqcup(A,B,C,f,g) \\
\text{po$_2$} : B \to \sqcup(A,B,C,f,g) \\
\text{po$_3$} : (c : C) \to \text{po$_1$}(f(c)) \equiv \text{po$_2$}(g(c))
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def $\sqcup$ (A B C: U) (f: C -> A) (g: C -> B) : U
 := inductive { po$_1$ (_: A)
              | po$_2$ (_: B)
              | po$_3$ (c: C) : po$_1$(f(c)) $\equiv$ po$_2$(g(c))
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $D : \sqcup \to \mathcal{U}$, maps $u : A \to D$, $v : B \to D$,
and a family of paths $p : (c : C) \to u(f(c)) \equiv v(g(c)))$,
there exists a map $\text{Ind}_\sqcup : \sqcup(A,B,C,f,g) \to D$ such that:
\[
\begin{cases}
\text{Ind}_\sqcup(\text{po$_1$}(a)) = u(a) \\
\text{Ind}_\sqcup(\text{po$_2$}(b)) = v(b) \\
\text{Ind}_\sqcup(\text{po$_3$}(c,i)) = p(c,i)
\end{cases}
\]
\begin{lstlisting}[mathescape=true]
def PathOver (A B C : U) (f : C $\rightarrow$ A) (g : C $\rightarrow$ B)
    (D : $\sqcup$ A B C f g $\rightarrow$ U)
    (c : C) (u : D (po$_1$ (f c))) (v : D (po$_2$ (g c))) : U
 := PathP ($\lambda$ i, D (po$_3$ c i)) u v

def Ind$_\sqcup$ : (A B C : U) (f : C $\rightarrow$ A) (g : C $\rightarrow$ B)
    (D : $\sqcup$ A B C f g $\rightarrow$ U)
    (u : (a : A) $\rightarrow$ D (po$_1$ a))
    (v : (b : B) $\rightarrow$ D (po$_2$ b))
    (p : (c : C) $\rightarrow$ PathOver D c (u (f c)) (v (g c)))
  : (x : $\sqcup$ A B C f g) $\rightarrow$ D x
 := split { po$_1$ a $\rightarrow$ u a | po$_2$ b $\rightarrow$ v b | po$_3$ c @ i $\rightarrow$ p c @ i }
\end{lstlisting}
\end{theorem}

\newpage
\begin{theorem} (Computation)
For $x : \sqcup(A,B,C,f,g)$,
\[
\begin{cases}
\text{Ind$_\sqcup$}(\text{po$_1$}(a)) \equiv u(a) \\
\text{Ind$_\sqcup$}(\text{po$_2$}(b)) \equiv v(b) \\
\text{Ind$_\sqcup$}(\text{po$_3$}(c,i)) \equiv p(c,i)
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $u, v : \sqcup(A,B,C,f,g) \to D$ are homotopic
if they agree on $\text{po}_1$, $\text{po}_2$, and $\text{po}_3$, i.e.,
if $u(\text{po}_1(a)) = v(\text{po}_1(a))$ for all $a : A$, $u(\text{po}_2(b)) = v(\text{po}_2(b))$
for all $b : B$, and $u(\text{po}_3(c)) = v(\text{po}_3(c))$ for all $c : C$.
\end{theorem}

\begin{example} (Cell Attachment)
The pushout models attaching an $n$-cell to a space $X$.
Given $f : S^{n-1} \to X$ and the inclusion $g : S^{n-1} \to D^n$,
the pushout $\sqcup(X,D^n,S^{n-1},f,g)$ is the
space $X \cup_f D^n$, gluing the $n$-disk to $X$ along $f$.
\[
\begin{tikzcd}
S^{n-1} \arrow[r, "f"] \arrow[d, "g"] & X \arrow[d] \\
D^n \arrow[r] & X \cup_f D^n
\end{tikzcd}
\]
\end{example}


\newpage
\subsection{Wedge Sum}
The wedge sum of two pointed types $A$ and $B$, denoted $A \vee B$,
is a higher inductive type (HIT) that represents the union of $A$
and $B$ with their base points identified. Topologically,
it corresponds to $A \times \{ y_0 \} \cup \{ x_0 \} \times B$,
where $x_0$ and $y_0$ are the base points of $A$ and $B$, respectively.

\begin{definition} (Formation)
For pointed types $A, B : \text{pointed}$, the wedge sum $\text{Wedge } A B : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The wedge sum is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{winl} : A.1 \to \text{Wedge } A B \\
\text{winr} : B.1 \to \text{Wedge } A B \\
\text{wglue} : \text{Path}_{\text{Wedge } A B} (\text{winl } A.2, \text{winr } B.2)
\end{cases}
\]
\begin{lstlisting}
data Wedge (A : pointed) (B : pointed)
   = winl (a : A.1)
   | winr (b : B.1)
   | wglue <x> [ (x = 0) -> winl A.2 , (x = 1) -> winr B.2 ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $C : \mathcal{U}$, maps $f : A.1 \to C$, $g : B.1 \to C$, and a path $p : \text{Path}_C (f (A.2), g (B.2))$, there exists a map $\text{WedgeRec} : \text{Wedge } A B \to C$ such that:
\[
\begin{cases}
\text{WedgeRec}(\text{winl } a) = f(a) \\
\text{WedgeRec}(\text{winr } b) = g(b) \\
\text{WedgeRec}(\text{wglue } @ \, x) = p \, @ \, x
\end{cases}
\]
\begin{lstlisting}
WedgeRec (A B : pointed) (C : U) (f : A.1 -> C) (g : B.1 -> C)
         (p : Path C (f A.2) (g B.2))
   : Wedge A B -> C
   = split
     winl a -> f a
     winr b -> g b
     wglue @ x -> p @ x
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
For $z : \text{Wedge } A B$,
\[
\begin{cases}
\text{WedgeRec}(\text{winl } a) \equiv f(a) \\
\text{WedgeRec}(\text{winr } b) \equiv g(b) \\
\text{WedgeRec}(\text{wglue } @ \, x) \equiv p \, @ \, x
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \text{Wedge } A B \to C$ are homotopic if
they agree on $\text{winl}$, $\text{winr}$, and $\text{wglue}$,
i.e., if $h_1(\text{winl } a) = h_2(\text{winl } a)$ for
all $a : A.1$, $h_1(\text{winr } b) = h_2(\text{winr } b)$ for
all $b : B.1$, and $h_1(\text{wglue}) = h_2(\text{wglue})$.
\end{theorem}

\newpage
\subsection{Hub and Spoke}
The Hub and Spoke $\odot$ construction defines $n$-truncations,
ensuring a type has no non-trivial homotopy groups above
dimension $n$. It models a type as a CW-complex with a
hub (central point) and spokes (paths to points).

\begin{definition} (Hub and Spokes)
For types $S, A : \mathcal{U}$, the Hub and Spokes type $\odot(S,A) : \mathcal{U}$.
\[
\begin{cases}
\text{base} : A \to \odot(S,A) \\
\text{hub} : (S \to \odot(S,A)) \to \odot(S,A) \\
\text{spoke} : (f : S \to \odot(S,A)) \to (s : S) \to \text{hub}(f) \equiv f(s) \\
\text{hubEq} : (x, y : A) \to (p : S \to x \equiv y) \to \text{base}(x) \equiv \text{base}(y) \\
\text{spokeEq} : (x, y : A) \to (p : S \to x \equiv y) \to (s : S) \to \text{hubEq}(x,y,p) \equiv \text{base}(p(s))
\end{cases}
\]
\begin{lstlisting}
data hubSpokes (S A: U)
   = base (x: A)
   | hub (f: S -> hubSpokes S A)
   | spoke (f: S -> hubSpokes S A) (s:S)
     <i> [ (i=0) -> hub f , (i=1) -> f s ]
   | hubEq (x y: A) (p: S -> Path A x y)
     <i> [ (i=0) -> base x , (i=1) -> base y ]
   | spokeEq (x y: A) (p: S -> Path A x y) (s: S)
     <i> [ (i=0) -> hubEq x y p , (i=1) -> base (p s) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\text{hubSpokes}$)
For a type $B : \mathcal{U}$, a map $g : A \to B$,
a point $h : (S \to \text{hubSpokes } S A) \to B$,
and path maps ensuring coherence, there exists
$\text{rec}_{\text{hubSpokes}} : \text{hubSpokes } S A \to B$,
such that $\text{rec}_{\text{hubSpokes}}(\text{base } x) = g(x)$
and $\text{rec}_{\text{hubSpokes}}(\text{hub } f) = h(f)$.
\end{theorem}

\newpage
\subsection{Set-Truncations}
Set truncation (0-truncation), denoted $\| A \|_0$,
ensures a type is a set, with homotopy groups vanishing above dimension 0.

\begin{definition} (Set Truncation)
For $A : \mathcal{U}$, $\| A \|_0 : \mathcal{U}$.
\[
\begin{cases}
\text{inc} : A \to \| A \|_0 \\
\text{squash} : (a, b : \| A \|_0) \to (p, q : a \equiv  b) \to p \equiv q
\end{cases}
\]
\begin{lstlisting}
data setTrunc (A: U)
   = inc (a: A)
   | squash (a b: setTrunc A) (p q: Path (setTrunc A) a b)
     <i j> [ (i = 0) -> p @ j, (i = 1) -> q @ j,
             (j = 0) -> a,     (j = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\| A \|_0$)
For a set $B : \mathcal{U}$ (i.e., $\text{isSet}(B)$), a map $f : A \to B$,
there exists $\text{setTruncRec} : \| A \|_0 \to B$, such that $\text{setTruncRec}(\text{inc}(a)) = f(a)$.
\end{theorem}

\subsection{Groupoid-Truncations}
Groupoid truncation (1-truncation), denoted $\| A \|_1$, ensures a
type is a 1-groupoid, with homotopy groups vanishing above dimension 1.

\begin{definition} (Groupoid Truncation)
For $A : \mathcal{U}$, $\| A \|_1 : \mathcal{U}$.
\[
\begin{cases}
\text{inc} : A \to \| A \|_1 \\
\text{squash} : (a, b : \| A \|_1) \to (p, q : a \equiv b) \to (r, s : p \equiv  q) \to r \equiv s
\end{cases}
\]
\begin{lstlisting}
data grpdTrunc (A: U)
   = inc (a: A)
   | squash (a b: grpdTrunc A)
            (p q: Path (grpdTrunc A) a b)
            (r s: Path (Path (grpdTrunc A) a b) p q)
     <i j k> [ (i = 0) -> r @ j @ k, (i = 1) -> s @ j @ k,
               (j = 0) -> p @ k,     (j = 1) -> q @ k,
               (k = 0) -> a,         (k = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\| A \|_1$)
For a 1-groupoid $B : \mathcal{U}$ (i.e., $\text{isGroupoid}(B)$),
a map $f : A \to B$, there exists $\text{grpdTruncRec} : \| A \|_1 \to B$,
such that $\text{grpdTruncRec}(\text{inc}(a)) = f(a)$.
\end{theorem}

\newpage

\subsection{Set-Quotients}
Set quotients construct a type $A$ quotiented by a
relation $R : A \to A \to \mathcal{U}$, ensuring the result is a set.

\begin{definition} (Set Quotient)
For a type $A : \mathcal{U}$ and a relation $R : A \to A \to \mathcal{U}$,
the set quotient $\text{setQuot } A R : \mathcal{U}$.
\[
\begin{cases}
\text{quotient} : A \to \text{setQuot}(A,R) \\
\text{identification} : (a, b : A) \to R a b \to \text{quotient}(a) \equiv \text{quotient}(b) \\
\text{trunc} : (a, b : \text{setQuot}(A,R)) \to (p, q : a \equiv b \to p \equiv q
\end{cases}
\]
\begin{lstlisting}
data setQuot (A: U) (R: A -> A -> U)
   = quotient (a: A)
   | identification (a b: A) (r: R a b)
     <i> [ (i=0) -> quotient a, (i=1) -> quotient b ]
   | trunc (a b : setQuot A R) (p q : Path (setQuot A R) a b)
     <i j> [ (i = 0) -> p @ j , (i = 1) -> q @ j ,
             (j = 0) -> a ,     (j = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\text{setQuot}$)
For a type family $B : \text{setQuot } A R \to \mathcal{U}$ with $\text{isSet}(B x)$,
and maps $f : (x : A) \to B(\text{quotient } x)$,
$g : (a, b : A) \to (r : R a b) \to \text{PathP} (<i> B(\text{idq } a b r @ i)) (f a) (f b)$,
there exists $\text{setQuotElim} : \Pi_{x:\text{setQuot } A R} B(x)$, such that $\text{setQuotElim}(\text{quotient } a) = f a$.
\end{theorem}

\subsection{Groupoid-Quotients}
Groupoid quotients extend set quotients to produce a 1-groupoid,
incorporating higher path constructors.

\begin{definition} (Groupoid Quotient)
For a type $A : \mathcal{U}$ and a relation $R : A \to A \to \mathcal{U}$, the groupoid quotient $\text{grpdQuot } A R : \mathcal{U}$ includes constructors for points, paths, and higher paths ensuring 1-groupoid structure. (Note: Full definition requires additional structure, partially omitted for brevity.)
\end{definition}


\newpage
\subsection{Smash Product}
The smash product of two pointed types $A$ and $B$, denoted $A \wedge B$,
is a higher inductive type that quotients the product $A \times B$ by the
wedge sum $A \vee B$. It represents the space $A \times B / (A \times \{ y_0 \} \cup \{ x_0 \} \times B)$,
collapsing the wedge to a single point.

\begin{definition} (Formation)
For pointed types $A, B : \text{pointed}$, the smash product $\text{Smash } A B : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The smash product is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{spair} : A.1 \to B.1 \to \text{Smash } A B \\
\text{smash} : (a : A.1) \to (b : B.1) \to \text{Path}_{\text{Smash } A B} (\text{spair } a \, B.2, \text{spair } A.2 \, b) \\
\text{smashpt} : \text{Path}_{\text{Smash } A B} (\text{smash } A.2 \, B.2, \text{spair } A.2 \, B.2)
\end{cases}
\]
\begin{lstlisting}
data Smash (A : pointed) (B : pointed)
   = spair (a : A.1) (b : B.1)
   | smash (a : A.1) (b : B.1) <x> [(x=0) -> spair a B.2, (x=1) -> spair A.2 b]
   | smashpt <x y> [(x=0) -> smash A.2 B.2 @ y,
                    (x=1) -> spair A.2 B.2,
                    (y=0) -> spair A.2 B.2,
                    (y=1) -> spair A.2 B.2]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $C : \mathcal{U}$, a map $f : A.1 \to B.1 \to C$,
paths $g : (a : A.1) \to (b : B.1) \to \text{Path}_C (f a \, B.2, f A.2 \, b)$,
and a 2-path $h : \text{Path}_{\text{Path}_{\text{Smash } A B} (f A.2 \, B.2, f A.2 \, B.2)} (g A.2 \, B.2, \text{idp } (f A.2 \, B.2))$,
there exists a map $\text{SmashRec} : \text{Smash } A B \to C$ such that:
\[
\begin{cases}
\text{SmashRec}(\text{spair } a \, b) = f(a, b) \\
\text{SmashRec}(\text{smash } a \, b \, @ \, x) = g(a, b) \, @ \, x \\
\text{SmashRec}(\text{smashpt } @ \, x \, @ \, y) = h \, @ \, x \, @ \, y
\end{cases}
\]
\end{theorem}

\begin{theorem} (Computation)
For $z : \text{Smash } A B$,
\[
\begin{cases}
\text{SmashRec}(\text{spair } a \, b) \equiv f(a, b) \\
\text{SmashRec}(\text{smash } a \, b \, @ \, x) \equiv g(a, b) \, @ \, x \\
\text{SmashRec}(\text{smashpt } @ \, x \, @ \, y) \equiv h \, @ \, x \, @ \, y
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \text{Smash } A B \to C$ are homotopic
if they agree on $\text{spair}$, $\text{smash}$, and $\text{smashpt}$.
\end{theorem}

\begin{example} (Smash of Spheres)
The smash product $S^1 \wedge S^1$ is homotopy equivalent to $S^2$,
as it quotients the torus $S^1 \times S^1$ by the wedge $S^1 \vee S^1$,
collapsing the base points and their fibers.
\end{example}

\newpage
\subsection{Join}
The join of two types $A$ and $B$, denoted $A * B$,
is a higher inductive type that constructs a type by
connecting every point of $A$ to every point of $B$ with a path.
Topologically, it corresponds to the join of spaces, forming a
space that interpolates between $A$ and $B$.

\begin{definition} (Formation)
For types $A, B : \mathcal{U}$, the join $\text{Join } A B : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The join is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{joinl} : A \to \text{Join } A B \\
\text{joinr} : B \to \text{Join } A B \\
\text{join} : (a : A) \to (b : B) \to \text{Path}_{\text{Join } A B} (\text{joinl } a, \text{joinr } b)
\end{cases}
\]
\begin{lstlisting}
data Join (A : U) (B : U)
   = joinl (a : A)
   | joinr (b : B)
   | join (a:A) (b:B) <i> [(i=0) -> joinl a, (i=1) -> joinr b]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $C : \mathcal{U}$, maps $f : A \to C$, $g : B \to C$,
and a family of paths $h : (a : A) \to (b : B) \to \text{Path}_C (f a, g b)$,
there exists a map $\text{JoinRec} : \text{Join } A B \to C$ such that:
\[
\begin{cases}
\text{JoinRec}(\text{joinl } a) = f(a) \\
\text{JoinRec}(\text{joinr } b) = g(b) \\
\text{JoinRec}(\text{join } a \, b \, @ \, i) = h(a, b) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
JoinRec (A B C : U) (f : A -> C) (g : B -> C)
        (h : (a : A) -> (b : B) -> Path C (f a) (g b))
   : Join A B -> C
   = split
     joinl a -> f a
     joinr b -> g b
     join a b @ i -> h a b @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
For $z : \text{Join } A B$,
\[
\begin{cases}
\text{JoinRec}(\text{joinl } a) \equiv f(a) \\
\text{JoinRec}(\text{joinr } b) \equiv g(b) \\
\text{JoinRec}(\text{join } a \, b \, @ \, i) \equiv h(a, b) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \text{Join } A B \to C$ are homotopic
if they agree on $\text{joinl}$, $\text{joinr}$, and $\text{join}$.
\end{theorem}

\begin{example} (Join of Spheres)
The join $S^0 * S^0$ is homotopy equivalent to $S^1$, as it connects
two points (from each $S^0$) with paths, forming a circle-like structure.
\end{example}

\newpage
\subsection{Equalizer}
The equalizer of two maps $f, g : A \to B$ is a higher inductive
type (HIT) that constructs a type consisting of elements in $B$
where $f$ and $g$ agree, along with paths enforcing this equality.
It is a fundamental construction in homotopy type theory,
capturing the subspace of $B$ where $f(a) = g(a)$ for $a : A$.

\begin{definition} (Formation)
For types $A, B : \mathcal{U}$ and maps $f, g : A \to B$,
the equalizer $\text{coeq } A B f g : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The equalizer is generated by the following higher
inductive composition structure:
\[
\begin{cases}
\text{inC} : B \to \text{coeq } A B f g \\
\text{glueC} : (a : A) \to \text{Path}_{\text{coeq } A B f g} (\text{inC } (f a), \text{inC } (g a))
\end{cases}
\]
\begin{lstlisting}
data coeq (A B: U) (f g: A -> B)
   = inC (_: B)
   | glueC (a: A) <i> [(i=0) -> inC (f a), (i=1) -> inC (g a) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $C : \mathcal{U}$, a map $h : B \to C$, and a family of paths $y : (x : A) \to \text{Path}_C (h (f x), h (g x))$, there exists a map $\text{coequRec} : \text{coeq } A B f g \to C$ such that:
\[
\begin{cases}
\text{coequRec}(\text{inC } x) = h(x) \\
\text{coequRec}(\text{glueC } x \, @ \, i) = y(x) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
coequRec (A B C : U) (f g : A -> B) (h: B -> C) (y: (x : A) -> Path C (h (f x)) (h (g x)))
   : (z : coeq A B f g) -> C
   = split
     inC x -> h x
     glueC x @ i -> y x @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
For $z : \text{coeq } A B f g$,
\[
\begin{cases}
\text{coequRec}(\text{inC } x) \equiv h(x) \\
\text{coequRec}(\text{glueC } x \, @ \, i) \equiv y(x) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \text{coeq } A B f g \to C$ are homotopic
if they agree on $\text{inC}$ and $\text{glueC}$, i.e.,
if $h_1(\text{inC } x) = h_2(\text{inC } x)$ for
all $x : B$ and $h_1(\text{glueC } a) = h_2(\text{glueC } a)$ for all $a : A$.
\end{theorem}

\begin{example} (Equalizer as Subspace)
The equalizer $\text{coeq } A B f g$ represents the subspace
of $B$ where $f(a) = g(a)$. For example, if $A = B = \mathbb{R}$
and $f(x) = x^2$, $g(x) = x$, the equalizer captures points
where $x^2 = x$, i.e., $\{0, 1\}$.
\end{example}

\subsection{Path-Equalizer}
The path-equalizer is a higher inductive type that generalizes
the equalizer to handle pairs of paths in $B$. Given a
map $p : A \to (b_1, b_2 : B) \times (\text{Path}_B (b_1, b_2)) \times (\text{Path}_B (b_1, b_2))$,
it constructs a type where elements of $A$ induce pairs
of paths between points in $B$, with paths connecting
the endpoints of these paths.

\begin{definition} (Formation)
For types $A, B : \mathcal{U}$ and a map $p : A \to (b_1, b_2 : B) \times (\text{Path}_B (b_1, b_2)) \times (\text{Path}_B (b_1, b_2))$, the path-equalizer $\text{coeqP } A B p : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The path-equalizer is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{inP} : B \to \text{coeqP } A B p \\
\text{glueP} : (a : A) \to \text{Path}_{\text{coeqP } A B p} (\text{inP } (((p \, a).2.2.1) \, @ \, 0), \text{inP } (((p \, a).2.2.2) \, @ \, 1))
\end{cases}
\]
\begin{lstlisting}
data coeqP (A B: U) (p : A -> (b1 b2: B) * (_: Path B b1 b2) * (Path B b1 b2))
   = inP (b: B)
   | glueP (a:A) <i> [(i=0) -> inP (((p a).2.2.1) @ 0), (i=1) -> inP (((p a).2.2.2) @ 1) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $C : \mathcal{U}$, a map $h : B \to C$, and a family of paths $y : (a : A) \to \text{Path}_C (h (((p \, a).2.2.1) \, @ \, 0), h (((p \, a).2.2.2) \, @ \, 1))$, there exists a map $\text{coequPRec} : \text{coeqP } A B p \to C$ such that:
\[
\begin{cases}
\text{coequPRec}(\text{inP } b) = h(b) \\
\text{coequPRec}(\text{glueP } a \, @ \, i) = y(a) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
coequPRec (A B C : U) (p : A -> (b1 b2: B) * (_: Path B b1 b2) * (Path B b1 b2))
          (h: B -> C) (y: (a : A) -> Path C (h (((p a).2.2.1) @ 0)) (h (((p a).2.2.2) @ 1)))
   : (z : coeqP A B p) -> C
   = split
     inP b -> h b
     glueP a @ i -> y a @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
For $z : \text{coeqP } A B p$,
\[
\begin{cases}
\text{coequPRec}(\text{inP } b) \equiv h(b) \\
\text{coequPRec}(\text{glueP } a \, @ \, i) \equiv y(a) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \text{coeqP } A B p \to C$ are homotopic
if they agree on $\text{inP}$ and $\text{glueP}$, i.e.,
if $h_1(\text{inP } b) = h_2(\text{inP } b)$ for all $b : B$
and $h_1(\text{glueP } a) = h_2(\text{glueP } a)$ for all $a : A$.
\end{theorem}

\begin{example} (Path-Equalizer for Homotopy)
The path-equalizer can model spaces where elements of $A$ specify
pairs of paths between points in $B$. For instance, if $p(a)$ provides
two paths from $b_1$ to $b_2$ in $B$, $\text{coeqP}$ constructs a type
connecting the starting and ending points of these paths,
useful in studying homotopy classes.
\end{example}

\newpage
\subsection{Colimits}
Colimits construct the limit of a sequence of types connected by maps,
such as propositional truncations.

\begin{definition} (Colimit)
For a sequence of types $A : \text{nat} \to \mathcal{U}$ and
maps $f : (n : \mathbb{N}) \to A n \to A(\text{succ}(n))$,
the colimit type $\text{colimit}(A,f) : \mathcal{U}$.
\[
\begin{cases}
\text{ix} : (n : \text{nat}) \to A n \to \text{colimit}(A,f) \\
\text{gx} : (n : \text{nat}) \to (a : A(n)) \to \text{ix} (\text{succ}(n),f(n,a)) \equiv \text{ix}(n,a)
\end{cases}
\]
\begin{lstlisting}
def colimit (A : nat -> U) (f : (n : nat) -> A n -> A (succ n)) : U
 := inductive { ix (n : nat) (x: A n)
              | gx (n : nat) (a: A n)
                <i> [ (i=0) -> ix (succ n) (f n a),
                      (i=1) -> ix n a ]
              }
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\text{colimit}$)
For a type $P : \text{colimit } A f \to \mathcal{U}$,
with $p : (n : \text{nat}) \to (x : A n) \to P(\text{ix}(n, x))$
and $q : (n : \text{nat}) \to (a : A n) \to \text{PathP} (\langle i \rangle P(\text{gx}(n, a) @ i)) (p (\text{succ } n) (f n a)) (p n a)$,
there exists $i : \Pi_{x:\text{colimit } A f} P(x)$, such that $i(\text{ix}(n, x)) = p n x$.
\end{theorem}


\newpage

\subsection{K(G,n)}
Eilenberg-MacLane spaces $K(G,n)$ have a single non-trivial
homotopy group $\pi_n(K(G,n)) = G$. They are defined using truncations and suspensions.

\begin{definition} (K(G,n))
For an abelian group $G : \text{abgroup}$, the type $KGn G : \text{nat} \to \mathcal{U}$.
\[
\begin{cases}
n = 0: \text{discreteTopology}(G) \\
n \geq 1: \text{succ}(n) = \text{nTrunc}(\text{suspension}(K1' (G.1, G.2.1)) n) (\text{succ} n)
\end{cases}
\]
\begin{lstlisting}
KGn (G: abgroup)
  : nat -> U
  = split
    zero -> discreteTopology G
    succ n -> nTrunc (suspension (K1' (G.1,G.2.1)) n) (succ n)
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $KGn$)
For $n \geq 1$, a type $B : \mathcal{U}$ with $\text{isNGroupoid}(B, \text{succ } n)$,
and a map $f : \text{suspension}(K1' G) \to B$, there
exists $\text{rec}_{KGn} : KGn G (\text{succ } n) \to B$,
defined via $\text{nTruncRec}$.
\end{theorem}

\newpage

\subsection{Localization}
Localization constructs an $F$-local type from a type $X$,
with respect to a family of maps $F_A : S(a) \to T(a)$.

\begin{definition} (Localization Modality)
For a family of maps $F_A : S(a) \to T(a)$,
the $F$-localization $L^{AST}_F(X) : \mathcal{U}$.
\[
\begin{cases}
\text{center} : X \to L_{F_A}(X) \\
\text{ext} : (a : A) \to (S(a) \to L_{F_A}(X)) \to T(a) \to L_{F_A}(X) \\
\text{isExt} : (a : A) \to (f : S(a) \to L_{F_A}(X)) \to (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (\text{ext } a f (F a s), f s) \\
\text{extEq} : (a : A) \to (g, h : T(a) \to L_{F_A}(X)) \to (p : (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (g (F a s), h (F a s))) \to (t : T(a)) \to \text{Path}_{L_{F_A}(X)} (g t, h t) \\
\text{isExtEq} : (a : A) \to (g, h : T(a) \to L_{F_A}(X)) \to (p : (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (g (F a s), h (F a s))) \to (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (\text{extEq } a g h p (F a s), p s)
\end{cases}
\]
\begin{lstlisting}
data Localize (A X: U) (S T: A -> U) (F : (x:A) -> S x -> T x)
   = center (x: X)
   | ext (a: A) (f: S a -> Localize A X S T F) (t: T a)
   | isExt (a: A) (f: S a -> Localize A X S T F) (s: S a) <i>
     [ (i=0) -> ext a f (F a s) , (i=1) -> f s ]
   | extEq (a: A) (g h: T a -> Localize A X S T F)
     (p: (s : S a) -> Path (Localize A X S T F) (g (F a s)) (h (F a s)))
     (t : T a) <i> [ (i=0) -> g t , (i=1) -> h t ]
   | isExtEq (a: A) (g h : T a -> Localize A X S T F)
     (p: (s : S a) -> Path (T a -> Localize A X S T F) (g (F a s)) (h (F a s)))
     (s : S a) <i> [ (i=0) -> extEq a g h p (F a s) , (i=1) -> p s ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Localization Induction)
For any $P : \Pi_{X:U} L_{F_A}(X) \to U$ with $\{n, r, s\}$ satisfying coherence conditions,
there exists $i : \Pi_{x:L_{F_A}(X)} P(x)$ such that $i \cdot \text{center}_X = n$.
\end{theorem}


\section{Conclusion}
HITs encode CW-complexes in HoTT, bridging topology and type theory.
They capture cell attachments, with examples like spheres, tori, and truncations.
Infinity constructors extend HITs to infinite spaces, handled by Agda Cubicalâ€™s primitives and indexed HITs.

\bibliographystyle{plain}
\begin{thebibliography}{9}
\bibitem{univalent}
The Univalent Foundations Program, \emph{Homotopy Type Theory: Univalent Foundations of Mathematics}, IAS, 2013.
\bibitem{cubicaltt}
C. Cohen, T. Coquand, S. Huber, A. MÃ¶rtberg, \emph{Cubical Type Theory}, Journal of Automated Reasoning, 2018.
\bibitem{agda-cubical}
A. MÃ¶rtberg et al., \emph{Agda Cubical Library}, \url{https://github.com/agda/cubical}, 2023.
\bibitem{hott-book}
M. Shulman, \emph{Higher Inductive Types in HoTT}, \url{https://arxiv.org/abs/1705.07088}, 2017.
\bibitem{localization}
J. D. Christensen, M. Opie, E. Rijke, L. Scoccola, \emph{Localization in Homotopy Type Theory}, \url{https://arxiv.org/pdf/1807.04155.pdf}, 2018.
\bibitem{modalities}
E. Rijke, M. Shulman, B. Spitters, \emph{Modalities in Homotopy Type Theory}, \url{https://arxiv.org/pdf/1706.07526v6.pdf}, 2017.
\bibitem{synthetic-spectra}
M. Riley, E. Finster, D. R. Licata, \emph{Synthetic Spectra via a Monadic and Comonadic Modality}, \url{https://arxiv.org/pdf/2102.04099.pdf}, 2021.
\end{thebibliography}

\end{document}
