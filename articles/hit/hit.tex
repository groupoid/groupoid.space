% copyright (c) 2018 Groupoid Infinity
\documentclass{article}
\usepackage[english]{babel}
\usepackage{hyphenat}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{url}
\usepackage{tikz-cd}
\usepackage[utf8]{inputenc}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newcommand*{\incmap}{\hookrightarrow}
\newcommand*{\thead}[1]{\multicolumn{1}{c}{\bfseries #1}}
\lstset{basicstyle=\small,inputencoding=utf8}

\begin{document}

\title{Issue IV: Higher Inductive Types}
\author{Maxim Sokhatsky $^1$}
\date{ $^1$ National Technical University of Ukraine \\
       \small Igor Sikorsky Kyiv Polytechnical Institute \\
       \today }
\maketitle

\begin{abstract}
CW-complexes are key in homotopy type theory (HoTT) and are encoded
in cubical type checkers as higher inductive types (HITs). Like
recursive trees for (co)inductive types, HITs represent CW-complexes.
An HIT defines a CW-complex using cubical composition as an initial
algebra element in a cubical model. We explore HIT motivation, their
topological role, and implementation in Agda Cubical, focusing on infinity constructors. \\
{\bf Keywords}: Cellular Topology, Cubical Type Theory, HITs
\end{abstract}

\tableofcontents
\newpage

\section{CW-Complexes}
CW-complexes are spaces built by attaching cells of increasing
dimension. In HoTT, they are encoded as HITs, with cells as
constructors for points and paths.\begin{definition} (Cell Attachment). Attaching an \( n \)-cell
to a space \( X \) along \( f : S^{n-1} \to X \) is a pushout:
\[
\begin{tikzcd}
S^{n-1} \arrow[r, "f"] \arrow[d, "\iota"] & X \arrow[d, "j"] \\
D^n \arrow[r, "g"] & X \cup_f D^n
\end{tikzcd}
\]
Here, \( \iota : S^{n-1} \incmap D^n \) is the boundary
inclusion, and \( X \cup_f D^n \) is the pushout, gluing an
\( n \)-cell to \( X \) via \( f \). The result depends on the
homotopy class of \( f \).
\end{definition}\begin{definition} (CW-Complex). A CW-complex is a space \( X \)
built inductively by attaching cells, with a skeletal
filtration:
\begin{itemize}
    \item The \((-1)\)-skeleton is \( X_{-1} = \varnothing \).
    \item For \( n \geq 0 \), the \( n \)-skeleton \( X_n \) is
      obtained by attaching \( n \)-cells to \( X_{n-1} \). For
      indices \( J_n \) and maps \( \{ f_j : S^{n-1} \to X_{n-1}
      \}_{j \in J_n} \), \( X_n \) is the pushout:
    \[
    \begin{tikzcd}
    \coprod_{j \in J_n} S^{n-1} \arrow[r, "\coprod f_j"] \arrow[d, "\coprod \iota_j"] & X_{n-1} \arrow[d, "i_n"] \\
    \coprod_{j \in J_n} D^n \arrow[r, "\coprod g_j"] & X_n
    \end{tikzcd}
    \]
    where \( \coprod_{j \in J_n} S^{n-1} \), \( \coprod_{j \in
    J_n} D^n \) are disjoint unions, and \( i_n : X_{n-1}
    \incmap X_n \) is the inclusion.
    \item \( X \) is the colimit of:
    \[
    \varnothing = X_{-1} \incmap X_0 \incmap X_1 \incmap \dots
    \incmap X,
    \]
    with \( X_n \) the \( n \)-skeleton, and \( X = \text{colim}_{n
    \to \infty} X_n \). The sequence is the skeletal filtration.
\end{itemize}
In HoTT, CW-complexes are HITs, with constructors for cells and
path constructors for gluing.
\end{definition}\begin{example} (Sphere as a CW-Complex). The \( n \)-sphere
\( S^n \) is a CW-complex with one 0-cell and one \( n \)-cell:
\begin{itemize}
    \item \( X_0 = \{ \text{base} \} \), a point.
    \item \( X_k = X_0 \) for \( 0 < k < n \), no cells added.
    \item \( X_n \): Attach an \( n \)-cell to \( X_{n-1} =
      \{ \text{base} \} \) along \( f : S^{n-1} \to
      \{ \text{base} \} \):
    The \( \text{cell} \) constructor glues boundaries to
    \( \text{base} \), yielding \( S^n \).
\end{itemize}
\end{example}

\subsection{Motivation for Higher Inductive Types}
HITs in HoTT enable direct encoding of topological spaces like
CW-complexes. In homotopy theory, spaces are built by gluing
cells via attaching maps. HoTT views types as spaces, elements
as points, and equalities as paths, making HITs a natural fit.
Standard inductive types cannot capture higher homotopies, but
HITs allow constructors for points and paths.For example, the circle \( S^1 \) (Definition 2) has a base
point and a loop, encoding its fundamental group
\( \mathbb{Z} \). HITs avoid set-level quotients, preserving
HoTTâ€™s synthetic nature. In cubical type theory, paths are
intervals (e.g., \( <i> \)) with computational content, unlike
propositional equalities, enabling efficient type checking in
tools like Agda Cubical.

\subsection{HITs with Infinity Constructors}
Some HITs require infinite constructors for spaces like Eilenberg-MacLane spaces or the infinite sphere $S^\infty$.
\begin{lstlisting}
data SInf
   = base
   | loopn (n: Nat) <i> [ (i = 0) -> base, (i = 1) -> base ]
\end{lstlisting}
Challenges include type checking, computation, and expressivity.

Agda Cubical uses cubical primitives to handle HITs, supporting infinite constructors via indexed HITs.
\begin{lstlisting}
data InfHIT (A: Type) : Type where
point : InfHIT A
pathn : (n: Nat) -> PathP (\lambda i -> InfHIT A) point point
\end{lstlisting}

\newpage
\section{Higher Inductive Types}
CW-complexes are central in HoTT and appear in cubical type checkers as HITs. Unlike inductive types (recursive trees), HITs encode CW-complexes, capturing points (0-cells) and higher paths (n-cells). Defining an HIT specifies a CW-complex via cubical composition, an initial algebra in a cubical model.

\subsection{Suspension}
The suspension $\Sigma A$ of a type $A$ is a higher inductive type (HIT) that constructs a new type by adding two points, called poles, and paths connecting each point of $A$ to these poles. It is a fundamental construction in homotopy type theory, often used to shift homotopy groups, e.g., producing $S^{n+1}$ from $S^n$.

\begin{definition} (Formation)
For a type $A : \mathcal{U}$, the suspension $\Sigma A : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The suspension is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{north} : \Sigma A \\
\text{south} : \Sigma A \\
\text{merid} : (a : A) \to \text{Path}_{\Sigma A} (\text{north}, \text{south})
\end{cases}
\]
\begin{lstlisting}
data Suspension (A: U)
   = north
   | south
   | merid (a: A) <i> [ (i=0) -> north, (i=1) -> south ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $B : \mathcal{U}$, points $n, s : B$, and a family of paths $m : (a : A) \to \text{Path}_B (n, s)$, there exists a map $\text{rec}_{\Sigma A} : \Sigma A \to B$ such that:
\[
\begin{cases}
\text{rec}_{\Sigma A}(\text{north}) = n \\
\text{rec}_{\Sigma A}(\text{south}) = s \\
\text{rec}_{\Sigma A}(\text{merid } a) = m(a)
\end{cases}
\]
\begin{lstlisting}
SuspensionRec (A B: U) (n s: B) (m: (a: A) -> Path B n s)
  : Suspension A -> B
  = split
    north -> n
    south -> s
    merid a @ i -> m a @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
For $x : \Sigma A$,
\[
\begin{cases}
\text{rec}_{\Sigma A}(\text{north}) \equiv n \\
\text{rec}_{\Sigma A}(\text{south}) \equiv s \\
\text{rec}_{\Sigma A}(\text{merid } a \, @ \, i) \equiv m(a) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
SuspensionBeta (A B: U) (n s: B) (m: (a: A) -> Path B n s)
    (x: Suspension A)
  : Path B (SuspensionRec A B n s m x)
    (split north -> n; south -> s; merid a @ i -> m a @ i) x
  = idp B (SuspensionRec A B n s m x)
\end{lstlisting}
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \Sigma A \to B$ are homotopic if they agree on $\text{north}$, $\text{south}$, and $\text{merid}$, i.e., if $h_1(\text{north}) = h_2(\text{north})$, $h_1(\text{south}) = h_2(\text{south})$, and $h_1(\text{merid } a) = h_2(\text{merid } a)$ for all $a : A$.
\end{theorem}

\begin{example} (Suspension of $S^0$)
The suspension of the 0-sphere $S^0$ (two points) yields the 1-sphere $S^1$. If $A = S^0 = \{ \text{base}_0, \text{base}_1 \}$, then $\Sigma S^0$ has two points $\text{north}$, $\text{south}$, and two paths $\text{merid}(\text{base}_0)$, $\text{merid}(\text{base}_1)$, resembling the loop structure of $S^1$.
\end{example}


\subsection{Pushout}
The pushout is a higher inductive type (HIT) that constructs a type by gluing two types $A$ and $B$ along a common type $C$ via maps $f : C \to A$ and $g : C \to B$. It is a fundamental construction in homotopy type theory, used to model cell attachments and cofibrant objects, generalizing the topological notion of pushouts.

\begin{definition} (Formation)
For types $A, B, C : \mathcal{U}$ and maps $f : C \to A$, $g : C \to B$, the pushout $\text{pushout } A B C f g : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The pushout is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{po1} : A \to \text{pushout } A B C f g \\
\text{po2} : B \to \text{pushout } A B C f g \\
\text{po3} : (c : C) \to \text{Path}_{\text{pushout } A B C f g} (\text{po1 } (f c), \text{po2 } (g c))
\end{cases}
\]
\begin{lstlisting}
data pushout (A B C: U) (f: C -> A) (g: C -> B)
   = po1 (_: A)
   | po2 (_: B)
   | po3 (c: C) <i> [ (i = 0) -> po1 (f c) , (i = 1) -> po2 (g c) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $D : \mathcal{U}$, maps $h_A : A \to D$, $h_B : B \to D$, and a family of paths $h_C : (c : C) \to \text{Path}_D (h_A (f c), h_B (g c))$, there exists a map $\text{pushoutRec} : \text{pushout } A B C f g \to D$ such that:
\[
\begin{cases}
\text{pushoutRec}(\text{po1 } a) = h_A(a) \\
\text{pushoutRec}(\text{po2 } b) = h_B(b) \\
\text{pushoutRec}(\text{po3 } c \, @ \, i) = h_C(c) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
pushoutRec (A B C D: U) (f: C -> A) (g: C -> B) 
           (hA: A -> D) (hB: B -> D) (hC: (c: C) -> Path D (hA (f c)) (hB (g c)))
   : pushout A B C f g -> D
   = split
     po1 a -> hA a
     po2 b -> hB b
     po3 c @ i -> hC c @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
For $x : \text{pushout } A B C f g$,
\[
\begin{cases}
\text{pushoutRec}(\text{po1 } a) \equiv h_A(a) \\
\text{pushoutRec}(\text{po2 } b) \equiv h_B(b) \\
\text{pushoutRec}(\text{po3 } c \, @ \, i) \equiv h_C(c) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \text{pushout } A B C f g \to D$ are homotopic if they agree on $\text{po1}$, $\text{po2}$, and $\text{po3}$, i.e., if $h_1(\text{po1 } a) = h_2(\text{po1 } a)$ for all $a : A$, $h_1(\text{po2 } b) = h_2(\text{po2 } b)$ for all $b : B$, and $h_1(\text{po3 } c) = h_2(\text{po3 } c)$ for all $c : C$.
\end{theorem}

\begin{example} (Cell Attachment)
The pushout models attaching an $n$-cell to a space $X$. Given $f : S^{n-1} \to X$ and the inclusion $g : S^{n-1} \to D^n$, the pushout $\text{pushout } X D^n S^{n-1} f g$ is the space $X \cup_f D^n$, gluing the $n$-disk to $X$ along $f$.
\[
\begin{tikzcd}
S^{n-1} \arrow[r, "f"] \arrow[d, "g"] & X \arrow[d] \\
D^n \arrow[r] & X \cup_f D^n
\end{tikzcd}
\]
\end{example}

\newpage
\subsection{Spheres}
Spheres are HITs with higher-dimensional paths, representing fundamental topological spaces like the circle ($S^1$) or 2-sphere ($S^2$).

\begin{definition} (Spheres and Disks)
\[
S^1 = \begin{cases}
\quad \text{base} \\
\quad \text{loop } <i> \begin{cases} (i = 0) \mapsto \text{base} \\ (i = 1) \mapsto \text{base} \end{cases} \\
\end{cases}
\]

\[
S^2 = \begin{cases}
\quad \text{point} \\
\quad \text{surf} <i \, j> \begin{cases}
(i = 0) \mapsto \text{point} \\
(i = 1) \mapsto \text{point} \\
(j = 0) \mapsto \text{point} \\
(j = 1) \mapsto \text{point}
\end{cases}
\end{cases}
\]
\begin{lstlisting}
data S1
   = base
   | loop <i> [ (i = 0) -> base, (i = 1) -> base ]
data S2
   = point
   | surf <i j> [ (i = 0) -> point, (i = 1) -> point,
                  (j = 0) -> point, (j = 1) -> point ]
\end{lstlisting}
\end{definition}

\begin{example} (Sphere as a CW-Complex)
The $n$-sphere $S^n$ is a CW-complex with one 0-cell and one $n$-cell:
\[
\begin{cases}
X_0 = \{ \text{base} \}, \text{a point} \\
X_k = X_0 \text{ for } 0 < k < n, \text{no cells added} \\
X_n: \text{Attach an } n\text{-cell to } X_{n-1} = \{ \text{base} \} \text{ along } f : S^{n-1} \to \{ \text{base} \}
\end{cases}
\]
\begin{lstlisting}
data Sn (n: Nat)
   = base
   | cell <i1 ... in> [ (i1 = 0) -> base, (i1 = 1) -> base,
                        ...,
                        (in = 0) -> base, (in = 1) -> base ]
\end{lstlisting}
The $\text{cell}$ constructor glues boundaries to $\text{base}$, yielding $S^n$.
\end{example}

\newpage
\subsection{Hub and Spoke}
The Hub and Spoke construction defines $n$-truncations, ensuring a type has no non-trivial homotopy groups above dimension $n$. It models a type as a CW-complex with a hub (central point) and spokes (paths to points).

\begin{definition} (Hub and Spokes)
For types $S, A : \mathcal{U}$, the Hub and Spokes type $\text{hubSpokes } S A : \mathcal{U}$.
\[
\begin{cases}
\text{base} : A \to \text{hubSpokes } S A \\
\text{hub} : (S \to \text{hubSpokes } S A) \to \text{hubSpokes } S A \\
\text{spoke} : (f : S \to \text{hubSpokes } S A) \to (s : S) \to \text{Path}_{\text{hubSpokes } S A} (\text{hub } f, f s) \\
\text{hubEq} : (x, y : A) \to (p : S \to \text{Path}_A(x, y)) \to \text{Path}_{\text{hubSpokes } S A} (\text{base } x, \text{base } y) \\
\text{spokeEq} : (x, y : A) \to (p : S \to \text{Path}_A(x, y)) \to (s : S) \to \text{Path}_{\text{hubSpokes } S A} (\text{hubEq } x y p, \text{base } (p s))
\end{cases}
\]
\begin{lstlisting}
data hubSpokes (S A: U)
   = base (x: A)
   | hub (f: S -> hubSpokes S A)
   | spoke (f: S -> hubSpokes S A) (s:S)
     <i> [ (i=0) -> hub f , (i=1) -> f s ]
   | hubEq (x y: A) (p: S -> Path A x y)
     <i> [ (i=0) -> base x , (i=1) -> base y ]
   | spokeEq (x y: A) (p: S -> Path A x y) (s: S)
     <i> [ (i=0) -> hubEq x y p , (i=1) -> base (p s) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\text{hubSpokes}$)
For a type $B : \mathcal{U}$, a map $g : A \to B$, a point $h : (S \to \text{hubSpokes } S A) \to B$, and path maps ensuring coherence, there exists $\text{rec}_{\text{hubSpokes}} : \text{hubSpokes } S A \to B$, such that $\text{rec}_{\text{hubSpokes}}(\text{base } x) = g(x)$ and $\text{rec}_{\text{hubSpokes}}(\text{hub } f) = h(f)$.
\end{theorem}

\newpage
\subsection{Set-Truncations}
Set truncation (0-truncation), denoted $\| A \|_0$, ensures a type is a set, with homotopy groups vanishing above dimension 0.

\begin{definition} (Set Truncation)
For $A : \mathcal{U}$, $\| A \|_0 : \mathcal{U}$.
\[
\begin{cases}
\text{inc} : A \to \| A \|_0 \\
\text{squash} : (a, b : \| A \|_0) \to (p, q : \text{Path}_{\| A \|_0}(a, b)) \to \text{Path}_{\text{Path}_{\| A \|_0}(a, b)}(p, q)
\end{cases}
\]
\begin{lstlisting}
data setTrunc (A: U)
   = inc (a: A)
   | squash (a b: setTrunc A) (p q: Path (setTrunc A) a b)
     <i j> [ (i = 0) -> p @ j, (i = 1) -> q @ j,
             (j = 0) -> a,     (j = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\| A \|_0$)
For a set $B : \mathcal{U}$ (i.e., $\text{isSet}(B)$), a map $f : A \to B$, there exists $\text{setTruncRec} : \| A \|_0 \to B$, such that $\text{setTruncRec}(\text{inc}(a)) = f(a)$.
\end{theorem}

\subsection{Groupoid-Truncations}
Groupoid truncation (1-truncation), denoted $\| A \|_1$, ensures a type is a 1-groupoid, with homotopy groups vanishing above dimension 1.

\begin{definition} (Groupoid Truncation)
For $A : \mathcal{U}$, $\| A \|_1 : \mathcal{U}$.
\[
\begin{cases}
\text{inc} : A \to \| A \|_1 \\
\text{squash} : (a, b : \| A \|_1) \to (p, q : \text{Path}_{\| A \|_1}(a, b)) \to (r, s : \text{Path}_{\text{Path}_{\| A \|_1}(a, b)}(p, q)) \to \text{Path}_{\text{Path}_{\text{Path}_{\| A \|_1}(a, b)}(p, q)}(r, s)
\end{cases}
\]
\begin{lstlisting}
data grpdTrunc (A: U)
   = inc (a: A)
   | squash (a b: grpdTrunc A)
            (p q: Path (grpdTrunc A) a b)
            (r s: Path (Path (grpdTrunc A) a b) p q)
     <i j k> [ (i = 0) -> r @ j @ k, (i = 1) -> s @ j @ k,
               (j = 0) -> p @ k,     (j = 1) -> q @ k,
               (k = 0) -> a,         (k = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\| A \|_1$)
For a 1-groupoid $B : \mathcal{U}$ (i.e., $\text{isGroupoid}(B)$), a map $f : A \to B$, there exists $\text{grpdTruncRec} : \| A \|_1 \to B$, such that $\text{grpdTruncRec}(\text{inc}(a)) = f(a)$.
\end{theorem}

\newpage

\subsection{Set-Quotients}
Set quotients construct a type $A$ quotiented by a relation $R : A \to A \to \mathcal{U}$, ensuring the result is a set.

\begin{definition} (Set Quotient)
For a type $A : \mathcal{U}$ and a relation $R : A \to A \to \mathcal{U}$, the set quotient $\text{setQuot } A R : \mathcal{U}$.
\[
\begin{cases}
\text{quotient} : A \to \text{setQuot } A R \\
\text{identification} : (a, b : A) \to R a b \to \text{Path}_{\text{setQuot } A R} (\text{quotient } a, \text{quotient } b) \\
\text{trunc} : (a, b : \text{setQuot } A R) \to (p, q : \text{Path}_{\text{setQuot } A R}(a, b)) \to \text{Path}_{\text{Path}_{\text{setQuot } A R}(a, b)}(p, q)
\end{cases}
\]
\begin{lstlisting}
data setQuot (A: U) (R: A -> A -> U)
   = quotient (a: A)
   | identification (a b: A) (r: R a b)
     <i> [ (i=0) -> quotient a, (i=1) -> quotient b ]
   | trunc (a b : setQuot A R) (p q : Path (setQuot A R) a b)
     <i j> [ (i = 0) -> p @ j , (i = 1) -> q @ j ,
             (j = 0) -> a ,     (j = 1) -> b ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\text{setQuot}$)
For a type family $B : \text{setQuot } A R \to \mathcal{U}$ with $\text{isSet}(B x)$, and maps $f : (x : A) \to B(\text{quotient } x)$, $g : (a, b : A) \to (r : R a b) \to \text{PathP} (\langle i \rangle B(\text{identification } a b r @ i)) (f a) (f b)$, there exists $\text{setQuotElim} : \Pi_{x:\text{setQuot } A R} B(x)$, such that $\text{setQuotElim}(\text{quotient } a) = f a$.
\end{theorem}

\subsection{Groupoid-Quotients}
Groupoid quotients extend set quotients to produce a 1-groupoid, incorporating higher path constructors.

\begin{definition} (Groupoid Quotient)
For a type $A : \mathcal{U}$ and a relation $R : A \to A \to \mathcal{U}$, the groupoid quotient $\text{grpdQuot } A R : \mathcal{U}$ includes constructors for points, paths, and higher paths ensuring 1-groupoid structure. (Note: Full definition requires additional structure, partially omitted for brevity.)
\end{definition}

\newpage

\subsection{Colimits}
Colimits construct the limit of a sequence of types connected by maps, such as propositional truncations.

\begin{definition} (Colimit)
For a sequence of types $A : \text{nat} \to \mathcal{U}$ and maps $f : (n : \text{nat}) \to A n \to A (\text{succ } n)$, the colimit type $\text{colimit } A f : \mathcal{U}$.
\[
\begin{cases}
\text{ix} : (n : \text{nat}) \to A n \to \text{colimit } A f \\
\text{gx} : (n : \text{nat}) \to (a : A n) \to \text{Path}_{\text{colimit } A f} (\text{ix} (\text{succ } n) (f n a), \text{ix} n a)
\end{cases}
\]
\begin{lstlisting}
data colimit (A : nat -> U)
             (f : (n : nat) -> A n -> A (succ n))
   = ix (n : nat) (x: A n)
   | gx (n : nat) (a: A n) <i> [ (i=0) -> ix (succ n) (f n a)
                               , (i=1) -> ix n a]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $\text{colimit}$)
For a type $P : \text{colimit } A f \to \mathcal{U}$, with $p : (n : \text{nat}) \to (x : A n) \to P(\text{ix}(n, x))$ and $q : (n : \text{nat}) \to (a : A n) \to \text{PathP} (\langle i \rangle P(\text{gx}(n, a) @ i)) (p (\text{succ } n) (f n a)) (p n a)$, there exists $i : \Pi_{x:\text{colimit } A f} P(x)$, such that $i(\text{ix}(n, x)) = p n x$.
\end{theorem}

\newpage

\subsection{Equalizer}
The equalizer of two maps $f, g : A \to B$ is a higher inductive type (HIT) that constructs a type consisting of elements in $B$ where $f$ and $g$ agree, along with paths enforcing this equality. It is a fundamental construction in homotopy type theory, capturing the subspace of $B$ where $f(a) = g(a)$ for $a : A$.

\begin{definition} (Formation)
For types $A, B : \mathcal{U}$ and maps $f, g : A \to B$, the equalizer $\text{coeq } A B f g : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The equalizer is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{inC} : B \to \text{coeq } A B f g \\
\text{glueC} : (a : A) \to \text{Path}_{\text{coeq } A B f g} (\text{inC } (f a), \text{inC } (g a))
\end{cases}
\]
\begin{lstlisting}
data coeq (A B: U) (f g: A -> B)
   = inC (_: B)
   | glueC (a: A) <i> [(i=0) -> inC (f a), (i=1) -> inC (g a) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $C : \mathcal{U}$, a map $h : B \to C$, and a family of paths $y : (x : A) \to \text{Path}_C (h (f x), h (g x))$, there exists a map $\text{coequRec} : \text{coeq } A B f g \to C$ such that:
\[
\begin{cases}
\text{coequRec}(\text{inC } x) = h(x) \\
\text{coequRec}(\text{glueC } x \, @ \, i) = y(x) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
coequRec (A B C : U) (f g : A -> B) (h: B -> C) (y: (x : A) -> Path C (h (f x)) (h (g x)))
   : (z : coeq A B f g) -> C
   = split
     inC x -> h x
     glueC x @ i -> y x @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
For $z : \text{coeq } A B f g$,
\[
\begin{cases}
\text{coequRec}(\text{inC } x) \equiv h(x) \\
\text{coequRec}(\text{glueC } x \, @ \, i) \equiv y(x) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \text{coeq } A B f g \to C$ are homotopic if they agree on $\text{inC}$ and $\text{glueC}$, i.e., if $h_1(\text{inC } x) = h_2(\text{inC } x)$ for all $x : B$ and $h_1(\text{glueC } a) = h_2(\text{glueC } a)$ for all $a : A$.
\end{theorem}

\begin{example} (Equalizer as Subspace)
The equalizer $\text{coeq } A B f g$ represents the subspace of $B$ where $f(a) = g(a)$. For example, if $A = B = \mathbb{R}$ and $f(x) = x^2$, $g(x) = x$, the equalizer captures points where $x^2 = x$, i.e., $\{0, 1\}$.
\end{example}

\subsection{Path-Equalizer}
The path-equalizer is a higher inductive type that generalizes the equalizer to handle pairs of paths in $B$. Given a map $p : A \to (b_1, b_2 : B) \times (\text{Path}_B (b_1, b_2)) \times (\text{Path}_B (b_1, b_2))$, it constructs a type where elements of $A$ induce pairs of paths between points in $B$, with paths connecting the endpoints of these paths.

\begin{definition} (Formation)
For types $A, B : \mathcal{U}$ and a map $p : A \to (b_1, b_2 : B) \times (\text{Path}_B (b_1, b_2)) \times (\text{Path}_B (b_1, b_2))$, the path-equalizer $\text{coeqP } A B p : \mathcal{U}$.
\end{definition}

\begin{definition} (Introduction)
The path-equalizer is generated by the following higher inductive composition structure:
\[
\begin{cases}
\text{inP} : B \to \text{coeqP } A B p \\
\text{glueP} : (a : A) \to \text{Path}_{\text{coeqP } A B p} (\text{inP } (((p \, a).2.2.1) \, @ \, 0), \text{inP } (((p \, a).2.2.2) \, @ \, 1))
\end{cases}
\]
\begin{lstlisting}
data coeqP (A B: U) (p : A -> (b1 b2: B) * (_: Path B b1 b2) * (Path B b1 b2))
   = inP (b: B)
   | glueP (a:A) <i> [(i=0) -> inP (((p a).2.2.1) @ 0), (i=1) -> inP (((p a).2.2.2) @ 1) ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination)
For a type $C : \mathcal{U}$, a map $h : B \to C$, and a family of paths $y : (a : A) \to \text{Path}_C (h (((p \, a).2.2.1) \, @ \, 0), h (((p \, a).2.2.2) \, @ \, 1))$, there exists a map $\text{coequPRec} : \text{coeqP } A B p \to C$ such that:
\[
\begin{cases}
\text{coequPRec}(\text{inP } b) = h(b) \\
\text{coequPRec}(\text{glueP } a \, @ \, i) = y(a) \, @ \, i
\end{cases}
\]
\begin{lstlisting}
coequPRec (A B C : U) (p : A -> (b1 b2: B) * (_: Path B b1 b2) * (Path B b1 b2))
          (h: B -> C) (y: (a : A) -> Path C (h (((p a).2.2.1) @ 0)) (h (((p a).2.2.2) @ 1)))
   : (z : coeqP A B p) -> C
   = split
     inP b -> h b
     glueP a @ i -> y a @ i
\end{lstlisting}
\end{theorem}

\begin{theorem} (Computation)
For $z : \text{coeqP } A B p$,
\[
\begin{cases}
\text{coequPRec}(\text{inP } b) \equiv h(b) \\
\text{coequPRec}(\text{glueP } a \, @ \, i) \equiv y(a) \, @ \, i
\end{cases}
\]
\end{theorem}

\begin{theorem} (Uniqueness)
Any two maps $h_1, h_2 : \text{coeqP } A B p \to C$ are homotopic if they agree on $\text{inP}$ and $\text{glueP}$, i.e., if $h_1(\text{inP } b) = h_2(\text{inP } b)$ for all $b : B$ and $h_1(\text{glueP } a) = h_2(\text{glueP } a)$ for all $a : A$.
\end{theorem}

\begin{example} (Path-Equalizer for Homotopy)
The path-equalizer can model spaces where elements of $A$ specify pairs of paths between points in $B$. For instance, if $p(a)$ provides two paths from $b_1$ to $b_2$ in $B$, $\text{coeqP}$ constructs a type connecting the starting and ending points of these paths, useful in studying homotopy classes.
\end{example}

\newpage

\subsection{K(G,n)}
Eilenberg-MacLane spaces $K(G,n)$ have a single non-trivial homotopy group $\pi_n(K(G,n)) = G$. They are defined using truncations and suspensions.

\begin{definition} (K(G,n))
For an abelian group $G : \text{abgroup}$, the type $KGn G : \text{nat} \to \mathcal{U}$.
\[
\begin{cases}
n = 0: KGn G 0 = \text{discreteTopology}(G) \\
n \geq 1: KGn G (\text{succ } n) = \text{nTrunc}(\text{suspension}(K1' (G.1, G.2.1)) n) (\text{succ } n)
\end{cases}
\]
\begin{lstlisting}
KGn (G: abgroup)
  : nat -> U
  = split
    zero -> discreteTopology G
    succ n -> nTrunc (suspension (K1' (G.1,G.2.1)) n) (succ n)
\end{lstlisting}
\end{definition}

\begin{theorem} (Elimination $KGn$)
For $n \geq 1$, a type $B : \mathcal{U}$ with $\text{isNGroupoid}(B, \text{succ } n)$, and a map $f : \text{suspension}(K1' G) \to B$, there exists $\text{rec}_{KGn} : KGn G (\text{succ } n) \to B$, defined via $\text{nTruncRec}$.
\end{theorem}

\newpage

\subsection{Localization}
Localization constructs an $F$-local type from a type $X$, with respect to a family of maps $F_A : S(a) \to T(a)$.

\begin{definition} (Localization Modality)
For a family of maps $F_A : S(a) \to T(a)$, the $F$-localization $L^{AST}_F(X) : \mathcal{U}$.
\[
\begin{cases}
\text{center} : X \to L_{F_A}(X) \\
\text{ext} : (a : A) \to (S(a) \to L_{F_A}(X)) \to T(a) \to L_{F_A}(X) \\
\text{isExt} : (a : A) \to (f : S(a) \to L_{F_A}(X)) \to (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (\text{ext } a f (F a s), f s) \\
\text{extEq} : (a : A) \to (g, h : T(a) \to L_{F_A}(X)) \to (p : (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (g (F a s), h (F a s))) \to (t : T(a)) \to \text{Path}_{L_{F_A}(X)} (g t, h t) \\
\text{isExtEq} : (a : A) \to (g, h : T(a) \to L_{F_A}(X)) \to (p : (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (g (F a s), h (F a s))) \to (s : S(a)) \to \text{Path}_{L_{F_A}(X)} (\text{extEq } a g h p (F a s), p s)
\end{cases}
\]
\begin{lstlisting}
data Localize (A X: U) (S T: A -> U) (F : (x:A) -> S x -> T x)
   = center (x: X)
   | ext (a: A) (f: S a -> Localize A X S T F) (t: T a)
   | isExt (a: A) (f: S a -> Localize A X S T F) (s: S a) <i>
     [ (i=0) -> ext a f (F a s) , (i=1) -> f s ]
   | extEq (a: A) (g h: T a -> Localize A X S T F)
     (p: (s : S a) -> Path (Localize A X S T F) (g (F a s)) (h (F a s)))
     (t : T a) <i> [ (i=0) -> g t , (i=1) -> h t ]
   | isExtEq (a: A) (g h : T a -> Localize A X S T F)
     (p: (s : S a) -> Path (T a -> Localize A X S T F) (g (F a s)) (h (F a s)))
     (s : S a) <i> [ (i=0) -> extEq a g h p (F a s) , (i=1) -> p s ]
\end{lstlisting}
\end{definition}

\begin{theorem} (Localization Induction)
For any $P : \Pi_{X:U} L_{F_A}(X) \to U$ with $\{n, r, s\}$ satisfying coherence conditions, there exists $i : \Pi_{x:L_{F_A}(X)} P(x)$ such that $i \cdot \text{center}_X = n$.
\end{theorem}


\section{Conclusion}
HITs encode CW-complexes in HoTT, bridging topology and type theory. They capture cell attachments, with examples like spheres, tori, and truncations. Infinity constructors extend HITs to infinite spaces, handled by Agda Cubicalâ€™s primitives and indexed HITs.

\bibliographystyle{plain}
\begin{thebibliography}{9}
\bibitem{univalent}
The Univalent Foundations Program, \emph{Homotopy Type Theory: Univalent Foundations of Mathematics}, IAS, 2013.
\bibitem{cubicaltt}
C. Cohen, T. Coquand, S. Huber, A. MÃ¶rtberg, \emph{Cubical Type Theory}, Journal of Automated Reasoning, 2018.
\bibitem{agda-cubical}
A. MÃ¶rtberg et al., \emph{Agda Cubical Library}, \url{https://github.com/agda/cubical}, 2023.
\bibitem{hott-book}
M. Shulman, \emph{Higher Inductive Types in HoTT}, \url{https://arxiv.org/abs/1705.07088}, 2017.
\bibitem{localization}
J. D. Christensen, M. Opie, E. Rijke, L. Scoccola, \emph{Localization in Homotopy Type Theory}, \url{https://arxiv.org/pdf/1807.04155.pdf}, 2018.
\bibitem{modalities}
E. Rijke, M. Shulman, B. Spitters, \emph{Modalities in Homotopy Type Theory}, \url{https://arxiv.org/pdf/1706.07526v6.pdf}, 2017.
\bibitem{synthetic-spectra}
M. Riley, E. Finster, D. R. Licata, \emph{Synthetic Spectra via a Monadic and Comonadic Modality}, \url{https://arxiv.org/pdf/2102.04099.pdf}, 2021.
\end{thebibliography}

\end{document}
