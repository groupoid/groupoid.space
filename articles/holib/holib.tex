% copyright (c) 2018 Groupoid Infinity

\documentclass{article}
\usepackage[english,ukrainian]{babel}
\usepackage{hyphenat}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{url}
\usepackage{tikz-cd}
\usepackage[utf8]{inputenc}
\theoremstyle{definition}
\newtheorem{theorem}{Теорема}
\newtheorem{definition}{Визначення}
\newtheorem{exercise}{Вправа}
\newtheorem{example}{Приклад}
\newcommand*{\sigmatype}{$\Sigma$}
\newcommand*{\nat}{$\mathbb{N}$}
\newcommand*{\presheaf}{$\mathbb{\int}$}
\newcommand*{\defequ}{$=_{def}$}
\newcommand*{\incmap}{\hookrightarrow}
\newcommand*{\thead}[1]{\multicolumn{1}{c}{\bfseries #1}}
\lstset{basicstyle=\small,inputencoding=utf8}

\addto\captionsukrainian{\renewcommand{\contentsname}{Зміст}}
\addto\captionsukrainian{\def\refname{Список використаних джерел}}
\addto\captionsukrainian{\renewcommand{\abstractname}{Анотація}}

\begin{document}
\title{Issue V: Homotopy Library}
\author{Максим Сохацький$^1$ }
\date{ \small $^1$ Інститут математики «Групоїд Інфініті» \\
       13 січня 2024 }
\maketitle

\begin{abstract}
Тут представлена базова гомотопічна бібліотека мови {\bf Anders} для курсу «Теорія типів»,
яка сумісна з позначеннями, що використовуються в підручнику HoTT.
Серед принципів, які покладені в основу бібліотеки, головними є:
лаконічность, академічність, педагогічність. Кожна сторінка має
на меті повністю висвітлити компоненти типу, використовуючи тільки
ті типи, що були викладені попередньо, кожне визначення повинно
містити як математичну нотацію так і код верифікатора та бути
вичерпним посібником користувача мови програмування {\bf Anders} та
її базової бібліотеки. Загалом передбачається, що бібліотека
повинна відповідати підручнику HoTT, та бути його практичним
досліднидницьким артефактом.
\\
\\
{\bf Ключові слова}: Теорія типів, формалізація математики
\end{abstract}

\section*{Теорія типів}
Теорія типів --- це універсальна мова програмування чистої
математики (для доведення теорем), яка може містити довільну
кількість консистентних аксіом, впорядкованих у вигляді псевдо-ізоморфізмів:
1) сигнатури типу або формації;
2) функції encode, способи конструювання елементів типу або конструкція;
3) функції decode, залежні елімінатори принципу індукції типу або елімінація;
4) рівняння бета правила або обчислювальності;
5) рівняння ета правила або унікальності.
Таке визначення було дано Мартіном-Льофом,
від чого теорія типів носить його ім'я MLTT.

Головна мотивація гомотопічної теорії — надати обчислювальну
семантику гомотопічним типам та CW-комплексам. Головна ідея
гомотопічної теорії [1] полягає в поєднанні просторів функцій,
просторів контекстів  і просторів шляхів  таким чином, що вони
утворюють фібраційну рівність яка збігається (доводиться в самій
теорії) з простором шляхів.

Завдяки відсутності ета-правила у рівності, не кожні два
доведення одного простору шляхів дорівнюють між собою, отже
простір шляхів утворює багатовимірну структуру інфініті-групоїда.

\newpage
\section*{Основи}

Перша частина базової бібліотеки --- модальні унівалентні MLTT основи,
що розділені на три групи. Перша група містить класичні типи MLTT
системи описані Мартіном-Льофом, які присутні у мовах $\mathbf{Per}$
та $\mathbf{Anders}$. Друга група містить унівалентні ідентифікаційні
системи мови $\mathbf{Anders}$. Третя група містить модальності мови
$\mathbf{Anders}$, які використовуються в диференціальній геометріїї
та в теорії гомотопій. Основи пропонують фундаментальний базис який
використовується для формалізації сучасної математики в таких системах
доведення теорем як: Coq, Agda, Lean.
\\
\\
\noindent
$\bullet$ Фібраційні \\
$\bullet$ Унівалентні \\
$\bullet$ Модальні

\section*{Математики}

Друга частина базової бібліотеки $\mathbf{Anders}$ містить формалізації математичних
теорій з різних галузей математики: аналіз, алгебра, геометрія,
теорія гомотопій, теорія категорій.

Слухачам курсу (10) пропонується застосувати теорію типів для
доведення початкового але нетривіального результу, який є
відкритою проблемою в теорії типів для однєї із математик,
що є курсами на кафедрі чистої математики (КМ-111):\\
\\
\noindent
$\bullet$ Функціональний аналіз \\
$\bullet$ Гомологічна алгебра \\
$\bullet$ Диференціальна геометрія \\
$\bullet$ Теорія гомотопій \\
$\bullet$ Теорія категорій \\

\section*{Програми}

Третя частини базової бібліотеки, присутня у мовах $\mathbf{Per}$ та $\mathbf{Anders}$,
присвячена прикладам з промислового програмування в області автоматизації
підприємств та інформаційних технологій, а саме для специфікації програмних інтерфейсів.
\\
\\
\noindent $\bullet$ Формалізація двонаправленого тракту \\
$\bullet$ Формалізація графічного веб інтерфейсу \\
$\bullet$ Формалізація бази даних з єдиним простором ключів \\
$\bullet$ Формалізація реляційної бази даних \\
$\bullet$ Формалізація системи управління процесами \\

\section*{Філософії}

З сучасників формальною філософією в HoTT загалом займається Девід Корфілд,
а формалізацією свідомості як окремий предмет вивчають Хенк Барендрехт та Горо Като.
Формальна теорія природніх мов теж формалізується за допомогою MLTT,
а основні теореми доводять в HoTT. В четвертій частині базової
бібліотеки $\mathbf{Anders}$ наводяться приклади програм, які
маніфестують висловлювання і теореми з формальної філософії про пустотність
всіх феноменів та синтаксис, морфологію і семантику природньої української мови.
\\
\\
\noindent $\bullet$ Формалізація Мадг'яміки \\
$\bullet$ Формалізація української мови в кванторах

\section*{Структура верифікатора}

На відміну від одноаксіоматичного верифікатора $\mathbf{Henk}$,
який містить тільки один індексований всесвіт $U_i$, рівність
за визначенням для примітивів єдиного $\Pi$-типу, та функцію
верифікації $\tau = \mathbf{type}$, верифікатори $\mathbf{Per}$
і $\mathbf{Anders}$ містять додатково $\Sigma$-тип для контекстів
та телескопів, більш деталізовану функцію типізації $\tau$,
та багато інших досніпових модулів, крім $\Pi$-типу, але які
теж підпорядковуються системі типів Мартіна-Льофа.

\subsection*{Космос \nat-індексованих всесвітів $\omega$ }

В теорії типів всі сигнатури всіх типів живуть в ієрархіях
всесвітів індексованих натуральними числами. Множина таких
ієрархій називається космосом. В імплементаціях $\mathbb{N}$
завжди реалізовано як Big Integer. Верифікатор $\mathbf{Anders}$ має
космос, що складається з двох ієрархій всесвітів $\omega = \{ \mathbf{V}_i, \mathbf{U}_i \}$.

\subsection*{Рівність \defequ\ з точністю до $\alpha$-$\beta$ конверсій}

Рівність за визначенням (інтенсіональна) двох термів означає, що за допомогою серії альфа та бета
перетворень можна довести що терми дорівнюють посимвольно (бінарно). Саме ця функція повинна бути
імплементована для всіх типів у верифікаторі. Програми, які доводять рівність двох термів
в теорії самого верифікатора за допомогою конструкторів рефлексивності називаються екстенсіональними рівностями.
Якшо це відбувається для $=$-типу у всесвітах $V_i$ --- це називаються пропрозиційними рівностями,
а якшо в інших ідентифікаційних системах у всесвітах $U_i$ -- називаються типовими рівностями.
Інтерналізація інтенсіональної рівності за визначенням всередині теорії за
допомогою $\Pi$-типів називається рівністю Лейбніца і є виводимою у всіх фібраційних верифікаторах.

\subsection*{Функція верифікації $\tau$}

Головна функція верифікації  розпадається на систему взаємозалежних функцій
$\tau = \{ \mathbf{infer},\mathbf{app}, \mathbf{check}, \mathbf{act}, \mathbf{conv}, \mathbf{eval} \}$,
які повинні бути імплементовані для кожного типу, вбудованого в верифікатор.

\subsection*{Контексти та телескопи \sigmatype }

В теорії типів контексти, як алгебраїчні послідовності які містять сигнатури, які теж у свою
чергу складаються з послідовністей пар, що складаються з імені змінної та її типу, визначаються
$\Sigma$-типами.

\subsection*{Досніпові модулі \presheaf\ вбудованих типів}

Кожен досніповий модуль повинен бути представлений у вигляді п'яти
синтаксичних примітивів: 1) формації; 2) конструкції; 3) елімінації;
4) обчислювальності; 5) унікальності. Ці примітиви повинні бути узгоджені
в сенсі Мартіна-Льофа та представлені у цій статті,
як документація на бібліотеку верифікатора, як у тому числі дає формальне визначення
примітивам в конкретній теорії $\mathrm{\int} = \{ \Pi, \Sigma, =, \mathbf{W},
\mathbf{0}, \mathbf{1}, \mathbf{2}, \mathbf{Path}, \mathbf{Glue} \}$.

\newpage

\section{Простори функцій}
$\Pi$-тип — це простір, що містить залежні функції, кодомен яких залежить від значення
з домену. Так як всі розшарування домену присутні повністю в кожній функції з простору,
$\Pi$-тип також називається залежним добутком, так як фунція визначена на всьому просторі домена.

Простори залежних функції використовуються в теорії типів для моделювання різних
математичних конструкцій, об'єктів, типів, просторів, а також їхніх відображень:
залежних функцій, неперервниї відображень, етальних відображень, розшарувань, квантора
узанальнення $\forall$, імплікації, тощо.

 \subsection{Формація}

$\textbf{Визначення\ 1.1}$ ($\Pi$-формація, залежний добуток).
$\Pi$-типи репрезентують спосіб створення просторів залежних функцій  $f: \Pi(x:A), B(x)$ в певному всесвіті $U_i$,
з доменом в $A$ і кодоменом в сім'ї функцій $B : A \rightarrow U_i$ над $A$.
$$
   \Pi : U =_{def} \prod_{x:A}B(x).
$$
\begin{lstlisting}[mathescape=true]
def Pi (A : U) (B : A $\rightarrow$ U) : U
 := $\Pi$ (x : A), B(x)
\end{lstlisting}

\subsection{Конструкція}

$\textbf{Визначення\ 1.2}$ ($\lambda$-функція).
Лямбда конструктор визначає нову лямбда функцію в просторі залежних функцій,
вона ще називається лямбда абстракцією і позначається як $\lambda x. b(x)$ або $x \mapsto b(x)$.
$$
    \lambda (x: A) \rightarrow b(x) : \Pi(A,B) =_{def}
$$
$$
    \prod_{A:U}\prod_{B:A \rightarrow U}\prod_{a: A}\prod_{b:B(a)}\lambda x.b.
$$
\begin{lstlisting}[mathescape=true]
def lambda (A: U) (B: A $\rightarrow$ U) (b: Pi A B)
  : Pi A B := $\lambda$ (x : A), b(x)

def lam (A B: U) (f: A $\rightarrow$ B)
  : A $\rightarrow$ B := $\lambda$ (x : A), f(x)
\end{lstlisting}

Коли кодомен не залежить від значеення з домену функції $f: A \rightarrow B$
розглядаються в контексті System F$_\omega$, залежний випадок розглядається
в  Systen P$_\omega$ або Calculus of Construction (CoC).

\newpage
\subsection{Елімінація}

$\textbf{Визначення\ 1.3}$ (Принцип індукції). Якшо предикат виконується для
лямбда функції тоді існує функція з простору функцій в простіп предикатів.

\begin{lstlisting}[mathescape=true]
def $\Pi$-ind (A : U) (B : A $\rightarrow$ U) (C : Pi A B $\rightarrow$ U)
    (g: $\Pi$ (x: Pi A B), C x)
  : $\Pi$ (p: Pi A B), C p := $\lambda$ (p: Pi A B), g(p)
\end{lstlisting}

\noindent $\textbf{Визначення\ 1.3.1}$ ($\lambda$-аплікація).
Застосування функції до аргументів редукує терм
використовуючи рекурсивну підстановку аргументів в тіло функції.

$$
    f\ a : B(a) =_{def} \prod_{A:U}\prod_{B: A \rightarrow U}\prod_{a:A}\prod_{f: \prod_{x:A}B(a)}f(a).
$$

\begin{lstlisting}[mathescape=true]
def apply (A: U) (B: A $\rightarrow$ U) (f: Pi A B) (a: A) : B a := f(a)
def app (A B: U) (f: A $\rightarrow$ B) (x: A): B := f(x)
\end{lstlisting}

\noindent $\textbf{Визначення\ 1.3.2}$ (Композиція функцій).
\begin{lstlisting}[mathescape=true]
def $\circ^T$ (x y z: U) : U
 := (y $\rightarrow$ z) $\rightarrow$ (x $\rightarrow$ y) $\rightarrow$ (x $\rightarrow$ z)

def $\circ$ (x y z : U) : $\circ^T$ x y z
 := $\lambda$ (g: x $\rightarrow$ z) (f: x $\rightarrow$ y) (a: x), g (f a)
\end{lstlisting}

\subsection{Обчислювальність}

$\textbf{Теорема\ 1.4}$ (Обчислювальність $\Pi_\beta$).
$\beta$-правило показує, що композиція $\mathrm{lam} \circ \mathrm{app}$ може бути скорочена (fused).
$$
    f(a) =_{B(a)} (\lambda (x:A) \rightarrow f(a))(a).
$$
\begin{lstlisting}[mathescape=true]
def $\Pi$-$\beta$ (A : U) (B : A $\rightarrow$ U) (a : A) (f : Pi A B)
  : Path (B a) (apply A B (lambda A B f) a) (f a)
 := idp (B a) (f a)
\end{lstlisting}

\subsection{Унікальність}

$\textbf{Теорема\ 1.5}$ (Унікальність $\Pi_\eta$).
$\eta$-правило показує, що композиація $\mathrm{app} \circ \mathrm{lam}$ можу бути скоронеча (fused).
$$
    f =_{(x:A)\rightarrow B(a)} (\lambda (y:A) \rightarrow f(y)).
$$
\begin{lstlisting}[mathescape=true]
def $\Pi$-$\eta$ (A : U) (B : A $\rightarrow$ U) (a : A) (f : Pi A B)
  : Path (Pi A B) f ($\lambda$ (x : A), f x)
 := idp (Pi A B) f
\end{lstlisting}

\newpage
\section{Простори контекстів}

$\Sigma$-тип --- це простір, що містить залежні пари, де тип другого
елемента залежить від значення першого елемента. Оскільки в кожній
визначеній парі присутня лише одна точка домену волокна, — тип також
є залежною сумою, де основа волокна є непересічним об'єднанням.

Простори залежних пар використовуються в теорії типів для моделювання
декартових добутків, непересічних сум, розшарувань, векторних просторів,
телескопів, лінз, контекстів, об'єктів, алгебр, квантору існування $\exists$, тощо.

\subsection{Формація}

$\textbf{Визначення\ 2.1}$ ($\Sigma$-формація, залежна сума). Тип залежної суми
індексований типом  $A$ в сенсу кодобутку або диз'юнктивної суми, де тільки одне
волокно кодомену $B(x)$ присутнє в парі.
$$
     \Sigma : U =_{def} \sum_{x:A} B(x).
$$
\begin{lstlisting}[mathescape=true]
def Sigma (A: U) (B: A $\rightarrow$ U) : U
 := $\Sigma$ (x: A), B(x)
\end{lstlisting}

\subsection{Конструкція}

$\textbf{Визначення\ 2.2}$ (Залежна пара). Конструктор залежної пари —
це спосіб визначення індексованої пари над типом $A$ елементу кодобутку
або диз'юнктивного об'єднання.
$$
      \mathbf{pair} : \Sigma(A,B) =_{def}
$$
$$
      \prod_{A:U}\prod_{B:A \rightarrow U}\prod_{a:A}\prod_{b:B(a)} (a,b).
$$
\begin{lstlisting}[mathescape=true]
def pair (A: U) (B: A $\rightarrow$ U) (a: A) (b: B a)
  : Sigma A B := (a, b)
\end{lstlisting}

\newpage

\subsection{Елімінація}

$\textbf{Визначення\ 2.3}$ (Проекції). Залежні проекції
$pr_{1}: \Sigma(A,B) \rightarrow A$ і
$pr_{2}: \Pi_{x: \Sigma(A,B)} B(pr_{1}(x))$ є деконструкторами пари.
$$
    \mathbf{pr}_1 : \prod_{A:U} \prod_{B:A \rightarrow U} \prod_{x: \Sigma(A,B)} A
$$
$$
    =_{def} .1 =_{def} (a,b) \mapsto a.
$$
$$
    \mathbf{pr}_2 : \prod_{A:U} \prod_{B:A \rightarrow U} \prod_{x: \Sigma(A,B)} B(x.1)
$$
$$
    =_{def} .2 =_{def} (a,b) \mapsto b.
$$
\begin{lstlisting}[mathescape=true]
def pr$_1$ (A: U) (B: A $\rightarrow$ U) (x: Sigma A B) : A := x.1
def pr$_2$ (A: U) (B: A $\rightarrow$ U) (x: Sigma A B) : B (pr$_1$ A B x) := x.2
\end{lstlisting}

Якшо ви хочете доступитися до глибокого (>1) поля в сігма-типі — ви повинні використати
серію елімінаторів $.2$, яка закінчується елімінатором $.1$.
\\
\\
\noindent $\textbf{Визначення\ 2.3.1}$ (Принцип індукції $\Sigma$). Каже, що
предикат, який виконується для двох проекцій, він виконується також і для
всього простору пар.

\begin{lstlisting}[mathescape=true]
def $\Sigma$-ind (A : U) (B : A $\rightarrow$ U)
    (C : $\Pi$ (s: $\Sigma$ (x: A), B x), U)
    (g: $\Pi$ (x: A) (y: B x), C (x,y))
    (p: $\Sigma$ (x: A), B x) : C p := g p.1 p.2
\end{lstlisting}

\subsection{Обчислювальність}

$\textbf{Визначення\ 2.4}$ ($\Sigma$-обчислювальність).
\begin{lstlisting}[mathescape=true]
def $\Sigma$-$\beta_1$ (A : U) (B : A $\rightarrow$ U) (a : A) (b : B a)
  : Path A a (pr$_1$ A B (a, b)) := idp A a

def $\Sigma$-$\beta_2$ (A : U) (B : A $\rightarrow$ U) (a : A) (b : B a)
  : Path (B a) b (pr$_2$ A B (a, b)) := idp (B a) b
\end{lstlisting}

\subsection{Унікальність}

$\textbf{Визначення\ 2.5}$ ($\Sigma$-унікальність).
\begin{lstlisting}[mathescape=true]
def $\Sigma$-$\eta$ (A : U) (B : A $\rightarrow$ U) (p : Sigma A B)
  : Path (Sigma A B) p (pr$_1$ A B p, pr$_2$ A B p)
 := idp (Sigma A B) p
\end{lstlisting}

\newpage
\section{Ідентифікаційні простори}

$=$-тип --- це індуктивна родина функій індексована елементами $x,y : A$,
які містять доведення того факту, що ці елементи рівні між собою $x=y$.

\subsection{Формація}
$\textbf{Визначення\ 3.1}$ ($=$-формація, родина залежних функцій). Індуктивна родина
$Id_V: A \rightarrow A \rightarrow V$ з доменом і кодоменом у всесвіті $V$
представляє елементи, що містять доведення факту, що індексовані $x,y:A$
елменти рівні між собою.
$$
  =\hspace{0.4em} : V =_{def} \prod_{A:V}\prod_{x,y:A} \mathbf{Id}_V(A,x,y).
$$
\begin{lstlisting}[mathescape=true]
def IdV (A: V) (x y: A)
  : V := Id A x y
\end{lstlisting}

\subsection{Конструкція}
$\textbf{Визначення\ 3.2}$ ($=$-конструкція, рефлексивність). Елементи індуктивної родини
інстанціюються єдиним конструктором який містить доведення, що елемент типу $x:A$ дорівнює сам собі.
$$
   \mathbf{ref}_V : x =_A x =_{def} \prod_{A:V}\prod_{x:A} \mathbf{ref}_A(x)
$$
\begin{lstlisting}[mathescape=true]
def Id-ref (A : V) (a: A)
  : Id A a a := ref a
\end{lstlisting}

\subsection{Елімінація}
$\textbf{Визначення\ 3.3}$ ($=$-елімінатор, J). Для індуктивної родини
$C$ і функції $c$ існує функція $f$ така, що $f(x,x,\mathbf{ref}_V(A,x)) = c(x)$.
$$
    \mathbf{ind}_{=_A} : (p: x =_A y) \rightarrow C(x,y,p) =_{def}
$$
$$
    \prod_{A:V}\prod_{C:\Pi_{x,y:A}x=y\rightarrow V}\prod_{c: C(x,x,\mathbf{ref}(x))}
$$
$$
    \lambda p.\mathbf{J}(A,C,x,c,y,p).
$$
\begin{lstlisting}[mathescape=true]
def =-ind (A : V)
    (C : $\Pi$ (x y : A), Id A x y $\rightarrow$ V)
    (x y : A) (c : C x x (ref x))
    (p : Id A x y)
  : C x y p
 := ind$_\mathbf{J}$ A C x c y p
\end{lstlisting}

\subsection{Обчислювальність}
$\textbf{Визначення\ 3.4}$ ($=$-обчислювальність).
\begin{lstlisting}[mathescape=true]
def J$^S$-$\beta$ (A : V)
    (C : $\Pi$ (a b : A), Id A a b $\rightarrow$ V)
    (a : A) (c : C a a (ref a))
  : Id (C a a (ref a)) (J$^S$ A C a a c (ref a)) c
 := ref c
\end{lstlisting}

\subsection{Унікальність}
$\textbf{Визначення\ 3.5}$ ($=$-унікальність).
\begin{lstlisting}[mathescape=true]
def UIP (A : V) (a b : A) (p q : Id A a b)
  : Id (Id A a b) p q
 := ref p
\end{lstlisting}

\newpage
\section{Індуктивні простори}

\end{document}

