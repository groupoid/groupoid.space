<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Namdak Tonpa"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta property="og:title" content="INDUCTIVE"><meta property="og:description" content="Inductive MLTT Foundations"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space/foundations/mltt/inductive/"><link rel="stylesheet" href="https://groupoid.space/main.css"><title>INDUCTIVE</title><script src="https://groupoid.space/styles/mathjax.js?config=TeX-AMS_HTML"></script><script>window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
               TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
               extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
               "HTML-CSS": { imageFont: null },
               AuthorInit: function() {
                   MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                       var TEX = MathJax.InputJax.TeX;
                       TEX.Definitions.Add({
                           macros: {
                             llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                             rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                             llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                             rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                           }
                       });
                   });
               },
               tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                          processEscapes: true }
           };</script></head><body class="content"></body></html><article class="main list"><section><h1>INDUCTIVE BASIS</h1><aside><time>Published: 27 JAN 2022</time></aside><p>These types form the inductive basis of MLTT foundations
and are built-in into type checker.
</p><h1>EMPTY</h1><p>The Empty type represents False-type logical 𝟎, type without inhabitants, Void or ⊥ (Bottom).
As it has not inhabitants it lacks both constructors and eliminators, however, it has induction.</p><p><b>Definition</b> (Empty). Empty-type is defined as built-in 𝟎-type:
$$
    𝟎 : U.
$$
</p><h2>Induction Principle</h2><p><b>Definition</b> (Induction Principle $\mathrm{ind_0}$). 𝟎-type is satisfying the
induction principle:
$$
    \mathrm{ind_0} : \prod_{C\ :\ 𝟎\ \rightarrow\ U} \prod_{z\ :\ 𝟎} C(z).
$$</p><br><code>def Empty-ind (C: 𝟎 → U) (z: 𝟎) : C z := ind₀ (C z) z</code><br><p><b>Definition</b> (Negation or isEmpty). For any type A negation of A is defined as arrow from A to 𝟎:
$$
   \neg A := A \rightarrow 𝟎.
$$</p><code>def isEmpty (A: U): U := A → 𝟎</code><p>The witness of $\neg A$ is obtained by assuming A and deriving a contradiction.
This techniques is called proof of negation and is applicable to any types in constrast
to proof by contradiction which implies $\neg\neg A \rightarrow A$ (double negation elimination) and is
applicable only to decidable types with $\neg A + A$ property.</p><br><h1>UNIT</h1><p>Unit type is the simplest type equipped with full set of MLTT inference rules.
It contains single inhabitant ★ (star).</p><p><b>Definition</b> (Unit). Unit-type is defined as built-in 𝟏-type:
$$
    𝟏 : U.
$$
</p><h2>Constructor</h2><p><b>Definition</b> (Star). 𝟏-type containts single inhabitant ★:
$$
     ★ : 𝟏.
$$
</p><h2>Induction Principle</h2><p><b>Definition</b> (Induction Principle $\mathrm{ind_1}$). 𝟏-type satisfies
induction principle that for any family $C$ indexed by $x : 1$ there is a function
$$
    \mathrm{ind_1} : \prod_{C\ :\ 𝟏\ \rightarrow\ U} \prod_{x\ :\ C(★)} \prod_{z\ :\ 𝟏} C(z).
$$</p><code>def 1-ind (C: 𝟏 → U) (x: C ★) (z: 𝟏) : C z := ind₁ C x z</code><br><h2>Computation</h2><p><b>Theorem</b> (Unit Computes). The following equation holds:
$$
   \mathrm{ind_1}(x,★) = x.
$$
</p><h1>BOOL</h1><p>𝟐 is a logical boolean type or 0-sphere which has two
inhabitants false (or $0_2$) and true (or $1_2$).</p><p><b>Definition</b> (Bool). Boolean-type or 0-sphere is defined as built-in 𝟐-type:
$$
    𝟐 : U.
$$
</p><h2>Constructors</h2><p><b>Definition</b> ($0_2$). false or $0_2$.
$$
     0_2 : 𝟐.
$$</p><p><b>Definition</b> ($1_2$). true or $1_2$.
$$
     1_2 : 𝟐.
$$</p><br><h2>Induction Principle</h2><p><b>Definition</b> (Induction Principle $\mathrm{ind_2}$).
$$
    \mathrm{ind_2} : \prod_{C\ :\ 𝟐\ \rightarrow\ U} \prod_{x\ :\ C(0_2)} \prod_{y\ :\ C(0_1)} \prod_{z\ :\ 𝟐} C(z).
$$</p><code>def 2-ind (C: 𝟐 → U) (x: C 0₂) (y: C 1₂) (z: 𝟐) : C z := ind₂ C x y z</code><br><h1>W</h1><p>Well-founded trees without mutual recursion represented as $\mathrm{W}$-types.</p><p><b>Definition</b> (W). For $A : U$ and $B : A \rightarrow U$, type $\mathrm{W}$
is defined as $\mathrm{W}(A,B) : U$ or
$$
   \mathrm{W}_{(x : A)} B(x) : U.
$$</p><code>def W' (A : U) (B : A → U) : U := W (x : A), B x
</code><h2>Constructor</h2><p>Elements of $\mathrm{W}_{(x : A)} B(x)$ are called trees and created with single $\mathrm{sup}$ constructor:
$$
    \mathrm{sup} : \mathrm{W}_{(x: A)}\ B(x).
$$</p><code>def sup' (A: U) (B: A → U) (x: A) (f: B x → W' A B)
  : W' A B
 := sup A B x f</code><br><h2>Induction Principle</h2><p><b>Definition</b> (Induction Principle $\mathrm{ind^W}$). The induction principle states that
for any types $A: U$ and $B: A \rightarrow U$ and type family $C$ over $\mathrm{W}(A,B)$
and the function $g : G$, where
$$
   G = \prod_{x: A}\prod_{f: B(x) → \mathrm{W}(A,B)}\prod_{b: B(x)} C(f(b)) → C(\mathrm{sup}(x,f))
$$
there is a dependent function:
$$
   \mathrm{ind^W} : \prod_{C: \mathrm{W}(A,B) → U}\prod_{g:G}\prod_{a: A}\prod_{f: B(a) → \mathrm{W}(A,B)}\prod_{b: B(a)}C(f(b)).
$$</p><code>def W-ind (A : U) (B : A → U)
    (C : (W (x : A), B x) → U)
    (g : Π (x : A) (f : B x → (W (x : A), B x)), (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x)) (b : B a) : C (f b) := indᵂ A B C g (f b)
</code><h2>Computation</h2><p><b>Theorem</b> ($\mathrm{ind^W}$ computes). The induction principle $\mathrm{ind^W}$ satisfies
the equation:
$$
    \mathrm{ind^W_\beta} : g(a,f,λb.\mathrm{ind^W}(g,f(b))) = \mathrm{ind^W}(g,\mathrm{sup}(a,f)).
$$</p><code>def indᵂ-β (A : U) (B : A → U)
    (C : (W (x : A), B x) → U) (g : Π (x : A)
    (f : B x → (W (x : A), B x)), (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x))
  : PathP (<_> C (sup A B a f))
          (indᵂ A B C g (sup A B a f))
          (g a f (λ (b : B a), indᵂ A B C g (f b)))
 := <_> g a f (λ (b : B a), indᵂ A B C g (f b))
</code></section></article><link rel="stylesheet" href="https://groupoid.space/main.css?v=44"><footer class="footer"><a href="https://groupoid.space/homotopy/base/"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"></a><span class="footer__copy">2016&mdash;2022 &copy; <a href="https://5ht.co/" style="color:Lavender;">Namdak Tönpa</a></span><script src="https://groupoid.space/highlight.js?v=44"></script></footer>