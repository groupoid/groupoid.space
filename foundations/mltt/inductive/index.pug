doctype html
html
    head
        meta(charset='utf-8')
        meta(http-equiv='x-ua-compatible' content='ie=edge')
        meta(name='viewport'        content='width=device-width, initial-scale=1')
        meta(name='author'          content='Namdak Tonpa')
        meta(name='twitter:site'    content='@5HT')
        meta(name='twitter:creator' content='@5HT')
        meta(property='og:title'       content='INDUCTIVE')
        meta(property='og:description' content='Inductive MLTT Foundations')
        meta(property='og:type'        content='website')
        meta(property='fb:app_id'      content='118554188236439')
        meta(property='og:url'         content='https://groupoid.space/foundations/mltt/inductive/')
        link(rel='stylesheet' href='https://groupoid.space/main.css')
        block title
            title 0,1,2,W
            script(src='https://groupoid.space/styles/mathjax.js?config=TeX-AMS_HTML')
            script.
              window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                             TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                             extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                             "HTML-CSS": { imageFont: null },
                             AuthorInit: function() {
                                 MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                     var TEX = MathJax.InputJax.TeX;
                                     TEX.Definitions.Add({
                                         macros: {
                                           llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                           rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                           llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                           rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                         }
                                     });
                                 });
                             },
                             tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                        processEscapes: true }
                         };
    body.content
        block content
        block vars

block content
    article.main.list
        section
            h1 INDUCTIVE BASIS
            aside
                time Published: 27 JAN 2022
            p.
               These types form the inductive basis of MLTT foundations
               and are built-in into type checker.

            h1 EMPTY
            p.
                The Empty type represents False-type logical ğŸ, type without inhabitants, Void or âŠ¥ (Bottom).
                As it has not inhabitants it lacks both constructors and eliminators, however, it has induction.
            p.
                <b>Definition</b> (Empty). Empty-type is defined as built-in ğŸ-type:
                $$
                    ğŸ : U.
                $$

            h2 Induction Principle
            p.
                <b>Definition</b> (Induction Principle $ind_0$). ğŸ-type is satisfying the
                induction principle:
                $$
                    ind_0 : \prod_{C\ :\ ğŸ\ \rightarrow\ U} \prod_{z\ :\ ğŸ} C(z).
                $$
            br.
            code.
                def Empty-ind (C: ğŸ â†’ U) (z: ğŸ) : C z := indâ‚€ (C z) z
            br.

            p.
                <b>Definition</b> (Negation or isEmpty). For any type A negation of A is defined as arrow from A to ğŸ:
                $$
                   \neg A := A \rightarrow ğŸ.
                $$
            code.
                def isEmpty (A: U): U := A â†’ ğŸ
            p.
                The witness of $\neg A$ is obtained by assuming A and deriving a contradiction.
                This techniques is called proof of negation and is applicable to any types in constrast
                to proof by contradiction which implies $\neg\neg A \rightarrow A$ (double negation elimination) and is
                applicable only to decidable types with $\neg A + A$ property.
            br

            h1 UNIT
            p.
                Unit type is the simplest type equipped with full set of MLTT inference rules.
                It contains single inhabitant â˜… (Star).
            p.
                <b>Definition</b> (Unit). Unit-type is defined as built-in ğŸ-type:
                $$
                    ğŸ : U.
                $$

            h2 Constructor
            p.
                <b>Definition</b> (Star). ğŸ-type containts single inhabitant â˜…:
                $$
                     â˜… : ğŸ.
                $$

            h2 Induction Principle
            p.
                <b>Definition</b> (Induction Principle $ind_1$). ğŸ-type satisfies
                induction principle that for any family $P(x)$ indexed by $x : 1$ there is a function
                $$
                    ind_1 : \prod_{C\ :\ ğŸ\ \rightarrow\ U} \prod_{x\ :\ C(â˜…)} \prod_{z\ :\ ğŸ} C(z).
                $$
            code.
                def 1-ind (C: ğŸ â†’ U) (x: C â˜…) (z: ğŸ) : C z := indâ‚ C x z
            br

            h2 Computation
            p.
                <b>Theorem</b> (Unit Computes). The following equation holds:
                $$
                   ind_1(x,â˜…) = x.
                $$

            h1 BOOL
            p.
                ğŸ is a logical boolean type or 0-sphere which has two
                inhabitants false=0$_2$ and true=1$_2$.
            p.
                <b>Definition</b> (Bool). Boolean-type or 0-sphere is defined as built-in ğŸ-type:
                $$
                    ğŸ : U.
                $$

            h2 Constructors
            p.
                <b>Definition</b> (0$_2$). North=False=0$_2$.
                $$
                     0_2 : ğŸ.
                $$
            p.
                <b>Definition</b> (1$_2$). South=True=1$_2$.
                $$
                     1_2 : ğŸ.
                $$
            br.

            h2 Induction Principle
            p.
                <b>Definition</b> (Induction Principle $ind_2$).
                $$
                    ind_2 : \prod_{C\ :\ ğŸ\ \rightarrow\ U} \prod_{x\ :\ C(0_2)} \prod_{y\ :\ C(0_1)} \prod_{z\ :\ ğŸ} C(z).
                $$
            code.
                def 2-ind (C: ğŸ â†’ U) (x: C 0â‚‚) (y: C 1â‚‚) (z: ğŸ) : C z := indâ‚‚ C x y z
            br

            h1 W
            p.
                Well-founded trees without mutual recursion represented as $W$-types.
                $$
                   W_{x: A}B(x) : U.
                $$
            code.
                def W' (A: U) (B: A â†’ U): U := W (x: A), B x

            h2 Constructor
            p.
                Elements of $W_{A,B}$ are called trees and created with single sup constructor:
                $$
                    sup : W_{x: A}B(x).
                $$
            code.
                def sup' (A: U) (B: A â†’ U) (x: A) (f: B x â†’ W' A B)
                  : W' A B
                 := sup A B x f
            br.

            h2 Induction Principle
            p.
                <b>Definition</b> (Induction Principle $ind^W$). The induction principle states that
                for any type family C over $W_{A,B}$ and the function $g : G$, where
                $$
                   G = \prod_{x: A}\prod_{f: B(x) â†’ W_{A,B}}\prod_{b: B(x)} C(f(b)) â†’ C(sup(x,f))
                $$
                there is a dependent function:
                $$
                   ind^W : \prod_{A : U}\prod_{B: A â†’ U}\prod_{C: W â†’ U}\prod_{x: A}\prod_{g:G}\prod_{a: A}\prod_{f: B(a) â†’ W_{A,B}}\prod_{b: B(a)}C(f(b)).
                $$
            code.
                def W-ind (A : U) (B : A â†’ U)
                    (C : (W (x : A), B x) â†’ U)
                    (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)), (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
                    (a : A) (f : B a â†’ (W (x : A), B x)) (b : B a) : C (f b) := indáµ‚ A B C g (f b)

            h2 Computation
            p.
                <b>Theorem</b> ($ind^W$ computes). The induction principle $ind^W$ satisfies
                the equation:
                $$
                    ind^W_\beta : ind^W(g,sup(a,f)) = g(a,f,Î»b.ind^W(g,f(b))).
                $$
            code.
                def indáµ‚-Î² (A : U) (B : A â†’ U)
                    (C : (W (x : A), B x) â†’ U) (g : Î  (x : A)
                    (f : B x â†’ (W (x : A), B x)), (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
                    (a : A) (f : B a â†’ (W (x : A), B x))
                  : PathP (<_> C (sup A B a f))
                          (indáµ‚ A B C g (sup A B a f))
                          (g a f (Î» (b : B a), indáµ‚ A B C g (f b)))
                 := <_> g a f (Î» (b : B a), indáµ‚ A B C g (f b))

    include ../../../footer.pug