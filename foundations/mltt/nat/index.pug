doctype html
html
    head
        meta(charset='utf-8')
        meta(http-equiv='x-ua-compatible' content='ie=edge')
        meta(name='viewport'        content='width=device-width, initial-scale=1')
        meta(name='author'          content='Namdak Tonpa')
        meta(name='twitter:site'    content='@5HT')
        meta(name='twitter:creator' content='@5HT')
        meta(property='og:title'       content='NAT')
        meta(property='og:description' content='Natural Numbers')
        meta(property='og:type'        content='website')
        meta(property='fb:app_id'      content='118554188236439')
        meta(property='og:url'         content='https://groupoid.space/foundations/mltt/nat/')
        link(rel='stylesheet' href='https://groupoid.space/main.css')
        block title
            title NAT
            script(src='https://groupoid.space/styles/mathjax.js?config=TeX-AMS_HTML')
            script.
              window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                             TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                             extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                             "HTML-CSS": { imageFont: null },
                             AuthorInit: function() {
                                 MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                     var TEX = MathJax.InputJax.TeX;
                                     TEX.Definitions.Add({
                                         macros: {
                                           llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                           rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                           llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                           rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                         }
                                     });
                                 });
                             },
                             tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                        processEscapes: true }
                         };
    body.content
        block content
        block vars

block content
    article.main.list
        .om
            section
                h1 NATURAL NUMBERS
                aside
                    time Published: 29 JAN 2022
                p.
                    Pointed Unary System is a category $Nat$ with the terminal object and a
                    carrier nat having morphism $[zero: 1 â†’ Nat, succ: Nat â†’ Nat]$.
                    The initial object of $Nat$ is called Natural Number Object and models
                    Peano axiom set.
                p.
                    In type theory $â„•$ type could be expressed as
                    $$
                      â„•^W = W_{(x:2)},\ rec_2(U, 0, 1, x).
                    $$
                code.
                    def â„• := W (x : ðŸ), indâ‚‚ (Î» (_ : ðŸ), U) ðŸŽ ðŸ x
                    def â„•-ctor := indâ‚‚ (Î» (_ : ðŸ), U) ðŸŽ ðŸ

                h2 Constructors
                p.
                    Type $â„•$ provides two way of creating numbers: by $zero$ and $succ$ constructors.
                code.
                    def zero : â„• := sup ðŸ â„•-ctor 0â‚‚ (indâ‚€ â„•)
                    def succ (n : â„•) : â„• := sup ðŸ â„•-ctor 1â‚‚ (Î» (x : ðŸ), n)

                h2 Eliminators
                p.
                    The induction principle is derivable in CCHM with W-types:
                    $$
                       ind^â„• = ind^W(2,rec^2(U,0,1),C,ind^2(x,y,z)).
                    $$
                code.
                    def â„•-ind (C : â„• â†’ U) (z : C zero)
                        (s : Î  (n : â„•), C n â†’ C (succ n)) : Î  (n : â„•), C n
                     := indáµ‚ ðŸ â„•-ctor C
                             (indâ‚‚ (Î» (x : ðŸ), Î  (f : â„•-ctor x â†’ â„•),
                                      (Î  (b : â„•-ctor x), C (f b)) â†’ C (sup ðŸ â„•-ctor x f))
                                   (Î» (f : ðŸŽ â†’ â„•) (g : Î  (x : ðŸŽ), C (f x)), ðŸŽâŸ¶â„• C f z)
                                   (Î» (f : ðŸ â†’ â„•) (g : Î  (x : ðŸ), C (f x)), ðŸâŸ¶â„• C f (s (f â˜…) (g â˜…))))

                p.
                    Non-dependent versions:
                code.
                    def â„•-rec (C : U) (z : C) (s : â„• â†’ C â†’ C) : â„• â†’ C := â„•-ind (Î» (_ : â„•), C) z s
                    def â„•-iter (C : U) (z : C) (s : C â†’ C) : â„• â†’ C := â„•-rec C z (Î» (_ : â„•), s)
                    def â„•-case (C : U) (z s : C) : â„• â†’ C := â„•-iter C z (Î» (_ : C), s)

            section
                h2 Transformations
                p.
                code.
                    def plus : â„• â†’ â„• â†’ â„•
                     := â„•-iter (â„• â†’ â„•) (idfun â„•) (âˆ˜ â„• â„• â„• succ)

                    def mult : â„• â†’ â„• â†’ â„•
                     := â„•-rec (â„• â†’ â„•) (Î» (_: â„•), zero)
                              (Î» (_: â„•) (x: â„• â†’ â„•) (m: â„•), plus m (x m))

            section
                h2 Theorems
                p.
                code.
                    def add_zero (n : â„•) : Path â„• (add zero n) n
                    def add_suc (a : â„•) (n : â„•) : Path â„• (add (suc a) n) (suc (add a n))
                    def add_comm (a : â„•) (n : â„•) : Path â„• (add a n) (add n a)
                    def assocAdd (a b : â„•) (c : â„•) : Path â„• (add a (add b c)) (add (add a b) c)
                    def sucInj (n m : â„•) (p : Path â„• (suc n) (suc m)) : Path â„• n m
                    def add_comm3 (a b c : nat) : Path â„• (add a (add b c)) (add c (add b a))
                    def caseNat (A : U) (z s : A) : â„• -> A
                    def natDec (n m : â„•) : dec (Path â„• n m)
                    def natSet : isSet â„•

    include ../../../footer.pug
