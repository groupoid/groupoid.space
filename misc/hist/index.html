<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:title" content="GROUPOЇD"><meta property="og:description" content="Formalization of Mathematics"><link rel="stylesheet" href="https://groupoid.space/main.css?v=31"><title>HIST</title></head><body class="content"><header class="header"><div class="header__titles"><h1 class="header__title">Intro</h1><h4 class="header__subtitle">History of Math Provers</h4></div></header><article class="main"><div class="om"><section></section><h1>Abstract</h1></div><aside>Maxim Sokhatsky<time>15 FEB 16</time></aside><div class="intro"><section></section><h2 id="fpga">LISP as Extraction Target</h2><p>Originally, utyped lambda calculus was discovered as an inner language of the space
(Curry, Church, 1932). This language was called LISP (McCarthy, 1958),
and it was based on cons, nil, eq, atom, car, cdr, lambda, apply, and id.
These are parts of inductive types lately known as inductive type constructors.
Today untyped lambda calculus is still used as an extraction target for many
provers (Idris, F*), and in different domain languages (JavaScript, Erlang).
</p><h2 id="auto">AUTOMATH</h2><p>The first computer-assisted prover AUTOMATH was devised by Nicolaas Govert de Bruijn starting in 1967.
Type theory beneath AUTOMATH is typed lambda calculus. AUTOMATH was the first
prover based on Curry–Howard correspondence.
</p><h2 id="fpga">ML/LCF</h2><p>Further teardown of inner space language was the ML programming language, founded merely on algebraic
datatypes and algebra on higher terms rather than categorical semantic. Lately, it
was fixed with categorical methods in CPL (Hagino, 1987) and Charity (Cockett, 1992).
Assisted by Morris and Newey, Milner designed Meta Language for the purpose of building LCF
in early 70-s. LCF was a predecessor family of automated math provers: HOL88,
HOL90, HOL98, and HOL/Isabelle which is now built using Poly/ML.
</p><h2 id="other">Fully Automated Provers</h2><p>Other automated math systems appeared during 80-90s:
Mizar (Trybulec, 1989), PVS (Owre, Rushby, Shankar, 1995),
ACL2 (Boyer, Kaufmann, Moore, 1996), and Otter (McCune, 1996).
</p><h2 id="mltt">MLTT</h2><p>Modern provers (based on consistent Martin-Löf Type Theory, 1972)
like Agda, Coq, Lean, F*, and Idris are based on Barendregt
and Coquand CoC with different flavors of infinity universe hierarchies
and Calculus of Inductive Constructions. Some of them are automated and some
are trying to also be general purpose programming languages with proving facilities,
like Idris, Coq (coq.io), Agda (M-Alonso).
</p><h2 id="cubical">Cubical Type Theory</h2><p>Further extensions of MLTT theory is Homotopy Types. It is necessary
for reasoning about abstract shapes and multidimentional path types.
The Cubical approach was chosen in favour of Globular and Simplical
due to computability of Voevodsky's univalence axiom.
</p><h2 id="inf">Infinity Language</h2><p><mark>From PTS to HTS</mark>. We want to have flexible and detachable
layers on top of PTS core. Then Sigma for proving.
Then well-founded trees or polynomial functors as known as data and record.
Then higher path types, interval arithmetic, glue and comp for HIT.
Layers are based on different math areas, the only common is
the method &mdash; category theory.</p><p><mark>Extensible Language Design.</mark> Encoding of inductive types is based on categorical semantic
of compilation to CoC. All other syntax constructions are inductive definitions plugged
into the stream parser. AST of the CoC language is also defined in terms of inductive
constructions and thus allowed in the macros. The language of polynomial functors (data
and record) and core language of the process calculus (spawn, receive, and send) are just
a macrosystem over the CoC language, its syntax extensions.</p><p><mark>Changable Encodings.</mark> In pure CoC we have only arrows, so all inductive type encodings
would be Church-encoding variations. Most extended nowadays is Church-Boehm-Berrarducci
encoding dedicated to inductive types. Another well known are Scott (laziness),
Parigot (laziness and constant-time iterators), and CPS (continuations) encodings.</p><p><mark>Proved Categorical Semantic.</mark> There was built a math model (using higher-order
categorical logic) of encoding, which calculates (co)limits in a category of (co)algebras
built with given set of (de)constructors. We call such encoding in honor of Lambek lemma
that leads us to the equality of (co)initial object and (co)limit in the categories
of (co)algebras. Such encoding works with dependent types and its consistency is proved
in Lean model.</p></div></article><footer class="footer"><a href="https://github.com/groupoid/"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"></a><span class="footer__copy">2016&mdash;2021 &copy; <a href="//5ht.co/" style="color:Lavender;">Максим Сохацький</a></span></footer><script src="https://groupoid.space/bundle.js?v=7"></script><script src="https://groupoid.space/highlight.js?v=13"></script></body></html>