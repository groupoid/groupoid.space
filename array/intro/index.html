<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta name="twitter:image" content="https://groupoid.space/card2.png"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="https://groupoid.space/card2.png"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:description" content="MLTT Language with Extensions"><link rel="stylesheet" href="https://groupoid.space/main.css?v=7"><title>Stream Calculus</title></head><body class="content"><header class="header"><a href="//groupoid.space/"><img class="header__logo" src="//groupoid.space/groupoid.svg"/></a><div class="header__titles"><h1 class="header__title">Stream Calculus</h1><h4 class="header__subtitle">Parallel Array Processing</h4></div></header><article class="main"><div class="exe"><section><p>Pi calculus can be transformed from lambda
calculus by replacing a variable constructor with stream constructor.
But the language and protocol accessing this stream could vary
from backend to backend with respect to design requirements.</p><p>Stream calculus provides different disciplines for accessing
underlying streams used in Pi calculus. For example: 1) linear types, or streams with
constant direction without rollbacks where each element of stream is touched once;
2) random access arrays; 3) GPU sources; 4) runtime typed channels;
5) effect and coeffect streams (processes as streams). Such stream
calculuses could be landed with such GPU languages as Futhark
or AVX intrinsics languages, such as Julia. We could treat
stream calculus as memory representation with different protocol accesses.</p><p>One type of disciplines is a stream calculus. While pi calculus could be imagined as
lambda calculus where function arguments are channels or streams, stream calculus defines set
of constructions over these streams. This calculus is needed to provide different forms
of vectorization that can be used on GPU and AVX hardware.
</p></section><section class="langf"><div class="langf__col"><h2 id="syntax">Language Axioms</h2><code>Inductive StreamCalculus :=
 | Map                | Fold
 | Scan               | Iota
 | SLoop              | Transpose
 | Rotate             | SSplit
 | Concat             | Zip
 | Reduce             | StreamMap          
 | StreamMapPer       | StreamRed
 | StreamSeq          | Partition
 | Reshape            | Shape
 | Rearrange          | Copy
 | For                | While.

</code></div></section><section><h1>Calculus</h1><p></p><code></code></section></div></article><footer class="footer"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"><span class="footer__copy">2016&mdash;2017 &copy; <a href="//groupoid.space/team.html" style="color:white;">Groupoid Infinity</a></span></footer><script src="https://groupoid.space/bundle.js"></script><script src="https://groupoid.space/highlight.js"></script></body></html>