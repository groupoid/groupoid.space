<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:title" content="GROUPOЇD"><meta property="og:description" content="Formalization of Mathematics"><link rel="stylesheet" href="https://groupoid.space/main.css?v=31"><title>IP</title></head><body class="content"><header class="header"><div class="header__titles"><h1 class="header__title">Intercore Protocol</h1><h4 class="header__subtitle">The (A)SMP Scheduler, CAS Queues and CPS Tasks</h4></div></header><article class="main"><div class="om"><section><h1>Article</h1></section></div><aside>Maxim Sokhatsky<time>31 DEC 16</time></aside><section></section><h2 id="Abstract">Low Latency Transport</h2><p>The InterCore bus is constructed of a number of SPMC queues per core. The bus itself
has a star topology between cores, and MPSC is organized as a computable function
over a set of publisher queues. Each core has exatcly one publisher queue.</p><p>The InterCore protocol handler is called <b>poll_bus</b> and is a member of
each <b>Scheduler</b>. You may think of InterCore as a teleport transport between
processors since <b>poll_bus</b> is being fired on every yield to scheduler, and
if any core has a message addressed to you since the last yield on your
core, then your core will execute the handler on this message before the next task.
</p><h2 id="Publisher">Publisher [capacity]</h2><p><b>pub</b> creates new publisher CAS cursor for writing.
Returns system-wide cursor Id.</p><code>o) p: pub[16]
</code><h2 id="Subscriber">Subscribe [publisher]</h2><p><b>sub</b> creates new subscriber CAS cursor based on a given writer cursor.
Returns system-wide cursor Id for reading.</p><code>o) s: sub[p]
</code><h2 id="Spawn">Spawn [core program cursors]</h2><p><b>spawn</b> creates a new Task on a given core. The Task could be O program
or any LLVM code with compatible FFI. Also, you should specify the ownership
list of cursors that are exclusively available to that Task.</p><code>o) spawn [0 "etc/proc0" (0;1)]
</code><h2 id="Send">Send [writer data]</h2><p><b>snd</b> sends particular data to a given writer cursor. Returns nil if OK.</p><code>o) snd[p;42]
</code><h2 id="Receive">Receive [reader]</h2><p><b>rcv</b> returns data from the given reader cursor.
If none then yields to scheduler for another task.</p><code>o) rcv[s]</code></article><footer class="footer"><a href="https://github.com/groupoid/"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"></a><span class="footer__copy">2016&mdash;2021 &copy; <a href="//5ht.co/" style="color:Lavender;">Максим Сохацький</a></span></footer><script src="https://groupoid.space/bundle.js?v=7"></script><script src="https://groupoid.space/highlight.js?v=20"></script></body></html>