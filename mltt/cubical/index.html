<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="//groupoid.space/grp.png"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="//groupoid.space"><meta property="og:description" content="Infinity Language"><link rel="stylesheet" href="//groupoid.space/main.css"><title>PATH ISO</title><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>MathJax.Hub.Config({ displayAlign: "left", tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true } });
</script></head><body class="content"><header class="header"><a href="//groupoid.space/"><img class="header__logo" src="//groupoid.space/groupoid.svg"/></a><div class="header__titles"><h1 class="header__title">Path Isomorphism</h1><h4 class="header__subtitle">Connecting two data types</h4></div></header><article class="main"><div class="om"><section><h1>Rant</h1><h2 id="nat">Background</h2><p>Just got a <b>cubical</b> type checker from Mortberg et all,
and the first thing I wanted to try was a connecting
two different values of two different types. As you may know,
the core thing of Type Theory is equality or isomorphism
or equivalence (which is the same thing but in different
universes: 0, 1, 2, ...). Despite cubical is U : U this task is possible here.</p><p>So I will try with simple comparing two nat types.</p><code>$ cat isoPath.ctt
data nat = zero | suc (n : nat)
data nat2 = zero2 | suc2 (n : nat2)

$ cubical isoPath.ctt
> nat
EVAL: nat
> nat2
EVAL: nat2</code><p>In MLTT propositional equality reflects it in some sense
definitional which is usually built into typechecker and.
Everything that involves normalized term comparing takes
its root from definitional equality.</p><p>The groupoid model gives us ∞-dimentional equality and also
denies the uniqueness of identity proofs. That means we can build
paths between objects in many ways inside and the space of
terms is ∞-groupoid:</p><code>Path     (A : U) : U = (a b : A) -> PathP (&lt;i&gt; A) a b
prop     (A : U) : U = (a b : A) -> Path A a b
set      (A : U) : U = (a b : A) -> prop     (Path A a b)
groupoid (A : U) : U = (a b : A) -> set      (Path A a b)
gr_2     (A : U) : U = (a b : A) -> groupoid (Path A a b)
gr_3     (A : U) : U = (a b : A) -> gr_2     (Path A a b)</code><p>To model other types of equalities, we need to design
its properties. The desired property, in general,
is to compare incomparable things (heterogenous equality):
namely two different points of two different types.
The cubical built-in <b>PathP</b> type is exactly such equality.
It connects different points of space with the function defined
on I interval [0..1] that is smooth between values at interval edges.</p><h2 id="nat">Path between Elements</h2><p>So let us be clear, we want to compare two points of A and B
types which both live un U. On the high level, we will use
<b>Path U A B</b>. which is homogenous on U. At the low level we
will use heterogenous <b>PathP (Path U A B) a b</b>:</p><code>PathTypes (A B: U) : U = PathP (&lt;i&gt; U) A B
PathElem  (A B: U) (a: A) (b: B) (P: PathTypes A B) : U = PathP P a b</code><p>Let us try to build proof-term:</p><code>PathElem nat2 nat zero2 zero nat2nat</code><h2 id="nat">Path Isomorphism</h2><p>But how to construct elements of <b>Path U nat2 nat</b> ?</p><code>nat2nat : Path U nat2 nat = isoPath nat2 nat toNat fromNat fromNatK toNatK</code><p>There is already inside cubical an isoPath. The proof-term
of isoPath implemented using glueing of types and composition
primitives of type checker inside isoToEquiv lemma.</p><div class="semantics"><figure>$$Iso(A,B) = \sum_{f:A\rightarrow B}\sum_{g:B\rightarrow A}\Biggl(\prod_{x:A} Id_A(gfx,x)) \times \prod_{y:B} Id_B(fgy,y)\Biggr)$$</figure></div><code>isContr (A : U) : U = (x : A) * ((y : A) -> Path A x y)
fiber (A B : U) (f : A -> B) (y : B) : U = (x : A) * Path B y (f x)
isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)
contrSingl (A : U) (a b : A) (p : Path A a b) :
    Path (singl A a) (a,refl A a) (b,p) = &lt;i&gt; (p @ i,&lt;j&gt; p @ i/\j)</code><code>isoPath (A B : U) (f : A -> B) (g : B -> A)
        (s : (y : B) -> Path B (f (g y)) y)
        (t : (x : A) -> Path A (g (f x)) x) : Path U A B =
        &lt;i&gt; Glue B [ (i = 0) -> (A,f,isoToEquiv A B f g s t),
                     (i = 1) -> (B,idfun B,idIsEquiv B) ]</code><code>isoToEquiv (A B : U) (f : A -> B) (g : B -> A)
           (s : (y : B) -> Path B (f (g y)) y)
           (t : (x : A) -> Path A (g (f x)) x) : isEquiv A B f =
    \(y:B) -> ((g y,&lt;i&gt;s y@-i),\ (z:fiber A B f y) ->
           lemIso A B f g s t y (g y) z.1 (&lt;i&gt;s y@-i) z.2)</code><code>idIsEquiv (A : U) : isEquiv A A (idfun A) =
     \(a : A) -> ((a, refl A a),\(z : fiber A A (idfun A) a) ->
     contrSingl A a z.1 z.2)</code><code>lemIso (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x)
       (y : B) (x0 x1 : A) (p0 : Path B y (f x0)) (p1 : Path B y (f x1)) :
       Path (fiber A B f y) (x0,p0) (x1,p1) = &lt;i&gt; (p @ i,sq1 @ i)
where
    rem0  : Path A (g y) x0 = &lt;i&gt; comp (&lt;k&gt; A) (g (p0 @ i)) [ (i = 1) -> t x0, (i = 0) -> &lt;k&gt; g y ]
    rem1  : Path A (g y) x1 = &lt;i&gt; comp (&lt;k&gt; A) (g (p1 @ i)) [ (i = 1) -> t x1, (i = 0) -> &lt;k&gt; g y ]
    p     : Path A x0 x1 = &lt;i&gt; comp (&lt;k&gt; A) (g y) [ (i = 0) -> rem0, (i = 1) -> rem1 ]
    fill0 : Square A (g y) (g (f x0)) (g y) x0
            (&lt;i&gt; g (p0 @ i)) rem0 (&lt;i&gt; g y) (t x0)  =
             &lt;i j&gt; comp (&lt;k&gt; A) (g (p0 @ i)) [ (i = 1) -> &lt;k&gt; t x0 @ j /\ k,
                                               (i = 0) -> &lt;k&gt; g y,
                                               (j = 0) -> &lt;k&gt; g (p0 @ i) ]
    fill1 : Square A (g y) (g (f x1)) (g y) x1
           (&lt;i&gt; g (p1 @ i)) rem1 (&lt;i&gt; g y) (t x1) =
            &lt;i j&gt; comp (&lt;k&gt; A) (g (p1 @ i)) [ (i = 1) -> &lt;k&gt; t x1 @ j /\ k,
                                              (i = 0) -> &lt;k&gt; g y,
                                              (j = 0) -> &lt;k&gt; g (p1 @ i) ]
    fill2 : Square A (g y) (g y) x0 x1
            (&lt;k&gt; g y) p rem0 rem1 =
             &lt;i j&gt; comp (&lt;k&gt; A) (g y) [ (i = 0) -> &lt;k&gt; rem0 @ j /\ k,
                                        (i = 1) -> &lt;k&gt; rem1 @ j /\ k,
                                        (j = 0) -> &lt;k&gt; g y ]

    sq : Square A (g y) (g y) (g (f x0)) (g (f x1))
         (&lt;i&gt; g y) (&lt;i&gt; g (f (p @ i)))
         (&lt;j&gt; g (p0 @ j)) (&lt;j&gt; g (p1 @ j)) =
          &lt;i j&gt; comp (&lt;k&gt; A) (fill2 @ i @ j) [ (i = 0) -> &lt;k&gt; fill0 @ j @ -k,
                                               (i = 1) -> &lt;k&gt; fill1 @ j @ -k,
                                               (j = 0) -> &lt;k&gt; g y,
                                               (j = 1) -> &lt;k&gt; t (p @ i) @ -k ]

    sq1 : Square B y y (f x0) (f x1)
          (&lt;k&gt;y) (&lt;i&gt; f (p @ i)) p0 p1 =
           &lt;i j&gt; comp (&lt;k&gt; B) (f (sq @ i @j)) [ (i = 0) -> s (p0 @ j),
                                                (i = 1) -> s (p1 @ j),
                                                (j = 1) -> s (f (p @ i)),
                                                (j = 0) -> s y ]</code><p>Now we need to pass maps f and g:</p><code>toNat : nat2 -> nat = split
    zero2 -> zero
    suc2 n -> suc (toNat n)

fromNat : nat -> nat2 = split
    zero -> zero2
    suc n -> suc2 (fromNat n)

toNatK : (n : nat2) -> Path nat2 (fromNat (toNat n)) n = split
    zero2 -> <_> zero2
    suc2 n -> &lt;i&gt; suc2 (toNatK n @ i)

fromNatK : (n : nat) -> Path nat (toNat (fromNat n)) n = split
    zero -> <_> zero
    suc n -> &lt;i&gt; suc (fromNatK n @ i)</code><p>Now let's see what we have built:</p><code>> PathElem nat2 nat zero2 zero nat2nat</code><pre>EVAL: PathP (<!0> Glue nat [ (!0 = 0) -> (nat2,(toNat,(\(y : B)
-> ((g y,&lt;i&gt; (s y) @ -i),\(z : fiber A B f y) -> lemIso A B f g
s t y (g y) z.1 (&lt;i&gt; (s y) @ -i) z.2)) (A = nat2, B = nat, f =
toNat, g = fromNat, s = fromNatK, t = toNatK))), (!0 = 1) ->
(nat,((\(a : A) -> a) (A = nat),(\(a : A) -> ((a,refl A a),\(z:
fiber A A (idfun A) a) -> contrSingl A a z.1 z.2)) (A = nat)))])
zero2 zero</pre><p>And its normalized version:</p><code>> :n PathElem nat2 nat zero2 zero nat2nat</code><pre>NORMEVAL: PathP (<!0> Glue nat [ (!0 = 0) -> (nat2,(toNat,\(y
: nat) -> ((fromNat y,<!0> fromNatK y @ -!0),\(z : Sigma nat2
(\(x : nat2) -> PathP (<!0> nat) y (toNat x))) -> <!0> (comp
(<!1> nat2) (fromNat y) [ (!0 = 0) -> <!1> comp (<!2> nat2)
(fromNat (fromNatK y @ -!1)) [ (!1 = 0) -> <!2> fromNat y,
(!1 = 1) -> <!2> toNatK (fromNat y) @ !2 ], (!0 = 1) -> <!1>
comp (<!2> nat2) (fromNat (z.2 @ !1)) [ (!1 = 0) -> <!2> fromNat y,
(!1 = 1) -> <!2> toNatK z.1 @ !2 ] ],<!1> comp (<!2> nat)
(toNat (comp (<!2> nat2) (comp (<!2> nat2) (fromNat y) [(!0 = 0)
-> <!2> comp (<!3> nat2) (fromNat (fromNatK y @ (-!1 \/ -!2)))
[ (!1 = 0) -> <!3> fromNat y, (!1 = 1)(!2 = 1) -> <!3> toNatK
(fromNat y) @ !3, (!2 = 0) -> <!3> fromNat y ], (!0 = 1) -> <!2>
comp (<!3> nat2) (fromNat (z.2 @ (!1 /\ !2))) [ (!1 = 0) -> <!3>
fromNat y, (!1 = 1)(!2 = 1) -> <!3> toNatK z.1 @ !3, (!2 = 0) ->
<!3> fromNat y ], (!1 = 0) -> <!2> fromNat y ]) [ (!0 = 0) -> <!2>
comp (<!3> nat2) (fromNat (fromNatK y @ -!1)) [ (!1 = 0) -> <!3>
fromNat y, (!1 = 1) -> <!3> toNatK (fromNat y) @ (-!2 /\ !3),
(!2 = 1) -> <!3> fromNat (fromNatK y @ -!1) ], (!0 = 1) -> <!2>
comp (<!3> nat2) (fromNat (z.2 @ !1)) [ (!1 = 0) -> <!3> fromNat
y, (!1 = 1) -> <!3> toNatK z.1 @ (-!2 /\ !3), (!2 = 1) -> <!3>
fromNat (z.2 @ !1) ], (!1 = 0) -> <!2> fromNat y, (!1 = 1) ->
<!2> toNatK (comp (<!1> nat2) (fromNat y) [ (!0 = 0) -> <!1>
comp (<!2> nat2) (fromNat (fromNatK y @ -!1)) [ (!1 = 0) ->
<!2> fromNat y, (!1 = 1) -> <!2> toNatK (fromNat y) @ !2 ],
(!0 = 1) -> <!1> comp (<!2> nat2) (fromNat (z.2 @ !1)) [ (!1 = 0)
-> <!2> fromNat y, (!1 = 1) -> <!2> toNatK z.1 @ !2 ] ]) @ -!2 ]))
[ (!0 = 0) -> <!2> fromNatK (fromNatK y @ -!1) @ !2, (!0 = 1) ->
<!2> fromNatK (z.2 @ !1) @ !2, (!1 = 0) -> <!2> fromNatK y @ !2,
(!1 = 1) -> <!2> fromNatK (toNat (comp (<!1> nat2) (fromNat y)
[ (!0 = 0) -> <!1> comp (<!2> nat2) (fromNat (fromNatK y @ -!1))
[ (!1 = 0) -> <!2> fromNat y, (!1 = 1) -> <!2> toNatK (fromNat y)
@ !2 ], (!0 = 1) -> <!1> comp (<!2> nat2) (fromNat (z.2 @ !1))
[ (!1 = 0) -> <!2> fromNat y, (!1 = 1) -> <!2> toNatK z.1 @ !2 ] ]))
@ !2 ])))), (!0 = 1) -> (nat,(\(a : nat) -> a,\(a : nat) -> ((a,<!0> a),
\(z : Sigma nat (\(x : nat) -> PathP (<!0> nat) a x)) -> <!0>
(z.2 @ !0,<!1> z.2 @ (!0 /\ !1))))) ]) zero2 zero</pre></section></div></article><footer class="footer"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"><span class="footer__copy">2016&mdash;2017 &copy; Groupoid Infinity</span></footer><script src="//groupoid.space/bundle.js"></script><script src="//groupoid.space/highlight.js"></script></body></html>