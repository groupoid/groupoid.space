<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:title" content="GROUPOЇD"><meta property="og:description" content="Formalization of Mathematics"><link rel="stylesheet" href="https://groupoid.space/main.css?v=31"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>MathJax.Hub.Config({
   tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true },
   jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
   TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
   extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
   "HTML-CSS": { imageFont: null },
});</script><title>PRELUDE</title></head><body class="content"><header class="header"><div class="header__titles"><h1 class="header__title">Formal Mathematics</h1><h4 class="header__subtitle">The Cubical Base Library</h4></div></header><article class="main"><div class="om"><section><h1>Abstract</h1></section><aside>Максим Сохацький<br><03-08-2018></03-08-2018></aside><p>The cubical base library is dedicated to type checkers with cubical syntax, based on
interval $[0,1]$ with functional extensionality, higher equalities, and higher
inductive types on top of MLTT as a core.
Please refer to <a href="http://www.cse.chalmers.se/~coquand/cubicaltt.pdf">CCHM</a>
paper for more information. The base library is founded on top of cubical modules each
falling into one of 15 categories:</p><p>(i) MLTT Types:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/pi.ctt">pi</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/sigma.ctt">sigma</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/path.ctt">path</a>;
(ii) Set Theory:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/prop.ctt">prop</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/set.ctt">set</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/ordinal.ctt">ordinal</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/hedberg.ctt">hedberg</a>;
(iii) Run-Time Inductive Types:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/proto.ctt">proto</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/maybe.ctt">maybe</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/bool.ctt">bool</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/nat.ctt">nat</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/list.ctt">list</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/stream.ctt">stream</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/vector.ctt">vector</a>;
(iv) Abstract Algebra:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/algebra.ctt">algebra</a>;
(v) Control Structures:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/control.ctt">control</a>;
(vi) Recursion Schemes:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/recursion.ctt">recursion</a>;
(vii) Univalent Foundations:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/equiv.ctt">equiv</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/retract.ctt">retract</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/iso.ctt">iso</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/iso_pi.ctt">iso_pi</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/iso_sigma.ctt">iso_sigma</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/univ.ctt">univ</a>;
(viii) Higher Inductive Types:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/interval.ctt">interval</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/real.ctt">interval</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/s1.ctt">s1</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/s2.ctt">s2</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/pullback.ctt">pullback</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/pushout.ctt">pushout</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/suspension.ctt">suspension</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/quotient.ctt">quotient</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/trunc.ctt">trunc</a>;
(ix) Process Calculus:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/process.ctt">process</a>;
(x) Category Theory:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/cat.ctt">cat</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/fun.ctt">fun</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/sip.ctt">sip</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/adj.ctt">adj</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/ump.ctt">ump</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/cones.ctt">cones</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/topos.ctt">topos</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/category.ctt">category</a>;
(xi) Contextual Categories:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/cwf.ctt">cwf</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/csystem.ctt">csystem</a>;
(xii) Languages:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/mltt.ctt">mltt</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/infinity.ctt">infinity</a>;
(xiii) Algebraic Geometry:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/pointed.ctt">pointed</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/euler.ctt">euler</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/seq.ctt">seq</a>,
    <a href="https://raw.githubusercontent.com/groupoid/hopf/master/src/hopf.ctt">hopf</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/cw.ctt">cw</a>;
(xiv) Cartan Geometry in Cohesive Topos:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/infinitesimal.ctt">infinitesimal</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/etale.ctt">etale</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/manifold.ctt">manifold</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/bundle.ctt">bundle</a>;
(xv) K-Theory:
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/k_theory.ctt">k_theory</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/swaptrans.ctt">swaptrans</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/bishop.ctt">bishop</a>,
    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/subtype.ctt">subtype</a>;</p><p>This library is best to read with <a href="http://5ht.co/hott.pdf">HoTT</a>
book and <a href="https://ncatlab.org/schreiber/show/thesis+Wellen">Felix Wellen</a> dissertation.</p><br></div><div class="om"><section><h1>Martin-Löf Type Theory</h1></section></div><section><p>Martin-Löf Type Theory contains Pi, Sigma, Id, Nat, List types.
Id types were added in 1984 while original MLTT was introduced in 1972.
Now Id types are treated as heterogeneous Path interval types.
</p><h2 id="pi"><a name='pi'><a href='../core/pi/'>Pi</a></a></h2><p>Pi is a space of sections $f: (x:A) \rightarrow B(x)$.</p><code>Pi (A: U) (P: A -> U): U</code><br><code>id (A: U): U = A -> A
idfun (A: U) (a: A): A = a
const (A B: U): U = A
lam (A: U) (B: A -> U) (x: A) (b: B(x)): A -> B(x) = \(x: A) -> b
app (A: U) (B: A -> U) (x: A) (f: A -> B(x)): B(x) = f(x)
lambda (A B: U) (b: B): A -> B = \(_:A) -> b
apply (A B: U) (f: A -> B) (x: A): B = f(x)
O (F G: U -> U) (t: U): U = F (G t)
ot (A B C: U): U = (B -> C) -> (A -> B) -> (A -> C)
o (A B C: U): ot A B C = \(f:B->C)(g:A->B)(x:A) -> f(g x)</code><br><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    1.5 Product types; and
    2.9 Pi-types and the function extensionality axiom</p><code>piExt  (A: U) (B: A -> U)
       (f g: (x:A) -> B x)
       (p: (x:A) -> Path (B x) (f x) (g x))
     : Path ((y:A) -> B y) f g
     = &lt;i&gt; \(a: A) -> (p a) @ i

funExt (A B: U) (f g: A -> B)
       (p: (x:A) -> Path B (f x) (g x))
     : Path (A -> B) f g
     = &lt;i&gt; \(a: A) -> p a @ i
</code><h2 id="sigma"><a name='exists'><a href='../core/sigma/'>Sigma</a></a></h2><p>Sigma is a total space of fibration $p: (x:A) * B(x)$.</p><code>Sigma (A: U) (B: A -> U): U</code><br><code>dpair (A: U) (B: A -> U) (a: A) (b: B a): Sigma A B
pi1 (A: U) (B: A -> U) (x: Sigma A B): A
pi2 (A: U) (B: A -> U) (x: Sigma A B): B (pi1 A B x)</code><br><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    1.6 Dependent pair types (Sigma-types); and
    2.7 Sigma-types.</p><code>sigmaRec (A: U) (B: A -> U) (C: U)
         (g: (x:A) -> B(x) -> C)
         (p: Sigma A B): C = g p.1 p.2

sigmaInd (A: U) (B: A -> U) (C: Sigma A B -> U)
         (g: (a:A)(b:B(a)) -> C (a,b))
         (p: Sigma A B): C p = g p.1 p.2

axiomChoice (A B: U) (R: A->B -> U):
     (p: (x:A)->(y:B)*(R x y)) -> (f:A->B)*((x:A)->R(x)(f x))
  = \(g: (x:A)->(y:B)*(R x y)) -> (\(i:A)->(g i).1,\(j:A)->(g j).2)
</code><h2 id="path"><a name=id><a href='../core/path/'>Path</a></a></h2><p>Path type is a $\mathbf{I}=[0,1]$ interval $Path_A(a,b)$
which elements are lambdas $i = \lambda (d: \mathbf{I}) \rightarrow A : Path_A(a,b)$
with values in $A$ such that $\{ i(0)=a$, $i(1)=b \}$.</p><code>Path (A: U) (a b: A): U</code><br><code>sym (A: U) (a b: A) (p: Path A a b): Path A b a
refl (A: U) (a: A) : Path A a a
singl (A: U) (a: A) : U
trans (A B: U) (p: Path U A B) (a: A) : B
subst (A: U) (P: A -> U) (a b: A) (p: Path A a b) (e: P a): P b
cong (A B: U) (f: A -> B) (a b: A) (p: Path A a b): Path B (f a) (f b)
composition (A: U) (a b c: A) (p: Path A a b) (q: Path A b c): Path A a c
kan (A: U) (a b c d: A) (p: Path A a b) (q: Path A a c) (r: Path A b d): Path A c d</code><br><code>J (A: U) (a x: A)
  (C: (x: A) -> Path A a x -> U)
  (d: C a (refl A a))
  (p: Path A a x): C x p</code><br><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    1.12 Identity types;
    1.12.1 Path induction;
    2.1 Types are higher groupoids;
    2.11 Identity type;
    3.11 Contractibility;
    6.2 Induction principles and dependent paths.
</p><h2 id="groupoid"><font color="#7D8A96">Groupoid</font></h2><p><b>Definition</b> (n-Types). n-truncated objects in $(\infty,1)$-topos called n-types.
Two object $X$, $Y$ are of the same homotopy type if there is a zig-zag of morphisms
connecting them. That induced equality $\pi_k(X) = \pi_k(Y), 0 \le k \le n$.
Homotopy n-types are equivalence classes of an equivalence relation of objects
objects in $(\infty,1)$-topos. The internalized homotopical interpretation of
such classes is the <mark>n_grpd</mark> function that constructs the hierarchy
from ground up.</p><code>data N = Z  | S (n: N)

n_grpd (A: U) (n: N): U = (a b: A) -> ((rec A a b) n) where
  rec (A: U) (a b: A): N -> U = split
    Z -> Path A a b
    S n -> n_grpd (Path A a b) n

isContr     (A: U): U = (x: A) * ((y: A) -> Path A x y)
isProp      (A: U): U = n_grpd A Z
isSet       (A: U): U = n_grpd A (S Z)
isGroupoid  (A: U): U = n_grpd A (S (S Z))
isGrp2      (A: U): U = n_grpd A (S (S (S Z)))
isGrp3      (A: U): U = n_grpd A (S (S (S (S Z))))</code><br><code>inf_grpd (A: U): U
  = (carrier: A)
  * (eq: (a b: A) -> Path A a b)
  * ((a b: A) -> inf_grpd (Path A a b))

isInfinityGroupoid (A: U): U = inf_grpd A</code><br><code>PROP         : U = (X:U) * isProp X
SET          : U = (X:U) * isSet X
GROUPOID     : U = (X:U) * isGroupoid X
INF_GROUPOID : U = (X:U) * isInfinityGroupoid X
</code><h2 id="W"><font color="#7D8A96">Well-Founded Trees</font></h2><p>W types are generalisation of trees to encode Nat and List
which should be derivable in any MLTT theory.
W types here are encoded with Sigma.</p><code>W (A:U) (B:A->U): U = (x:A) * (B(x) -> W A B)</code><br><code>Wrec (A:U) (B:A->U) (P:U)
     (alg: (a:A) (f:B(a)->W A B) (h:(b:B(a))->P) -> P)
   : (w: W A B) -> P
   = \(w:W A B) -> alg w.1 w.2 (\(b:B(w.1)) -> Wrec A B P alg (w.2 b))

Wind (A:U) (B:A->U) (P:W A B -> U)
     (alg: (a:A) (f:B(a)->W A B) (h:(b:B(a))->P (f b)) -> P (a,f))
   : (w: W A B) -> P w
   = \(w:W A B) -> alg w.1 w.2 (\(b:B(w.1)) -> Wind A B P alg (w.2 b))</code><br><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    5.3 W-types.
</p><h2 id="setoid"><font color="#7D8A96">Setoid</font></h2><p>Setoid was a first modeling of equality by its properties:
reflexivity, symmetry and transitivity by Errett Bishop in 1967.
</p><code>Setoid (A: U): U
  = (Carrier: A)
  * (Equ: (a b: A) -> Path A a b)
  * (Refl: (x: A) -> Equ x x)
  * (Trans: (x₁,x₂,x₃: A) -> Equ x₁ x₂ -> Equ x₂ x₃ -> Equ x₁ x₃)
  * (Sym: (x₁,x₂: A) -> Equ x₁ x₂ -> Equ x₂ x₁)

</code></section><div class="om"><section><h1>Inductive Data Types</h1></section></div><section><p>Inductive Types represent polynomial functors
equiped with recursor and indunction principle.
Inductive types are used for specification of
evaluation protocol for particular computations.
</p><h2 id="empty"><font color="#7D8A96">Empty</font></h2><p><b>empty</b> type lacks both introduction rules and eliminators.
However, it has recursor and induction.</p><code>data empty =</code><br><code>emptyRec (C: U): empty -> C = split {}
emptyInd (C: empty -> U): (z: empty) -> C z = split {}
</code><h2 id="unit"><font color="#7D8A96">Unit</font></h2><code>data unit = star</code><br><code>unitRec (C: U) (x: C): unit -> C = split tt -> x
unitInd (C: unit -> U) (x: C tt): (z: unit) -> C z = split tt -> x</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    2.8 The unit type
</p><h2 id="either"><font color="#7D8A96">Either</font></h2><p><b>either</b> is a representation for sum types or disjunction.</p><code>data either (A B: U) = left (x: A) | right (y: B)</code><br><code>eitherRec (A B C: U) (b: A -> C) (c: B -> C): either A B -> C
        = split { inl x -> b(x) ; inr y -> c(y) }

eitherInd (A B: U) (C: either A B -> U)
          (x: (a: A) -> C (inl a))
          (y: (b: B) -> C (inr b))
        : (x: either A B) -> C x
        = split { inl i -> x i ; inr j -> y j }
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    1.7 Coproduct types; and
    2.12 Coproducts.
</p><h2 id="tuple"><a name=prod><font color="#7D8A96">Tuple</font></a></h2><p><b>tuple</b> is a representation for non-dependent
product types or conjunction.</p><code>data tuple (A B: U) = pair (x: A) (y: B)
prod (A B: U) (x: A) (y: B): (_: A) * B = (x,y)</code><br><code>tupleRec  (A B C: U) (c: (x:A) (y:B) -> C): (x: tuple A B) -> C
        = split pair a b -> c a b
tupleInd  (A B: U) (C: tuple A B -> U)
          (c: (x:A)(y:B) -> C (pair x y))
        : (x: tuple A B) -> C x
        = split pair a b -> c a b
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    2.6 Cartesian product types.
</p><h2 id="bool"><a name='bool'><font color="#7D8A96">Bool</font></a></h2><p><b>bool</b> is a run-time version of the boolean logic you
may use in your general purpose applications. <b>bool</b>
is isomorphic to <b>1+1</b>: either unit unit.</p><code>data bool = false | true</code><br><code>b1: U = bool -> bool
b2: U = bool -> bool -> bool</code><br><code>negation: b1 = split { false -> true ; true -> false }
or:  b2 = split { false -> idfun bool ; true -> lambda bool bool true  }
and: b2 = split { false -> lambda bool bool false ; true -> idfun bool }</code><br><code>boolEq: b2 = lambda bool (bool -> bool) negation
boolRec (C: U) (f t: C): bool -> C = split { false -> f ; true -> t }
boolInd (C: bool -> U) (f: A false) (t: A true): (n:bool) -> A n
      = split { false -> f ; true -> t }</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    1.8 The type of booleans
</p><h2 id="maybe"><a href='../core/maybe/'>Maybe</a></a></h2><p>Maybe has representing functor M<sub>A</sub>(X) = 1 + A.
It is used for wrapping values with optional nothing constructor.
In ML-family languages this type is called Option (Miranda, ML).
There is an <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/maybe_nat.ctt">isomorphims</a>
between <b>(fix maybe)</b> and <b>nat</b>.</p><code>data maybe (A: U) = nothing | just (x: A)</code><br><code>maybeRec (A P: U) (n: P) (j: A -> P): maybe A -> P
       = split { nothing -> n; just a -> j a }

maybeInd (A: U) (P: maybe A -> U) (n: P nothing)
         (j: (a: A) -> P (just a)): (a: maybe A) -> P a
       = split { nothing -> n ; just x -> j x }
</code><h2 id="nat"><a name='nat'><a href='../core/nat/'>Nat</a></a></h2><p>Pointed Unary System is a category nat with the terminal object
and a carrier <b>nat</b> having morphism <b>[zero:
1<sub>nat</sub> → nat, succ: nat → nat]</b>. The initial
object of nat is called Natural Number Object and models
Peano axiom set.</p><code>data nat = zero | succ (n: nat)</code><br><code>natEq: nat -> nat -> bool
natCase (C:U) (a b: C): nat -> C
natRec  (C:U) (z: C) (s: nat->C->C): (n:nat) -> C
natElim (C:nat->U) (z: C zero) (s: (n:nat)->C(succ n)): (n:nat) -> C(n)
natInd  (C:nat->U) (z: C zero) (s: (n:nat)->C(n)->C(succ n)): (n:nat) -> C(n)
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    1.9 The natural numbers; and
    2.13 Natural numbers.
</p><h2 id="list"><a name='list'><a href='../core/list/'>List</a></a></h2><p>The data type of <b>list</b> over a given set A can
be represented as the initial algebra (&mu;&nbsp;L<sub>A</sub>,&nbsp;in)
of the functor L<sub>A</sub>(X) = 1 + (A &times; X).
Denote &mu; L<sub>A</sub> = List(A). The constructor
functions nil: 1 &rightarrow; List(A) and cons: A
&times; List(A) &rightarrow; List(A) are defined
by nil = in ◦ inl and cons = in ◦ inr, so
in = <b>[nil,cons]</b>.
</p><code>data list (A: U) = nil | cons (x:A) (xs: list A)</code><br><code>listCase (A C:U) (a b: C): list A -> C
listRec (A C:U) (z: C) (s: A->list A->C->C): (n:list A) -> C
listElim (A: U) (C:list A->U) (z: C nil) (s: (x:A)(xs:list A)->C(cons x xs)): (n:list A) -> C(n)
listInd (A: U) (C:list A->U) (z: C nil) (s: (x:A)(xs:list A)->C(xs)->C(cons x xs)): (n:list A) -> C(n)</code><br><code>null (A:U): list A −> bool
head (A:U): list A −> maybe A
tail (A:U): list A −> maybe (list A)
nth (A:U): nat −> list A −> maybeA
append (A: U): list A −> list A −> list A
reverse (A: U): list A −> list A
map (A B: U): (A −> B) −> list A −> list B
zip (AB: U): list A −> list B −> list (tuple A B)
foldr (AB: U): (A −> B −> B) −> B −> list A −> B
foldl (AB: U): (B −> A −> B) −> B −> list A −> B
switch (A: U): (Unit −> list A) −> bool −> list A
filter (A: U): (A −> bool) −> list A −> list A
length (A: U): list A −> nat
listEq (A: eq): list A.1 −> list A.1 −> bool
</code><h2 id="stream"><a name='stream'><a href='../core/stream/'>Stream</a></a></h2><p><b>stream</b> is a record form of the list's
<b>cons</b> constructor. It models the infinity
list that has no terminal element.</p><code>data stream (A: U) = cons (x: A) (xs: stream A)
</code><h2 id="fin"><a name='fin'><font color="#7D8A96">Fin</font></a></h2><p><b>fin</b> is the inductive defintion of set with finite elements.</p><code>data fin (n: nat)
   = fzero | fsucc (_: fin (pred n))

fz (n: nat): fin (succ n)          = fzero
fs (n: nat): fin n -> fin (succ n) = \(x: fin n) -> fsucc x
</code><h2 id="vector"><a name='vector'><font color="#7D8A96">Vector</font></a></h2><p><b>vector</b> is the inductive defintion of limited length list.</p><code>data vector (A: U) (n: nat)
   = nil | cons (_: A) (_: vector A (pred n))
</code><h2 id="seq"><a name='seq'>Seq</a></h2><p><b>seq</b> &mdash; abstract compositional sequences.</p><code>data seq (A: U) (B: A -> A -> U) (X Y: A)
   = seqNil (_: A)
   | seqCons (X Y Z: A) (_: B X Y) (_: Seq A B Y Z)
</code></section><div class="om"><section><h1>Abstract Algebra</h1></section></div><section><h2 id="monoid"><a name="monoid"><font color="#7D8A96">Monoid</font></a></h2><code>isAssociative (M: U) (op: M -> M -> M) : U

hasIdentity (M : U) (op : M -> M -> M) (id : M) : U
  = (_ : hasLeftIdentity M op id)
  * (hasRightIdentity M op id)

isMonoid (M: SET): U
  = (op: M.1 -> M.1 -> M.1)
  * (_: isAssociative M.1 op)
  * (id: M.1)
  * (hasIdentity M.1 op id)
</code><h2 id="cmonoid"><font color="#7D8A96">Commutative Monoid</font></h2><code>isCommutative (M: U) (op: M -> M -> M): U
  = (x y: M) -> Path M (op x y) (op y x)

isCMonoid (M: SET): U
  = (m: isMonoid M)
  * (isCommutative M.1 m.1)
</code><h2 id="group"><font color="#7D8A96">Group</font></h2><code>isGroup (G: SET): U
  = (m: isMonoid G)
  * (inv: G.1 -> G.1)
  * (hasInverse G.1 m.1 m.2.2.1 inv)
</code><h2 id="abgroup"><font color="#7D8A96">Abelian Group</font></h2><code>isAbGroup (G: SET): U
  = (g: isGroup G)
  * (isCommutative G.1 g.1.1)
</code><h2><font color="#7D8A96">Instances</font></h2><code>monoid:  U = (X: SET) * isMonoid X
cmonoid: U = (X: SET) * isCMonoid X
group:   U = (X: SET) * isGroup X
abgroup: U = (X: SET) * isAbGroup X
ring:    U = (X: SET) * isRing X
abring:  U = (X: SET) * isAbRing X
</code></section><div class="om"><section><h1>Control Structures</h1></section><h2><font color="#7D8A96">Signatures</font></h2><code>pure_sig       (F:U->U):U=   (A: U) ->           A  -> F A
extract_sig    (F:U->U):U=   (A: U) ->         F A  ->   A
extend_sig     (F:U->U):U= (A B: U) ->   (F A -> B) -> F A -> F B
appl_sig       (F:U->U):U= (A B: U) ->   F (A -> B) -> F A -> F B
fmap_sig       (F:U->U):U= (A B: U) ->     (A -> B) -> F A -> F B
unmap_sig      (F:U->U):U= (A B: U) -> (F A -> F B) ->  (A -> B)
contra_sig     (F:U->U):U= (A B: U) ->     (B -> A) -> F A -> F B
uncontra_sig   (F:U->U):U= (A B: U) -> (F A -> F B) ->  (B -> A)
cofmap_sig     (F:U->U):U= (A B: U) ->     (B -> A) -> F B -> F A
uncofmap_sig   (F:U->U):U= (A B: U) -> (F B -> F A) ->  (B -> A)
cocontra_sig   (F:U->U):U= (A B: U) ->     (A -> B) -> F B -> F A
uncocontra_sig (F:U->U):U= (A B: U) -> (F B -> F A) ->  (A -> B)
join_sig       (F:U->U):U=   (A: U) ->      F (F A) -> F A
dup_sig        (F:U->U):U=   (A: U) ->         F A  -> F (F A)
bind_sig       (F:U->U):U= (A B: U) ->    F A ->(A  -> F B)-> F B
</code><h2><font color="#7D8A96">Carriers</font></h2><code>pure:        U = (F: U -> U) * pure_sig F
functor:     U = (F: U -> U) * fmap_sig F

applicative: U = (F: U -> U)
               * (_: pure_sig F)
               * (_: fmap_sig F)
               *     appl_sig F

monad:       U = (F: U -> U)
               * (_: pure_sig F)
               * (_: fmap_sig F)
               * (_: appl_sig F)
               *     bind_sig F
</code><h2 id="functor"><font color="#7D8A96">Functor</font></h2><code>isFunctor (F: functor): U
  = (id: (A: U) -> (x: F.1 A) ->
     Path (F.1 A) (fmap F A A (idfun A) x) x)
  * (compose: (A B C: U) (f: B -> C) (g: A -> B) (x: F.1 A) ->
              Path (F.1 C) (F.2 A C (o A B C f g) x)
                   ((o (F.1 A) (F.1 B) (F.1 C)
                       (F.2 B C f) (F.2 A B g)) x)) * unit
</code><h2 id="applicative"><font color="#7D8A96">Applicative</font></h2><code>isApplicative (F: applicative): U
    = (id:  (A:U) -> (x: F.1 A) ->
       Path (F.1 A) x (ap F A A (apure F (id A) (idfun A)) x))
    * (hom: (A B:U)(f:A->B)(x: A) ->
       Path (F.1 B) (apure F B (f x)) (ap F A B (apure F (A->B) f) (apure F A x)))
    * (cmp: (A B C:U)(v: F.1(A->B))(u:F.1(B->C))(w:F.1 A) ->
       Path (F.1 C) (ap F B C u (ap F A B v w))
                    (ap F A C (ap F (A->B) (A->C) (ap F(B->C)((A->B)->(A->C))
                    (apure F (ot A B C) (o A B C)) u) v) w))
    * (xchg: (A B:U)(x:A)(u:F.1(A->B))(f:A->B) ->
       Path (F.1 B) (ap F A B u ((apure F) A x))
                    (ap F (A->B) B (apure F ((A->B)->B) (\(f:A->B)->f(x))) u)) * unit
</code><h2 id="monad"><font color="#7D8A96">Monad</font></h2><code>isMonad (F: monad): U
    = (one: (A B:U) (f:A->F.1 B)(x:A) -> Path (F.1 B) (bind F A B (mpure F A x) f) (f x))
    * (coone: (A:U) (m: F.1 A) -> Path (F.1 A) (bind F A A m (mpure F A)) m)
    * (assoc: (A B C: U) (f: A -> F.1 B) (g: B -> F.1 C) (m: F.1 A) ->
       Path (F.1 C) (bind F B C (bind F A B m f) g)
                    (bind F A C m (\(x: A) -> bind F B C (f x) g))) * unit</code><br><code>FUNCTOR:     U = (f: functor)
               * isFunctor f

APPLICATIVE: U = (f: applicative)
               * (_: isFunctor (f.1,f.2.2.1))
               * isApplicative f

MONAD:       U = (f: monad)
               * (_: isFunctor (f.1,f.2.2.1))
               * (_: isApplicative (f.1,f.2.1,f.2.2.1,f.2.2.2.1))
               * isMonad f
</code></div><div class="om"><section><h1>Recursion Schemes</h1></section></div><section><h2 id="fix"><font color="#7D8A96">Fix, Mu, Nu, Free, CoFree</font></h2><code>data fix    (F: U -> U) = Fix (point: F (fix F))
data mu     (F: U -> U) (A B: U)  = Return (a: A) | Bind (f: F B)
data nu     (F: U -> U) (A B: U)  = CoBind (a: A)        (f: F B)
data free   (F: U -> U) (A: U)    = Free        (_: fix (mu F A))
data cofree (F: U -> U) (A: U)    = CoFree      (_: fix (nu F A))
</code><h2><font color="#7D8A96">Cata, Ana, Futu, Histo</font></h2><code>cata (A: U) (F: functor) (alg: F.1 A -> A) (f: fix F.1): A
   = alg (F.2 (fix F.1) A (cata A F alg) (out_ F.1 f))</code><br><code>ana  (A: U) (F: functor) (coalg: A -> F.1 A) (a: A): fix F.1
   = Fix (F.2 A (fix F.1) (ana A F coalg) (coalg a))
                cat: U = (A: U) * (A -> A -> U)</code><br><code>futu (A: U) (F: functor)
     (f: A -> F.1 (free F.1 A)) (a: A): fix F.1
  = Fix (F.2 (free F.1 A) (fix F.1) (\(z: free F.1 A) -> w z) (f a)) where
  w: free F.1 A -> fix F.1 = split
    Free x -> unpack_fix x where
  unpack_free: mu F.1 A (fix (mu F.1 A)) -> fix F.1 = split
    Return x -> futu A F f x
    Bind g -> Fix (F.2 (fix (mu F.1 A)) (fix F.1)
                        (\(x: fix (mu F.1 A)) -> w (Free x)) g)
  unpack_fix: fix (mu F.1 A) -> fix F.1 = split
    Fix x -> unpack_free x</code><br><code>histo (A:U) (F: functor)
      (f: F.1 (cofree F.1 A) -> A) (z: fix F.1): A
  = extract A ((cata (cofree F.1 A) F (\(x: F.1 (cofree F.1 A)) ->
    CoFree (Fix (CoBind (f x) ((F.2 (cofree F.1 A)
    (fix (nu F.1 A)) (uncofree F.1 A) x)))))) z) where
  extract (A: U): cofree F.1 A -> A = split
    CoFree f -> unpack_fix f where
  unpack_fix: fix (nu F.1 A) -> A = split
    Fix f -> unpack_cofree f where
  unpack_cofree: nu F.1 A (fix (nu F.1 A)) -> A = split
    CoBind a -> a</code><br><code>chrono (A B: U) (F: functor)
       (f: F.1 (cofree F.1 B) -> B)
       (g: A -> F.1 (free F.1 A))
       (a: A): B = histo B F f (futu A F g a)
                cata (A: U) (F: functor) (alg: F.1 A -> A) (f: fix F.1): A
                   = alg (F.2 (fix F.1) A (cata A F alg) (out_ F.1 f))
</code><h2 id="inductive"><font color="#7D8A96">Inductive and CoInductive</font></h2><code>ind   (F: U -> U) (A: U): U
    = (in_: F (fix F) -> fix F)
    * (in_rev: fix F -> F (fix F))
    * (fold_: (F A -> A) -> fix F -> A)
    * (roll_: (F (cofree F A) -> A) -> fix F -> A)
    * unit

coind (F: U -> U) (A: U): U
    = (out_: fix F -> F (fix F))
    * (out_rev: F (fix F) -> fix F)
    * (unfold_: (A -> F A) -> A -> fix F)
    * (unroll_: (A -> F (free F A)) -> A -> fix F)
    * unit</code><br><code>inductive (F: functor) (A: U): ind F.1 A
    = (in_ F.1,out_ F.1,cata A F,futu A F,tt)
coinductive (F: functor) (A: U): coind F.1 A
    = (out_ F.1,in_ F.1,ana A F,histo A F,tt)
</code></section><div class="om"><section><h1>Category Theory</h1></section></div><section><h2 id="cat"><a name="category"><a href='category/'>Cat</a></a></h2><code>cat: U = (A: U) * (A -> A -> U)</code><br><code>isPrecategory (C: cat): U
  = (id: (x: C.1) -> C.2 x x)
  * (c: (x y z: C.1) -> C.2 x y -> C.2 y z -> C.2 x z)
  * (homSet: (x y: C.1) -> isSet (C.2 x y))
  * (left: (x y: C.1) -> (f: C.2 x y) -> Path (C.2 x y) (c x x y (id x) f) f)
  * (right: (x y: C.1) -> (f: C.2 x y) -> Path (C.2 x y) (c x y y f (id y)) f)
  * ( (x y z w: C.1) -> (f: C.2 x y) -> (g: C.2 y z) -> (h: C.2 z w) ->
  Path (C.2 x w) (c x z w (c x y z f g) h) (c x y w f (c y z w g h)))
precategory: U = (C: cat) * isPrecategory C</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    9.1 Categories and precategories.
</p><h2><font color="#7D8A96">Functors</font></h2><code>catfunctor (A B: precategory): U
  = (ob: carrier A -> carrier B)
  * (mor: (x y: carrier A) -> hom A x y -> hom B (ob x) (ob y))
  * (id: (x: carrier A) -> Path (hom B (ob x) (ob x)) (mor x x (path A x)) (path B (ob x)))
  * ((x y z: carrier A) -> (f: hom A x y) -> (g: hom A y z) ->
     Path (hom B (ob x) (ob z)) (mor x z (compose A x y z f g))
      (compose B (ob x) (ob y) (ob z) (mor x y f) (mor y z g)))</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    9.2 Functors and transformations;
    9.4 Equivalences.
</p><h2 id="coslise"><font color="#7D8A96">Coslice Category</font></h2><code>cosliceCat (C D: precategory)
           (a: carrier C)
           (F: catfunctor D C): precategory
</code><h2><font color="#7D8A96">Rezk Completion</font></h2><code>iso (C: precategory) (A B: carrier C): U
  = (f: hom C A B)
  * (g: hom C B A)
  * (_: Path (hom C A A) (compose C A B A f g) (path C A))
  * (   Path (hom C B B) (compose C B A B g f) (path C B))

isCategory    (C: precategory): U
  = (A: carrier C) -> isContr ((B: carrier C) * iso C A B)
category: U = (C: precategory) * isCategory C
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    9.9 The Rezk completion.
</p><h2><font color="#7D8A96">Initials and Terminals</font></h2><code>isInitial     (C: precategory) (x: carrier C): U = (y: carrier C) -> isContr (hom C x y)
isTerminal    (C: precategory) (y: carrier C): U = (x: carrier C) -> isContr (hom C x y)
initial       (C: precategory): U = (x: carrier C) * isInitial  C x
terminal      (C: precategory): U = (y: carrier C) * isTerminal C y
initialProp   (C: precategory) (isC: isCategory C): isProp (initial  C) = undefined
terminalProp  (C: precategory) (isC: isCategory C): isProp (terminal C) = undefined
isCommutative (X: precategory)
              (A B C D: carrier X)
              (f: hom X A B) (g: hom X C D)
              (h: hom X A C) (i: hom X B D): U
            = Path (hom X A D) (compose X A C D h g)
                               (compose X A B D f i)
</code><h2 id="univArr"><font color="#7D8A96">Universal Arrow</font></h2><code>univArr (C D: precategory)
        (a: carrier C) (F: catfunctor D C)
      : U = initial (cosliceCat C D a F)
</code><h2 id="ntrans"><font color="#7D8A96">Natural Transformations</font></h2><code>isNaturalTrans (C D: precategory)
               (F G: catfunctor C D)
               (eta: (x: carrier C) -> hom D (F.1 x) (G.1 x)): U
  = (x y: carrier C) (h: hom C x y) ->
    Path (hom D (F.1 x) (G.1 y))
         (compose D (F.1 x) (F.1 y) (G.1 y) (F.2.1 x y h) (eta y))
         (compose D (F.1 x) (G.1 x) (G.1 y) (eta x) (G.2.1 x y h))

ntrans (C D: precategory)
       (F G: catfunctor C D): U
  = (eta: (x: carrier C) -> hom D (F.1 x) (G.1 x))
  * (isNaturalTrans C D F G eta)

</code><h2 id="adj"><font color="#7D8A96">Adjunctions</font></h2><code>areAdjoint (C D: precategory)
           (F: catfunctor D C)
           (G: catfunctor C D)
           (unit: ntrans D D (idFunctor D) (compFunctor D C D F G))
           (counit: ntrans C C (compFunctor C D C G F) (idFunctor C)) : U

adjoint (C D: precategory) (F: catfunctor D C) (G: catfunctor C D) : U
  = (unit: ntrans D D (idFunctor D) (compFunctor D C D F G))
  * (counit: ntrans C C (compFunctor C D C G F) (idFunctor C))
  * areAdjoint C D F G unit counit
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    9.3 Adjunctions.
</p><h2 id="sip"><font color="#7D8A96">Structure Identity Principle</font></h2><code>structure (X: precategory): U
  = (P: carrier X -> U)
  * (H: (x y: carrier X) (a: P x) (b: P y) (f: hom X x y) -> U)
  * (propH: (x y: carrier X) (a: P x) (b: P y) (f: hom X x y) ->
    isProp (H x y a b f))
  * (Hid: (x: carrier X) (a: P x) -> H x x a a (path X x))
  * ((x y z : carrier X) (a: P x) (b: P y) (c: P z)
     (f: hom X x y) (g: hom X y z) -> H x y a b f ->
     H y z b c g -> H x z a c (compose X x y z f g))</code><br><code>isStandardStructure (X: precategory) (S: structure X): U
  = (x: carrier X) -> (a b: sP X S x) -> sH X S x x a b (path X x) ->
    sH X S x x b a (path X x) -> Path (sP X S x) a b</code><br><code>sip (X: precategory)
    (isC: isCategory X)
    (S: structure X)
    (isS: isStandardStructure X S)
  : isCategory (sipPrecategory X S)
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    9.8 The structure identity principle.
</p></section><div class="om"><section><h1>Univalent Foundations</h1></section></div><section><h2 id="equiv"><a href="equiv/">Equiv</a></h2><code>fiber   (A B: U) (f: A -> B) (y: B): U = (x: A) * Path B y (f x)
isEquiv (A B: U) (f: A -> B): U = (y: B) -> isContr (fiber A B f y)
equiv   (A B: U): U = (f: A -> B) * isEquiv A B f
equivElim (B: U) (P: (A: U) -> (A -> B) -> U)
          (d: P B (idfun B)) (A: U) (f: equiv A B): P A f.1
</code><h2 id="retract"><font color="#7D8A96">Retract</font></h2><code>section (A B:U) (f:A->B) (g:B->A): U = (b:B) -> Path B (f(g(b))) b
retract (A B:U) (f:A->B) (g:B->A): U = (a:A) -> Path A (g(f(a))) a
</code><h2 id="bundle"><a name="bundle"><a href='bundle/'>Bundle</a></a></h2><code>total   (B: U) (F: Family B): U = Sigma B F
trivial (B: U) (F: Family B): total B F -> B = \ (x: total B F) -> x.1
homeo (B E: U) (F: Family B) (p: E -> B) (y: B)
    : fiber E B p y -> total B F = \(x: fiber E B p y) -> (y,F)
</code><h2 id="iso"><a href="iso/">Iso</a></h2><code>Square (A: U) (a0 a1 b0 b1: A)
       (u: Path A a0 a1) (v: Path A b0 b1)
       (r0: Path A a0 b0) (r1: Path A a1 b1): U

lemIso (A B: U) (f: A -> B) (g: B -> A)
       (s:  section A B f g)
       (t:  retract A B f g)
       (y:  B) (x0 x1: A)
       (p0: Path B y (f x0))
       (p1: Path B y (f x1)):
       Path (fiber A B f y) (x0,p0) (x1,p1)

isoToEquiv (A B: U) (f: A -> B) (g: B -> A)
           (s: section A B f g)
           (t: retract A B f g): isEquiv A B f

isoPath    (A B: U) (f: A -> B) (g: B -> A)
           (s: section A B f g)
           (t: retract A B f g): Path U A B

isoElim (B: U) (Q: (A: U) -> (A -> B) -> (B -> A) -> U)
        (h1: Q B (idfun B) (idfun B)) (A: U) (f: A -> B)
      : (g: B -> A) -> section A B f g -> retract A B f g -> Q A f g
</code><h2 id="univ"><font color="#7D8A96">Univ</font></h2><code>univ (A B: U): Path U (Path U A B) (equiv A B)
</code></section><div class="om"><section><h1>Higher inductive types</h1></section></div><section><h2 id="i"><font color="#7D8A96">Interval</font></h2><code>data I
   = i0
   | i1
   | seg &lt;i&gt; [ (i = 0) -> i0,
               (i = 1) -> i1 ]</code><br><code>data P (A B: U)
   = p0 (_:A)
   | p1 (_:B)
   | pseg (x:A) (y:B) &lt;i&gt; [ (i = 0) -> p0 x,
                            (i = 1) -> p1 y ]</code><br><code>homotopy  (X Y: U)
          (f g: X -> Y)
          (p: (x: X) -> Path Y (f x) (g x))
          (x: X)
        : I -> Y
        = split { i0 -> f(x) ;
                  i1 -> g(x) ;
                  seg @ i -> p(x) @ i }</code><br><code>fext (A B: U) (f g: A -> B)
     (p: (x: A) -> Path B (f x) (g x))
   : Path (A -> B) f g
   = <j> (\(x : A) -> homotopy A B f g p x (seg{I} @ j))
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    6.3 The interval
</p><h2 id="circle"><font color="#7D8A96">Circle</font></h2><code>data S1
   = base
   | loop &lt;i&gt; [ (i=0) -> base ,
                (i=1) -> base ]</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    6.4 Circles and spheres
</p><h2 id="suspension"><font color="#7D8A96">Suspension</font></h2><code>data susp (A: U)
   = north
   | south
   | merid (a: A) &lt;i&gt; [ (i = 0) -> north ,
                        (i = 1) -> south ]
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    6.5 Suspensions.
</p><h2 id="pullback"><a name="pullback"><a href='pullback/'>Pullback</a></a></h2><code>pullback (A B C:U) (f: A -> C) (g: B -> C)
       : U
       = (a: A)
       * (b: B)
       * Path C (f a) (g b)
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    2.11 Exercise
</p><h2 id="pushout"><font color="#7D8A96">Pushout</font></h2><code>data pushout (A B C: U) (f: C -> A) (g: C -> B)
   = po1 (_: A)
   | po2 (_: B)
   | po3 (c: C) &lt;i&gt; [ (i = 0) -> po1 (f c),
                      (i = 1) -> po2 (g c) ]</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    6.8 Pushouts.
</p><h2 id="trunc"><font color="#7D8A96">Truncations</font></h2><code>data pTrunc (A: U) -- (-1)-trunc, mere proposition truncation
     = pinc (a: A)
    | pline (x y: pTrunc A) &lt;i&gt;
          [ (i = 0) -> x,
            (i = 1) -> y ]

data sTrunc (A: U) -- (0)-trunc, set truncation
     = sinc (a: A)
    | sline (a b: sTrunc A)
            (p q: Path (sTrunc A) a b) &lt;i j&gt;
          [ (i = 0) -> p @ j,
            (i = 1) -> q @ j,
            (j = 0) -> a,
            (j = 1) -> b ]

data gTrunc (A: U) -- (1)-trunc, groupoid truncation
   = ginc   (a: A)
   | gline  (a b: gTrunc A)
            (p q: Path (gTrunc A) a b)
            (r s: Path (Path (gTrunc A) a b) p q) &lt;i j k&gt;
          [ (i = 0) -> r @ j @ k,
            (i = 1) -> s @ j @ k,
            (j = 0) -> p @ k,
            (j = 1) -> q @ k,
            (k = 0) -> a,
            (k = 1) -> b ]
</code><p>see <a href="http://5ht.co/hott.pdf">HoTT</a>:
    6.9 Truncations.
</p><h2 id="quotient"><font color="#7D8A96">Quotients</font></h2><code>data quot (A: U) (R: A -> A -> U)
   = inj (a: A)
   | quoteq (a b: A) (r: R a b) &lt;i&gt;
          [ (i = 0) -> inj a,
            (i = 1) -> inj b ]

data setquot (A: U) (R: A -> A -> U)
   = quotient (a: A)
   | identification (a b: A) (r: R a b) &lt;i&gt;
                  [ (i = 0) -> quotient a,
                    (i = 1) -> quotient b ]
   | setTruncation  (a b: setquot A R)
                    (p q: Path (setquot A R) a b) &lt;i j&gt;
                  [ (i = 0) -> p @ j,
                    (i = 1) -> q @ j,
                    (j = 0) -> a,
                    (j = 1) -> b ]
</code><h2><a name="cw"><a href='cw/'>CW-complex</a></a></h2><p></p></section><div class="om"><section><h1>Cohesive Core</h1></section></div><section><h2 id="infinitesimal"><a name="infinitesimal"><a href='infinitesimal/'>Infinitesimal</a></a></h2><code>Im : U -> U = undefined
ImUnit (A: U) : A -> Im A = undefined

isCoreduced (A:U): U = isEquiv A (Im A) (ImUnit A)
ImCoreduced (A:U): isCoreduced (Im A) = undefined
ImRecursion (A B: U) (c: isCoreduced B) (f: A -> B) : Im A -> B = undefined
ImInduction (A:U)(B:Im A->U)(x: (a: Im A)->isCoreduced(B a))
            (y:(a: A)->B(ImUnit A a)):(a:Im A)->B a = undefined
</code><p><center><table cellspacing=20><tr><td><img src="https://n2o.space/img/pdf.jpg" width=50></td><td width=400>
<a href="https://github.com/groupoid/groupoid.space/blob/master/articles/types/types.pdf">
<h3>Mathematical Components for Cubical Syntax</h3></a>
</td></tr></table></center>
</p><br><br><hr><br></section><div class="types"><h2>Homotopy Core</h2><br><div class="type"><ol class="type__col"><h3>PURE</h3><li><a href="#pi">PI</a></li></ol><ol class="type__col"><h3>MLTT</h3><li><a href="#pi">PI</a></li><li><a href="#sigma">SIGMA</a></li><li><a href="#id">ID</a></li><li><a href="#W">W</a></li></ol><ol class="type__col"><h3>INDUCTIVE</h3><li><a href="#pi">PI</a></li><li><a href="#sigma">SIGMA</a></li><li><a href="#id">ID</a></li><li><a href="#fix">FIX</a></li><li><a href="#inductive">INDUCTIVE</a></li></ol><ol class="type__col"><h3>CUBICAL</h3><li><a href="#pi">PI</a></li><li><a href="#sigma">SIGMA</a></li><li><a href="#path">PATH</a></li><li><a href="#Compose">COMPOSE</a></li><li><a href="#Glue">GLUE</a></li><li><a href="#higher inductive types">HIGHER INDUCTIVE TYPES</a></li></ol></div><br></div><section><p>Cubical with HITs has very lightweight core and syntax, and
is an internal language of $(\infty,1)$-topos.
Cubical with $[0,1]$ Path types but without HITs is an
internal language of $(\infty,1)$-categories, while MLTT
is an internal language of locally cartesian closed categories.</p><br><br><hr><br></section><div class="types"><h2>Cohesive Core</h2><br><div class="type"><ol class="type__col"><h3>COHESIVE</h3><li><a href="#shape">SHAPE</a></li><li><a href="#flat">FLAT</a></li><li><a href="#sharp">SHARP</a></li></ol><ol class="type__col"><h3>DIFFERENTIAL</h3><li><a href="#reduction">REDUCTION</a></li><li><a href="#infinitesimal">INFINITESIMAL</a></li><li><a href="#smooth">SMOOTH</a></li></ol></div><br></div><section><p>Cohesive Type Theory is developed to satisfy needs of modeling modalities,
such as connectedness, compactness, infinitesimal shapes, etc. Differential
Cohesive Type Theory is an internal language of differential cohesive $(\infty,1)$-topoi, with
extra structure, just as $(\infty,1)$-categories add a globular path equality structure
to locally cartesian closed categories and their internal language &mdash; MLTT.
Please refer to <a href="https://hott-uf.github.io/2017/abstracts/cohesivett.pdf">cohesivett</a>
for more information.</p><p>Cohesive types modeled in base library and undefined axioms.
Process Calculus is another example of modality types with special comonadic spawn
arrows hiding the underlying run-time implementation.</p><br><br><hr><br></section><div class="types"><h2>Types Taxonomy</h2><br><div class="type"><ol class="type__col"><h3>NR ND +</h3><li><a href="#unit">UNIT</a></li><li><a href="#bool">BOOL</a></li><li><a href="#maybe">MAYBE</a></li><li><a href="#either">EITHER</a></li><li><a href="#tuple">TUPLE</a></li></ol><ol class="type__col"><h3>R ND +</h3><li><a href="#fix">FIX</a></li><li><a href="#nat">NAT</a></li><li><a href="#list">LIST</a></li></ol><ol class="type__col"><h3>NR D +</h3><li><a href="#exists">EXISTS</a></li></ol><ol class="type__col"><h3>RD +</h3><li><a href="#fin">FIN</a></li><li><a href="#vector">VECTOR</a></li><li><a href="#W">W</a></li><li><a href="#seq">SEQ</a></li></ol></div><div class="type"><ol class="type__col"><h3>NR ND *</h3><li><a href="#prod">PROD</a></li><li><a href="#pure">PURE</a></li><li><a href="#functor">FUNCTOR</a></li><li><a href="#applicative">APPLICATIVE</a></li><li><a href="#monad">MONAD</a></li></ol><ol class="type__col"><h3>R ND *</h3><li><a href="#stream">STREAM</a></li></ol><ol class="type__col"><h3>NR D *</h3><li><a href="#sigma">SIGMA</a></li><li><a href="#bundle">BUNDLE</a></li><li><a href="#iso">ISO</a></li><li><a href="#equiv">EQUIV</a></li><li><a href="#fiber">FIBER</a></li><li><a href="#pullback">PULLBACK</a></li><li><a href="#category">CATEGORY</a></li></ol><ol class="type__col"><h3>HIT</h3><li><a href="#groupoid">GROUPOID</a></li><li><a href="#infinity">INFINITY</a></li><li><a href="#pushout">PUSHOUT</a></li><li><a href="#S1">S1</a></li><li><a href="#S2">S2</a></li><li><a href="#hopf">HOPF</a></li><li><a href="#cw">CW</a></li></ol></div><br></div><section><p>Types taxonomy shows us the core types categorized by a several axis:
1) dependent (D) and non-dependent (ND) terms;
2) recursive trees (R) or non-recursive (NR) data types;
3) inductive (+, positive) or coinductive (*, negative) types.</p><br><br></section></article><footer class="footer"><a href="https://github.com/groupoid/"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"></a><span class="footer__copy">2016&mdash;2021 &copy; <a href="//5ht.co/" style="color:Lavender;">Максим Сохацький</a></span></footer><script src="https://groupoid.space/bundle.js?v=7"></script><script src="https://groupoid.space/highlight.js?v=20"></script></body></html>